
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model TenantModule
 * 
 */
export type TenantModule = $Result.DefaultSelection<Prisma.$TenantModulePayload>
/**
 * Model TenantUser
 * 
 */
export type TenantUser = $Result.DefaultSelection<Prisma.$TenantUserPayload>
/**
 * Model Driver
 * 
 */
export type Driver = $Result.DefaultSelection<Prisma.$DriverPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserPermission
 * 
 */
export type UserPermission = $Result.DefaultSelection<Prisma.$UserPermissionPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model HotelRequest
 * 
 */
export type HotelRequest = $Result.DefaultSelection<Prisma.$HotelRequestPayload>
/**
 * Model HotelBooking
 * 
 */
export type HotelBooking = $Result.DefaultSelection<Prisma.$HotelBookingPayload>
/**
 * Model HotelPricePool
 * 
 */
export type HotelPricePool = $Result.DefaultSelection<Prisma.$HotelPricePoolPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model TourBooking
 * 
 */
export type TourBooking = $Result.DefaultSelection<Prisma.$TourBookingPayload>
/**
 * Model TenantWebsite
 * 
 */
export type TenantWebsite = $Result.DefaultSelection<Prisma.$TenantWebsitePayload>
/**
 * Model WebsitePage
 * 
 */
export type WebsitePage = $Result.DefaultSelection<Prisma.$WebsitePagePayload>
/**
 * Model WebsiteSettings
 * 
 */
export type WebsiteSettings = $Result.DefaultSelection<Prisma.$WebsiteSettingsPayload>
/**
 * Model WebsiteSection
 * 
 */
export type WebsiteSection = $Result.DefaultSelection<Prisma.$WebsiteSectionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPERUSER: 'SUPERUSER',
  OPERATION: 'OPERATION',
  SELLER: 'SELLER',
  ACCOUNTANT: 'ACCOUNTANT',
  AGENCY_ADMIN: 'AGENCY_ADMIN',
  AGENCY_USER: 'AGENCY_USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantModule`: Exposes CRUD operations for the **TenantModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantModules
    * const tenantModules = await prisma.tenantModule.findMany()
    * ```
    */
  get tenantModule(): Prisma.TenantModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantUser`: Exposes CRUD operations for the **TenantUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantUsers
    * const tenantUsers = await prisma.tenantUser.findMany()
    * ```
    */
  get tenantUser(): Prisma.TenantUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPermission`: Exposes CRUD operations for the **UserPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPermissions
    * const userPermissions = await prisma.userPermission.findMany()
    * ```
    */
  get userPermission(): Prisma.UserPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelRequest`: Exposes CRUD operations for the **HotelRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelRequests
    * const hotelRequests = await prisma.hotelRequest.findMany()
    * ```
    */
  get hotelRequest(): Prisma.HotelRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelBooking`: Exposes CRUD operations for the **HotelBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelBookings
    * const hotelBookings = await prisma.hotelBooking.findMany()
    * ```
    */
  get hotelBooking(): Prisma.HotelBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelPricePool`: Exposes CRUD operations for the **HotelPricePool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelPricePools
    * const hotelPricePools = await prisma.hotelPricePool.findMany()
    * ```
    */
  get hotelPricePool(): Prisma.HotelPricePoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tourBooking`: Exposes CRUD operations for the **TourBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TourBookings
    * const tourBookings = await prisma.tourBooking.findMany()
    * ```
    */
  get tourBooking(): Prisma.TourBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantWebsite`: Exposes CRUD operations for the **TenantWebsite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantWebsites
    * const tenantWebsites = await prisma.tenantWebsite.findMany()
    * ```
    */
  get tenantWebsite(): Prisma.TenantWebsiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.websitePage`: Exposes CRUD operations for the **WebsitePage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebsitePages
    * const websitePages = await prisma.websitePage.findMany()
    * ```
    */
  get websitePage(): Prisma.WebsitePageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.websiteSettings`: Exposes CRUD operations for the **WebsiteSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebsiteSettings
    * const websiteSettings = await prisma.websiteSettings.findMany()
    * ```
    */
  get websiteSettings(): Prisma.WebsiteSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.websiteSection`: Exposes CRUD operations for the **WebsiteSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebsiteSections
    * const websiteSections = await prisma.websiteSection.findMany()
    * ```
    */
  get websiteSection(): Prisma.WebsiteSectionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    Module: 'Module',
    TenantModule: 'TenantModule',
    TenantUser: 'TenantUser',
    Driver: 'Driver',
    User: 'User',
    UserPermission: 'UserPermission',
    Activity: 'Activity',
    Reservation: 'Reservation',
    HotelRequest: 'HotelRequest',
    HotelBooking: 'HotelBooking',
    HotelPricePool: 'HotelPricePool',
    Vehicle: 'Vehicle',
    TourBooking: 'TourBooking',
    TenantWebsite: 'TenantWebsite',
    WebsitePage: 'WebsitePage',
    WebsiteSettings: 'WebsiteSettings',
    WebsiteSection: 'WebsiteSection'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "module" | "tenantModule" | "tenantUser" | "driver" | "user" | "userPermission" | "activity" | "reservation" | "hotelRequest" | "hotelBooking" | "hotelPricePool" | "vehicle" | "tourBooking" | "tenantWebsite" | "websitePage" | "websiteSettings" | "websiteSection"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      TenantModule: {
        payload: Prisma.$TenantModulePayload<ExtArgs>
        fields: Prisma.TenantModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload>
          }
          findFirst: {
            args: Prisma.TenantModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload>
          }
          findMany: {
            args: Prisma.TenantModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload>[]
          }
          create: {
            args: Prisma.TenantModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload>
          }
          createMany: {
            args: Prisma.TenantModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload>[]
          }
          delete: {
            args: Prisma.TenantModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload>
          }
          update: {
            args: Prisma.TenantModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload>
          }
          deleteMany: {
            args: Prisma.TenantModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload>[]
          }
          upsert: {
            args: Prisma.TenantModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantModulePayload>
          }
          aggregate: {
            args: Prisma.TenantModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantModule>
          }
          groupBy: {
            args: Prisma.TenantModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantModuleCountArgs<ExtArgs>
            result: $Utils.Optional<TenantModuleCountAggregateOutputType> | number
          }
        }
      }
      TenantUser: {
        payload: Prisma.$TenantUserPayload<ExtArgs>
        fields: Prisma.TenantUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload>
          }
          findFirst: {
            args: Prisma.TenantUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload>
          }
          findMany: {
            args: Prisma.TenantUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload>[]
          }
          create: {
            args: Prisma.TenantUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload>
          }
          createMany: {
            args: Prisma.TenantUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload>[]
          }
          delete: {
            args: Prisma.TenantUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload>
          }
          update: {
            args: Prisma.TenantUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload>
          }
          deleteMany: {
            args: Prisma.TenantUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload>[]
          }
          upsert: {
            args: Prisma.TenantUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantUserPayload>
          }
          aggregate: {
            args: Prisma.TenantUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantUser>
          }
          groupBy: {
            args: Prisma.TenantUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantUserCountArgs<ExtArgs>
            result: $Utils.Optional<TenantUserCountAggregateOutputType> | number
          }
        }
      }
      Driver: {
        payload: Prisma.$DriverPayload<ExtArgs>
        fields: Prisma.DriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findFirst: {
            args: Prisma.DriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findMany: {
            args: Prisma.DriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          create: {
            args: Prisma.DriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          createMany: {
            args: Prisma.DriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          delete: {
            args: Prisma.DriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          update: {
            args: Prisma.DriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          deleteMany: {
            args: Prisma.DriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          upsert: {
            args: Prisma.DriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.DriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverCountArgs<ExtArgs>
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserPermission: {
        payload: Prisma.$UserPermissionPayload<ExtArgs>
        fields: Prisma.UserPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          findFirst: {
            args: Prisma.UserPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          findMany: {
            args: Prisma.UserPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>[]
          }
          create: {
            args: Prisma.UserPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          createMany: {
            args: Prisma.UserPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>[]
          }
          delete: {
            args: Prisma.UserPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          update: {
            args: Prisma.UserPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          deleteMany: {
            args: Prisma.UserPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>[]
          }
          upsert: {
            args: Prisma.UserPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          aggregate: {
            args: Prisma.UserPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPermission>
          }
          groupBy: {
            args: Prisma.UserPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<UserPermissionCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReservationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      HotelRequest: {
        payload: Prisma.$HotelRequestPayload<ExtArgs>
        fields: Prisma.HotelRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload>
          }
          findFirst: {
            args: Prisma.HotelRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload>
          }
          findMany: {
            args: Prisma.HotelRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload>[]
          }
          create: {
            args: Prisma.HotelRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload>
          }
          createMany: {
            args: Prisma.HotelRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload>[]
          }
          delete: {
            args: Prisma.HotelRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload>
          }
          update: {
            args: Prisma.HotelRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload>
          }
          deleteMany: {
            args: Prisma.HotelRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload>[]
          }
          upsert: {
            args: Prisma.HotelRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRequestPayload>
          }
          aggregate: {
            args: Prisma.HotelRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelRequest>
          }
          groupBy: {
            args: Prisma.HotelRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelRequestCountArgs<ExtArgs>
            result: $Utils.Optional<HotelRequestCountAggregateOutputType> | number
          }
        }
      }
      HotelBooking: {
        payload: Prisma.$HotelBookingPayload<ExtArgs>
        fields: Prisma.HotelBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          findFirst: {
            args: Prisma.HotelBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          findMany: {
            args: Prisma.HotelBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>[]
          }
          create: {
            args: Prisma.HotelBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          createMany: {
            args: Prisma.HotelBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>[]
          }
          delete: {
            args: Prisma.HotelBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          update: {
            args: Prisma.HotelBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          deleteMany: {
            args: Prisma.HotelBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>[]
          }
          upsert: {
            args: Prisma.HotelBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          aggregate: {
            args: Prisma.HotelBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelBooking>
          }
          groupBy: {
            args: Prisma.HotelBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelBookingCountArgs<ExtArgs>
            result: $Utils.Optional<HotelBookingCountAggregateOutputType> | number
          }
        }
      }
      HotelPricePool: {
        payload: Prisma.$HotelPricePoolPayload<ExtArgs>
        fields: Prisma.HotelPricePoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelPricePoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelPricePoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload>
          }
          findFirst: {
            args: Prisma.HotelPricePoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelPricePoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload>
          }
          findMany: {
            args: Prisma.HotelPricePoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload>[]
          }
          create: {
            args: Prisma.HotelPricePoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload>
          }
          createMany: {
            args: Prisma.HotelPricePoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelPricePoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload>[]
          }
          delete: {
            args: Prisma.HotelPricePoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload>
          }
          update: {
            args: Prisma.HotelPricePoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload>
          }
          deleteMany: {
            args: Prisma.HotelPricePoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelPricePoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelPricePoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload>[]
          }
          upsert: {
            args: Prisma.HotelPricePoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPricePoolPayload>
          }
          aggregate: {
            args: Prisma.HotelPricePoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelPricePool>
          }
          groupBy: {
            args: Prisma.HotelPricePoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelPricePoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelPricePoolCountArgs<ExtArgs>
            result: $Utils.Optional<HotelPricePoolCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      TourBooking: {
        payload: Prisma.$TourBookingPayload<ExtArgs>
        fields: Prisma.TourBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload>
          }
          findFirst: {
            args: Prisma.TourBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload>
          }
          findMany: {
            args: Prisma.TourBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload>[]
          }
          create: {
            args: Prisma.TourBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload>
          }
          createMany: {
            args: Prisma.TourBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload>[]
          }
          delete: {
            args: Prisma.TourBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload>
          }
          update: {
            args: Prisma.TourBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload>
          }
          deleteMany: {
            args: Prisma.TourBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TourBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload>[]
          }
          upsert: {
            args: Prisma.TourBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBookingPayload>
          }
          aggregate: {
            args: Prisma.TourBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTourBooking>
          }
          groupBy: {
            args: Prisma.TourBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourBookingCountArgs<ExtArgs>
            result: $Utils.Optional<TourBookingCountAggregateOutputType> | number
          }
        }
      }
      TenantWebsite: {
        payload: Prisma.$TenantWebsitePayload<ExtArgs>
        fields: Prisma.TenantWebsiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantWebsiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantWebsiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          findFirst: {
            args: Prisma.TenantWebsiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantWebsiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          findMany: {
            args: Prisma.TenantWebsiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>[]
          }
          create: {
            args: Prisma.TenantWebsiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          createMany: {
            args: Prisma.TenantWebsiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantWebsiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>[]
          }
          delete: {
            args: Prisma.TenantWebsiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          update: {
            args: Prisma.TenantWebsiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          deleteMany: {
            args: Prisma.TenantWebsiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantWebsiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantWebsiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>[]
          }
          upsert: {
            args: Prisma.TenantWebsiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          aggregate: {
            args: Prisma.TenantWebsiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantWebsite>
          }
          groupBy: {
            args: Prisma.TenantWebsiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantWebsiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantWebsiteCountArgs<ExtArgs>
            result: $Utils.Optional<TenantWebsiteCountAggregateOutputType> | number
          }
        }
      }
      WebsitePage: {
        payload: Prisma.$WebsitePagePayload<ExtArgs>
        fields: Prisma.WebsitePageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebsitePageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebsitePageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload>
          }
          findFirst: {
            args: Prisma.WebsitePageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebsitePageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload>
          }
          findMany: {
            args: Prisma.WebsitePageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload>[]
          }
          create: {
            args: Prisma.WebsitePageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload>
          }
          createMany: {
            args: Prisma.WebsitePageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebsitePageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload>[]
          }
          delete: {
            args: Prisma.WebsitePageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload>
          }
          update: {
            args: Prisma.WebsitePageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload>
          }
          deleteMany: {
            args: Prisma.WebsitePageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebsitePageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebsitePageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload>[]
          }
          upsert: {
            args: Prisma.WebsitePageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePagePayload>
          }
          aggregate: {
            args: Prisma.WebsitePageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsitePage>
          }
          groupBy: {
            args: Prisma.WebsitePageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebsitePageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebsitePageCountArgs<ExtArgs>
            result: $Utils.Optional<WebsitePageCountAggregateOutputType> | number
          }
        }
      }
      WebsiteSettings: {
        payload: Prisma.$WebsiteSettingsPayload<ExtArgs>
        fields: Prisma.WebsiteSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebsiteSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebsiteSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          findFirst: {
            args: Prisma.WebsiteSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebsiteSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          findMany: {
            args: Prisma.WebsiteSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>[]
          }
          create: {
            args: Prisma.WebsiteSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          createMany: {
            args: Prisma.WebsiteSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebsiteSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>[]
          }
          delete: {
            args: Prisma.WebsiteSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          update: {
            args: Prisma.WebsiteSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          deleteMany: {
            args: Prisma.WebsiteSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebsiteSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebsiteSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>[]
          }
          upsert: {
            args: Prisma.WebsiteSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          aggregate: {
            args: Prisma.WebsiteSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsiteSettings>
          }
          groupBy: {
            args: Prisma.WebsiteSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebsiteSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebsiteSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<WebsiteSettingsCountAggregateOutputType> | number
          }
        }
      }
      WebsiteSection: {
        payload: Prisma.$WebsiteSectionPayload<ExtArgs>
        fields: Prisma.WebsiteSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebsiteSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebsiteSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload>
          }
          findFirst: {
            args: Prisma.WebsiteSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebsiteSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload>
          }
          findMany: {
            args: Prisma.WebsiteSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload>[]
          }
          create: {
            args: Prisma.WebsiteSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload>
          }
          createMany: {
            args: Prisma.WebsiteSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebsiteSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload>[]
          }
          delete: {
            args: Prisma.WebsiteSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload>
          }
          update: {
            args: Prisma.WebsiteSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload>
          }
          deleteMany: {
            args: Prisma.WebsiteSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebsiteSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebsiteSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload>[]
          }
          upsert: {
            args: Prisma.WebsiteSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSectionPayload>
          }
          aggregate: {
            args: Prisma.WebsiteSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsiteSection>
          }
          groupBy: {
            args: Prisma.WebsiteSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebsiteSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebsiteSectionCountArgs<ExtArgs>
            result: $Utils.Optional<WebsiteSectionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    module?: ModuleOmit
    tenantModule?: TenantModuleOmit
    tenantUser?: TenantUserOmit
    driver?: DriverOmit
    user?: UserOmit
    userPermission?: UserPermissionOmit
    activity?: ActivityOmit
    reservation?: ReservationOmit
    hotelRequest?: HotelRequestOmit
    hotelBooking?: HotelBookingOmit
    hotelPricePool?: HotelPricePoolOmit
    vehicle?: VehicleOmit
    tourBooking?: TourBookingOmit
    tenantWebsite?: TenantWebsiteOmit
    websitePage?: WebsitePageOmit
    websiteSettings?: WebsiteSettingsOmit
    websiteSection?: WebsiteSectionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    activities: number
    reservations: number
    drivers: number
    hotelBookings: number
    hotelPricePool: number
    hotelRequests: number
    modules: number
    users: number
    tourBookings: number
    vehicles: number
    websites: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | TenantCountOutputTypeCountActivitiesArgs
    reservations?: boolean | TenantCountOutputTypeCountReservationsArgs
    drivers?: boolean | TenantCountOutputTypeCountDriversArgs
    hotelBookings?: boolean | TenantCountOutputTypeCountHotelBookingsArgs
    hotelPricePool?: boolean | TenantCountOutputTypeCountHotelPricePoolArgs
    hotelRequests?: boolean | TenantCountOutputTypeCountHotelRequestsArgs
    modules?: boolean | TenantCountOutputTypeCountModulesArgs
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    tourBookings?: boolean | TenantCountOutputTypeCountTourBookingsArgs
    vehicles?: boolean | TenantCountOutputTypeCountVehiclesArgs
    websites?: boolean | TenantCountOutputTypeCountWebsitesArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountHotelBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelBookingWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountHotelPricePoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelPricePoolWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountHotelRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelRequestWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantModuleWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantUserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTourBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourBookingWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWebsitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWebsiteWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    tenantModules: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenantModules?: boolean | ModuleCountOutputTypeCountTenantModulesArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountTenantModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantModuleWhereInput
  }


  /**
   * Count Type DriverCountOutputType
   */

  export type DriverCountOutputType = {
    reservations: number
    tourBookings: number
  }

  export type DriverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | DriverCountOutputTypeCountReservationsArgs
    tourBookings?: boolean | DriverCountOutputTypeCountTourBookingsArgs
  }

  // Custom InputTypes
  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverCountOutputType
     */
    select?: DriverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountTourBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourBookingWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    activities: number
    reservations: number
    createdUsers: number
    permissions: number
    hotelRequests: number
    tenantUsers: number
    tour_bookings: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    reservations?: boolean | UserCountOutputTypeCountReservationsArgs
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs
    permissions?: boolean | UserCountOutputTypeCountPermissionsArgs
    hotelRequests?: boolean | UserCountOutputTypeCountHotelRequestsArgs
    tenantUsers?: boolean | UserCountOutputTypeCountTenantUsersArgs
    tour_bookings?: boolean | UserCountOutputTypeCountTour_bookingsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHotelRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTenantUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTour_bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourBookingWhereInput
  }


  /**
   * Count Type ReservationCountOutputType
   */

  export type ReservationCountOutputType = {
    hotelBookings: number
  }

  export type ReservationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelBookings?: boolean | ReservationCountOutputTypeCountHotelBookingsArgs
  }

  // Custom InputTypes
  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationCountOutputType
     */
    select?: ReservationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountHotelBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelBookingWhereInput
  }


  /**
   * Count Type HotelRequestCountOutputType
   */

  export type HotelRequestCountOutputType = {
    hotelBookings: number
  }

  export type HotelRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelBookings?: boolean | HotelRequestCountOutputTypeCountHotelBookingsArgs
  }

  // Custom InputTypes
  /**
   * HotelRequestCountOutputType without action
   */
  export type HotelRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequestCountOutputType
     */
    select?: HotelRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelRequestCountOutputType without action
   */
  export type HotelRequestCountOutputTypeCountHotelBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelBookingWhereInput
  }


  /**
   * Count Type TenantWebsiteCountOutputType
   */

  export type TenantWebsiteCountOutputType = {
    pages: number
    sections: number
  }

  export type TenantWebsiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | TenantWebsiteCountOutputTypeCountPagesArgs
    sections?: boolean | TenantWebsiteCountOutputTypeCountSectionsArgs
  }

  // Custom InputTypes
  /**
   * TenantWebsiteCountOutputType without action
   */
  export type TenantWebsiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsiteCountOutputType
     */
    select?: TenantWebsiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantWebsiteCountOutputType without action
   */
  export type TenantWebsiteCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsitePageWhereInput
  }

  /**
   * TenantWebsiteCountOutputType without action
   */
  export type TenantWebsiteCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsiteSectionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    subdomain: string | null
    companyName: string | null
    domain: string | null
    isActive: boolean | null
    subscriptionPlan: string | null
    websiteModuleEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentAccountHolder: string | null
    paymentBank: string | null
    paymentIban: string | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    subdomain: string | null
    companyName: string | null
    domain: string | null
    isActive: boolean | null
    subscriptionPlan: string | null
    websiteModuleEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentAccountHolder: string | null
    paymentBank: string | null
    paymentIban: string | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    subdomain: number
    companyName: number
    domain: number
    isActive: number
    subscriptionPlan: number
    websiteModuleEnabled: number
    createdAt: number
    updatedAt: number
    paymentAccountHolder: number
    paymentBank: number
    paymentIban: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    subdomain?: true
    companyName?: true
    domain?: true
    isActive?: true
    subscriptionPlan?: true
    websiteModuleEnabled?: true
    createdAt?: true
    updatedAt?: true
    paymentAccountHolder?: true
    paymentBank?: true
    paymentIban?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    subdomain?: true
    companyName?: true
    domain?: true
    isActive?: true
    subscriptionPlan?: true
    websiteModuleEnabled?: true
    createdAt?: true
    updatedAt?: true
    paymentAccountHolder?: true
    paymentBank?: true
    paymentIban?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    subdomain?: true
    companyName?: true
    domain?: true
    isActive?: true
    subscriptionPlan?: true
    websiteModuleEnabled?: true
    createdAt?: true
    updatedAt?: true
    paymentAccountHolder?: true
    paymentBank?: true
    paymentIban?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    subdomain: string
    companyName: string
    domain: string | null
    isActive: boolean
    subscriptionPlan: string
    websiteModuleEnabled: boolean
    createdAt: Date
    updatedAt: Date
    paymentAccountHolder: string | null
    paymentBank: string | null
    paymentIban: string | null
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subdomain?: boolean
    companyName?: boolean
    domain?: boolean
    isActive?: boolean
    subscriptionPlan?: boolean
    websiteModuleEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentAccountHolder?: boolean
    paymentBank?: boolean
    paymentIban?: boolean
    activities?: boolean | Tenant$activitiesArgs<ExtArgs>
    reservations?: boolean | Tenant$reservationsArgs<ExtArgs>
    drivers?: boolean | Tenant$driversArgs<ExtArgs>
    hotelBookings?: boolean | Tenant$hotelBookingsArgs<ExtArgs>
    hotelPricePool?: boolean | Tenant$hotelPricePoolArgs<ExtArgs>
    hotelRequests?: boolean | Tenant$hotelRequestsArgs<ExtArgs>
    modules?: boolean | Tenant$modulesArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    tourBookings?: boolean | Tenant$tourBookingsArgs<ExtArgs>
    vehicles?: boolean | Tenant$vehiclesArgs<ExtArgs>
    websites?: boolean | Tenant$websitesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subdomain?: boolean
    companyName?: boolean
    domain?: boolean
    isActive?: boolean
    subscriptionPlan?: boolean
    websiteModuleEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentAccountHolder?: boolean
    paymentBank?: boolean
    paymentIban?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subdomain?: boolean
    companyName?: boolean
    domain?: boolean
    isActive?: boolean
    subscriptionPlan?: boolean
    websiteModuleEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentAccountHolder?: boolean
    paymentBank?: boolean
    paymentIban?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    subdomain?: boolean
    companyName?: boolean
    domain?: boolean
    isActive?: boolean
    subscriptionPlan?: boolean
    websiteModuleEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentAccountHolder?: boolean
    paymentBank?: boolean
    paymentIban?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subdomain" | "companyName" | "domain" | "isActive" | "subscriptionPlan" | "websiteModuleEnabled" | "createdAt" | "updatedAt" | "paymentAccountHolder" | "paymentBank" | "paymentIban", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | Tenant$activitiesArgs<ExtArgs>
    reservations?: boolean | Tenant$reservationsArgs<ExtArgs>
    drivers?: boolean | Tenant$driversArgs<ExtArgs>
    hotelBookings?: boolean | Tenant$hotelBookingsArgs<ExtArgs>
    hotelPricePool?: boolean | Tenant$hotelPricePoolArgs<ExtArgs>
    hotelRequests?: boolean | Tenant$hotelRequestsArgs<ExtArgs>
    modules?: boolean | Tenant$modulesArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    tourBookings?: boolean | Tenant$tourBookingsArgs<ExtArgs>
    vehicles?: boolean | Tenant$vehiclesArgs<ExtArgs>
    websites?: boolean | Tenant$websitesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      drivers: Prisma.$DriverPayload<ExtArgs>[]
      hotelBookings: Prisma.$HotelBookingPayload<ExtArgs>[]
      hotelPricePool: Prisma.$HotelPricePoolPayload<ExtArgs>[]
      hotelRequests: Prisma.$HotelRequestPayload<ExtArgs>[]
      modules: Prisma.$TenantModulePayload<ExtArgs>[]
      users: Prisma.$TenantUserPayload<ExtArgs>[]
      tourBookings: Prisma.$TourBookingPayload<ExtArgs>[]
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
      websites: Prisma.$TenantWebsitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subdomain: string
      companyName: string
      domain: string | null
      isActive: boolean
      subscriptionPlan: string
      websiteModuleEnabled: boolean
      createdAt: Date
      updatedAt: Date
      paymentAccountHolder: string | null
      paymentBank: string | null
      paymentIban: string | null
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends Tenant$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Tenant$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    drivers<T extends Tenant$driversArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$driversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hotelBookings<T extends Tenant$hotelBookingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$hotelBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hotelPricePool<T extends Tenant$hotelPricePoolArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$hotelPricePoolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hotelRequests<T extends Tenant$hotelRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$hotelRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends Tenant$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tourBookings<T extends Tenant$tourBookingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tourBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicles<T extends Tenant$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    websites<T extends Tenant$websitesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$websitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly subdomain: FieldRef<"Tenant", 'String'>
    readonly companyName: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly isActive: FieldRef<"Tenant", 'Boolean'>
    readonly subscriptionPlan: FieldRef<"Tenant", 'String'>
    readonly websiteModuleEnabled: FieldRef<"Tenant", 'Boolean'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
    readonly paymentAccountHolder: FieldRef<"Tenant", 'String'>
    readonly paymentBank: FieldRef<"Tenant", 'String'>
    readonly paymentIban: FieldRef<"Tenant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.activities
   */
  export type Tenant$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Tenant.reservations
   */
  export type Tenant$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Tenant.drivers
   */
  export type Tenant$driversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    cursor?: DriverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Tenant.hotelBookings
   */
  export type Tenant$hotelBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    where?: HotelBookingWhereInput
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    cursor?: HotelBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * Tenant.hotelPricePool
   */
  export type Tenant$hotelPricePoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
    where?: HotelPricePoolWhereInput
    orderBy?: HotelPricePoolOrderByWithRelationInput | HotelPricePoolOrderByWithRelationInput[]
    cursor?: HotelPricePoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelPricePoolScalarFieldEnum | HotelPricePoolScalarFieldEnum[]
  }

  /**
   * Tenant.hotelRequests
   */
  export type Tenant$hotelRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    where?: HotelRequestWhereInput
    orderBy?: HotelRequestOrderByWithRelationInput | HotelRequestOrderByWithRelationInput[]
    cursor?: HotelRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelRequestScalarFieldEnum | HotelRequestScalarFieldEnum[]
  }

  /**
   * Tenant.modules
   */
  export type Tenant$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    where?: TenantModuleWhereInput
    orderBy?: TenantModuleOrderByWithRelationInput | TenantModuleOrderByWithRelationInput[]
    cursor?: TenantModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantModuleScalarFieldEnum | TenantModuleScalarFieldEnum[]
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    where?: TenantUserWhereInput
    orderBy?: TenantUserOrderByWithRelationInput | TenantUserOrderByWithRelationInput[]
    cursor?: TenantUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantUserScalarFieldEnum | TenantUserScalarFieldEnum[]
  }

  /**
   * Tenant.tourBookings
   */
  export type Tenant$tourBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    where?: TourBookingWhereInput
    orderBy?: TourBookingOrderByWithRelationInput | TourBookingOrderByWithRelationInput[]
    cursor?: TourBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourBookingScalarFieldEnum | TourBookingScalarFieldEnum[]
  }

  /**
   * Tenant.vehicles
   */
  export type Tenant$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Tenant.websites
   */
  export type Tenant$websitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    where?: TenantWebsiteWhereInput
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    cursor?: TenantWebsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantWebsiteScalarFieldEnum | TenantWebsiteScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    priceMonthly: number | null
    priceYearly: number | null
  }

  export type ModuleSumAggregateOutputType = {
    priceMonthly: number | null
    priceYearly: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    priceMonthly: number | null
    priceYearly: number | null
    features: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    priceMonthly: number | null
    priceYearly: number | null
    features: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    priceMonthly: number
    priceYearly: number
    features: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    priceMonthly?: true
    priceYearly?: true
  }

  export type ModuleSumAggregateInputType = {
    priceMonthly?: true
    priceYearly?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    priceMonthly?: true
    priceYearly?: true
    features?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    priceMonthly?: true
    priceYearly?: true
    features?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    priceMonthly?: true
    priceYearly?: true
    features?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    priceMonthly: number
    priceYearly: number
    features: string
    createdAt: Date
    updatedAt: Date
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantModules?: boolean | Module$tenantModulesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "priceMonthly" | "priceYearly" | "features" | "createdAt" | "updatedAt", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenantModules?: boolean | Module$tenantModulesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      tenantModules: Prisma.$TenantModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      priceMonthly: number
      priceYearly: number
      features: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules and returns the data updated in the database.
     * @param {ModuleUpdateManyAndReturnArgs} args - Arguments to update many Modules.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenantModules<T extends Module$tenantModulesArgs<ExtArgs> = {}>(args?: Subset<T, Module$tenantModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly name: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly isActive: FieldRef<"Module", 'Boolean'>
    readonly priceMonthly: FieldRef<"Module", 'Float'>
    readonly priceYearly: FieldRef<"Module", 'Float'>
    readonly features: FieldRef<"Module", 'String'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module updateManyAndReturn
   */
  export type ModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.tenantModules
   */
  export type Module$tenantModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    where?: TenantModuleWhereInput
    orderBy?: TenantModuleOrderByWithRelationInput | TenantModuleOrderByWithRelationInput[]
    cursor?: TenantModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantModuleScalarFieldEnum | TenantModuleScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model TenantModule
   */

  export type AggregateTenantModule = {
    _count: TenantModuleCountAggregateOutputType | null
    _min: TenantModuleMinAggregateOutputType | null
    _max: TenantModuleMaxAggregateOutputType | null
  }

  export type TenantModuleMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    moduleId: string | null
    isEnabled: boolean | null
    activatedAt: Date | null
    expiresAt: Date | null
    features: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantModuleMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    moduleId: string | null
    isEnabled: boolean | null
    activatedAt: Date | null
    expiresAt: Date | null
    features: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantModuleCountAggregateOutputType = {
    id: number
    tenantId: number
    moduleId: number
    isEnabled: number
    activatedAt: number
    expiresAt: number
    features: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantModuleMinAggregateInputType = {
    id?: true
    tenantId?: true
    moduleId?: true
    isEnabled?: true
    activatedAt?: true
    expiresAt?: true
    features?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantModuleMaxAggregateInputType = {
    id?: true
    tenantId?: true
    moduleId?: true
    isEnabled?: true
    activatedAt?: true
    expiresAt?: true
    features?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantModuleCountAggregateInputType = {
    id?: true
    tenantId?: true
    moduleId?: true
    isEnabled?: true
    activatedAt?: true
    expiresAt?: true
    features?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantModule to aggregate.
     */
    where?: TenantModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantModules to fetch.
     */
    orderBy?: TenantModuleOrderByWithRelationInput | TenantModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantModules
    **/
    _count?: true | TenantModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantModuleMaxAggregateInputType
  }

  export type GetTenantModuleAggregateType<T extends TenantModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantModule[P]>
      : GetScalarType<T[P], AggregateTenantModule[P]>
  }




  export type TenantModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantModuleWhereInput
    orderBy?: TenantModuleOrderByWithAggregationInput | TenantModuleOrderByWithAggregationInput[]
    by: TenantModuleScalarFieldEnum[] | TenantModuleScalarFieldEnum
    having?: TenantModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantModuleCountAggregateInputType | true
    _min?: TenantModuleMinAggregateInputType
    _max?: TenantModuleMaxAggregateInputType
  }

  export type TenantModuleGroupByOutputType = {
    id: string
    tenantId: string
    moduleId: string
    isEnabled: boolean
    activatedAt: Date | null
    expiresAt: Date | null
    features: string
    createdAt: Date
    updatedAt: Date
    _count: TenantModuleCountAggregateOutputType | null
    _min: TenantModuleMinAggregateOutputType | null
    _max: TenantModuleMaxAggregateOutputType | null
  }

  type GetTenantModuleGroupByPayload<T extends TenantModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantModuleGroupByOutputType[P]>
            : GetScalarType<T[P], TenantModuleGroupByOutputType[P]>
        }
      >
    >


  export type TenantModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    moduleId?: boolean
    isEnabled?: boolean
    activatedAt?: boolean
    expiresAt?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantModule"]>

  export type TenantModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    moduleId?: boolean
    isEnabled?: boolean
    activatedAt?: boolean
    expiresAt?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantModule"]>

  export type TenantModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    moduleId?: boolean
    isEnabled?: boolean
    activatedAt?: boolean
    expiresAt?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantModule"]>

  export type TenantModuleSelectScalar = {
    id?: boolean
    tenantId?: boolean
    moduleId?: boolean
    isEnabled?: boolean
    activatedAt?: boolean
    expiresAt?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "moduleId" | "isEnabled" | "activatedAt" | "expiresAt" | "features" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantModule"]>
  export type TenantModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantModule"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      moduleId: string
      isEnabled: boolean
      activatedAt: Date | null
      expiresAt: Date | null
      features: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantModule"]>
    composites: {}
  }

  type TenantModuleGetPayload<S extends boolean | null | undefined | TenantModuleDefaultArgs> = $Result.GetResult<Prisma.$TenantModulePayload, S>

  type TenantModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantModuleCountAggregateInputType | true
    }

  export interface TenantModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantModule'], meta: { name: 'TenantModule' } }
    /**
     * Find zero or one TenantModule that matches the filter.
     * @param {TenantModuleFindUniqueArgs} args - Arguments to find a TenantModule
     * @example
     * // Get one TenantModule
     * const tenantModule = await prisma.tenantModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantModuleFindUniqueArgs>(args: SelectSubset<T, TenantModuleFindUniqueArgs<ExtArgs>>): Prisma__TenantModuleClient<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantModuleFindUniqueOrThrowArgs} args - Arguments to find a TenantModule
     * @example
     * // Get one TenantModule
     * const tenantModule = await prisma.tenantModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantModuleClient<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantModuleFindFirstArgs} args - Arguments to find a TenantModule
     * @example
     * // Get one TenantModule
     * const tenantModule = await prisma.tenantModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantModuleFindFirstArgs>(args?: SelectSubset<T, TenantModuleFindFirstArgs<ExtArgs>>): Prisma__TenantModuleClient<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantModuleFindFirstOrThrowArgs} args - Arguments to find a TenantModule
     * @example
     * // Get one TenantModule
     * const tenantModule = await prisma.tenantModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantModuleClient<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantModules
     * const tenantModules = await prisma.tenantModule.findMany()
     * 
     * // Get first 10 TenantModules
     * const tenantModules = await prisma.tenantModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantModuleWithIdOnly = await prisma.tenantModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantModuleFindManyArgs>(args?: SelectSubset<T, TenantModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantModule.
     * @param {TenantModuleCreateArgs} args - Arguments to create a TenantModule.
     * @example
     * // Create one TenantModule
     * const TenantModule = await prisma.tenantModule.create({
     *   data: {
     *     // ... data to create a TenantModule
     *   }
     * })
     * 
     */
    create<T extends TenantModuleCreateArgs>(args: SelectSubset<T, TenantModuleCreateArgs<ExtArgs>>): Prisma__TenantModuleClient<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantModules.
     * @param {TenantModuleCreateManyArgs} args - Arguments to create many TenantModules.
     * @example
     * // Create many TenantModules
     * const tenantModule = await prisma.tenantModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantModuleCreateManyArgs>(args?: SelectSubset<T, TenantModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantModules and returns the data saved in the database.
     * @param {TenantModuleCreateManyAndReturnArgs} args - Arguments to create many TenantModules.
     * @example
     * // Create many TenantModules
     * const tenantModule = await prisma.tenantModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantModules and only return the `id`
     * const tenantModuleWithIdOnly = await prisma.tenantModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantModule.
     * @param {TenantModuleDeleteArgs} args - Arguments to delete one TenantModule.
     * @example
     * // Delete one TenantModule
     * const TenantModule = await prisma.tenantModule.delete({
     *   where: {
     *     // ... filter to delete one TenantModule
     *   }
     * })
     * 
     */
    delete<T extends TenantModuleDeleteArgs>(args: SelectSubset<T, TenantModuleDeleteArgs<ExtArgs>>): Prisma__TenantModuleClient<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantModule.
     * @param {TenantModuleUpdateArgs} args - Arguments to update one TenantModule.
     * @example
     * // Update one TenantModule
     * const tenantModule = await prisma.tenantModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantModuleUpdateArgs>(args: SelectSubset<T, TenantModuleUpdateArgs<ExtArgs>>): Prisma__TenantModuleClient<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantModules.
     * @param {TenantModuleDeleteManyArgs} args - Arguments to filter TenantModules to delete.
     * @example
     * // Delete a few TenantModules
     * const { count } = await prisma.tenantModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantModuleDeleteManyArgs>(args?: SelectSubset<T, TenantModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantModules
     * const tenantModule = await prisma.tenantModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantModuleUpdateManyArgs>(args: SelectSubset<T, TenantModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantModules and returns the data updated in the database.
     * @param {TenantModuleUpdateManyAndReturnArgs} args - Arguments to update many TenantModules.
     * @example
     * // Update many TenantModules
     * const tenantModule = await prisma.tenantModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantModules and only return the `id`
     * const tenantModuleWithIdOnly = await prisma.tenantModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantModule.
     * @param {TenantModuleUpsertArgs} args - Arguments to update or create a TenantModule.
     * @example
     * // Update or create a TenantModule
     * const tenantModule = await prisma.tenantModule.upsert({
     *   create: {
     *     // ... data to create a TenantModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantModule we want to update
     *   }
     * })
     */
    upsert<T extends TenantModuleUpsertArgs>(args: SelectSubset<T, TenantModuleUpsertArgs<ExtArgs>>): Prisma__TenantModuleClient<$Result.GetResult<Prisma.$TenantModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantModuleCountArgs} args - Arguments to filter TenantModules to count.
     * @example
     * // Count the number of TenantModules
     * const count = await prisma.tenantModule.count({
     *   where: {
     *     // ... the filter for the TenantModules we want to count
     *   }
     * })
    **/
    count<T extends TenantModuleCountArgs>(
      args?: Subset<T, TenantModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantModuleAggregateArgs>(args: Subset<T, TenantModuleAggregateArgs>): Prisma.PrismaPromise<GetTenantModuleAggregateType<T>>

    /**
     * Group by TenantModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantModuleGroupByArgs['orderBy'] }
        : { orderBy?: TenantModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantModule model
   */
  readonly fields: TenantModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantModule model
   */
  interface TenantModuleFieldRefs {
    readonly id: FieldRef<"TenantModule", 'String'>
    readonly tenantId: FieldRef<"TenantModule", 'String'>
    readonly moduleId: FieldRef<"TenantModule", 'String'>
    readonly isEnabled: FieldRef<"TenantModule", 'Boolean'>
    readonly activatedAt: FieldRef<"TenantModule", 'DateTime'>
    readonly expiresAt: FieldRef<"TenantModule", 'DateTime'>
    readonly features: FieldRef<"TenantModule", 'String'>
    readonly createdAt: FieldRef<"TenantModule", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantModule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantModule findUnique
   */
  export type TenantModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    /**
     * Filter, which TenantModule to fetch.
     */
    where: TenantModuleWhereUniqueInput
  }

  /**
   * TenantModule findUniqueOrThrow
   */
  export type TenantModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    /**
     * Filter, which TenantModule to fetch.
     */
    where: TenantModuleWhereUniqueInput
  }

  /**
   * TenantModule findFirst
   */
  export type TenantModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    /**
     * Filter, which TenantModule to fetch.
     */
    where?: TenantModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantModules to fetch.
     */
    orderBy?: TenantModuleOrderByWithRelationInput | TenantModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantModules.
     */
    cursor?: TenantModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantModules.
     */
    distinct?: TenantModuleScalarFieldEnum | TenantModuleScalarFieldEnum[]
  }

  /**
   * TenantModule findFirstOrThrow
   */
  export type TenantModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    /**
     * Filter, which TenantModule to fetch.
     */
    where?: TenantModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantModules to fetch.
     */
    orderBy?: TenantModuleOrderByWithRelationInput | TenantModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantModules.
     */
    cursor?: TenantModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantModules.
     */
    distinct?: TenantModuleScalarFieldEnum | TenantModuleScalarFieldEnum[]
  }

  /**
   * TenantModule findMany
   */
  export type TenantModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    /**
     * Filter, which TenantModules to fetch.
     */
    where?: TenantModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantModules to fetch.
     */
    orderBy?: TenantModuleOrderByWithRelationInput | TenantModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantModules.
     */
    cursor?: TenantModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantModules.
     */
    skip?: number
    distinct?: TenantModuleScalarFieldEnum | TenantModuleScalarFieldEnum[]
  }

  /**
   * TenantModule create
   */
  export type TenantModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantModule.
     */
    data: XOR<TenantModuleCreateInput, TenantModuleUncheckedCreateInput>
  }

  /**
   * TenantModule createMany
   */
  export type TenantModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantModules.
     */
    data: TenantModuleCreateManyInput | TenantModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantModule createManyAndReturn
   */
  export type TenantModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * The data used to create many TenantModules.
     */
    data: TenantModuleCreateManyInput | TenantModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantModule update
   */
  export type TenantModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantModule.
     */
    data: XOR<TenantModuleUpdateInput, TenantModuleUncheckedUpdateInput>
    /**
     * Choose, which TenantModule to update.
     */
    where: TenantModuleWhereUniqueInput
  }

  /**
   * TenantModule updateMany
   */
  export type TenantModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantModules.
     */
    data: XOR<TenantModuleUpdateManyMutationInput, TenantModuleUncheckedUpdateManyInput>
    /**
     * Filter which TenantModules to update
     */
    where?: TenantModuleWhereInput
    /**
     * Limit how many TenantModules to update.
     */
    limit?: number
  }

  /**
   * TenantModule updateManyAndReturn
   */
  export type TenantModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * The data used to update TenantModules.
     */
    data: XOR<TenantModuleUpdateManyMutationInput, TenantModuleUncheckedUpdateManyInput>
    /**
     * Filter which TenantModules to update
     */
    where?: TenantModuleWhereInput
    /**
     * Limit how many TenantModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantModule upsert
   */
  export type TenantModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantModule to update in case it exists.
     */
    where: TenantModuleWhereUniqueInput
    /**
     * In case the TenantModule found by the `where` argument doesn't exist, create a new TenantModule with this data.
     */
    create: XOR<TenantModuleCreateInput, TenantModuleUncheckedCreateInput>
    /**
     * In case the TenantModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantModuleUpdateInput, TenantModuleUncheckedUpdateInput>
  }

  /**
   * TenantModule delete
   */
  export type TenantModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
    /**
     * Filter which TenantModule to delete.
     */
    where: TenantModuleWhereUniqueInput
  }

  /**
   * TenantModule deleteMany
   */
  export type TenantModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantModules to delete
     */
    where?: TenantModuleWhereInput
    /**
     * Limit how many TenantModules to delete.
     */
    limit?: number
  }

  /**
   * TenantModule without action
   */
  export type TenantModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantModule
     */
    select?: TenantModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantModule
     */
    omit?: TenantModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantModuleInclude<ExtArgs> | null
  }


  /**
   * Model TenantUser
   */

  export type AggregateTenantUser = {
    _count: TenantUserCountAggregateOutputType | null
    _min: TenantUserMinAggregateOutputType | null
    _max: TenantUserMaxAggregateOutputType | null
  }

  export type TenantUserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    role: string | null
    permissions: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantUserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    role: string | null
    permissions: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantUserCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    role: number
    permissions: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantUserMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    role?: true
    permissions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantUserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    role?: true
    permissions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantUserCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    role?: true
    permissions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantUser to aggregate.
     */
    where?: TenantUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantUsers to fetch.
     */
    orderBy?: TenantUserOrderByWithRelationInput | TenantUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantUsers
    **/
    _count?: true | TenantUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantUserMaxAggregateInputType
  }

  export type GetTenantUserAggregateType<T extends TenantUserAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantUser[P]>
      : GetScalarType<T[P], AggregateTenantUser[P]>
  }




  export type TenantUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantUserWhereInput
    orderBy?: TenantUserOrderByWithAggregationInput | TenantUserOrderByWithAggregationInput[]
    by: TenantUserScalarFieldEnum[] | TenantUserScalarFieldEnum
    having?: TenantUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantUserCountAggregateInputType | true
    _min?: TenantUserMinAggregateInputType
    _max?: TenantUserMaxAggregateInputType
  }

  export type TenantUserGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    role: string
    permissions: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantUserCountAggregateOutputType | null
    _min: TenantUserMinAggregateOutputType | null
    _max: TenantUserMaxAggregateOutputType | null
  }

  type GetTenantUserGroupByPayload<T extends TenantUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantUserGroupByOutputType[P]>
            : GetScalarType<T[P], TenantUserGroupByOutputType[P]>
        }
      >
    >


  export type TenantUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantUser"]>

  export type TenantUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantUser"]>

  export type TenantUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantUser"]>

  export type TenantUserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "role" | "permissions" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantUser"]>
  export type TenantUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TenantUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TenantUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TenantUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantUser"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      role: string
      permissions: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantUser"]>
    composites: {}
  }

  type TenantUserGetPayload<S extends boolean | null | undefined | TenantUserDefaultArgs> = $Result.GetResult<Prisma.$TenantUserPayload, S>

  type TenantUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantUserCountAggregateInputType | true
    }

  export interface TenantUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantUser'], meta: { name: 'TenantUser' } }
    /**
     * Find zero or one TenantUser that matches the filter.
     * @param {TenantUserFindUniqueArgs} args - Arguments to find a TenantUser
     * @example
     * // Get one TenantUser
     * const tenantUser = await prisma.tenantUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantUserFindUniqueArgs>(args: SelectSubset<T, TenantUserFindUniqueArgs<ExtArgs>>): Prisma__TenantUserClient<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantUserFindUniqueOrThrowArgs} args - Arguments to find a TenantUser
     * @example
     * // Get one TenantUser
     * const tenantUser = await prisma.tenantUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantUserFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantUserClient<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUserFindFirstArgs} args - Arguments to find a TenantUser
     * @example
     * // Get one TenantUser
     * const tenantUser = await prisma.tenantUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantUserFindFirstArgs>(args?: SelectSubset<T, TenantUserFindFirstArgs<ExtArgs>>): Prisma__TenantUserClient<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUserFindFirstOrThrowArgs} args - Arguments to find a TenantUser
     * @example
     * // Get one TenantUser
     * const tenantUser = await prisma.tenantUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantUserFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantUserClient<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantUsers
     * const tenantUsers = await prisma.tenantUser.findMany()
     * 
     * // Get first 10 TenantUsers
     * const tenantUsers = await prisma.tenantUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantUserWithIdOnly = await prisma.tenantUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantUserFindManyArgs>(args?: SelectSubset<T, TenantUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantUser.
     * @param {TenantUserCreateArgs} args - Arguments to create a TenantUser.
     * @example
     * // Create one TenantUser
     * const TenantUser = await prisma.tenantUser.create({
     *   data: {
     *     // ... data to create a TenantUser
     *   }
     * })
     * 
     */
    create<T extends TenantUserCreateArgs>(args: SelectSubset<T, TenantUserCreateArgs<ExtArgs>>): Prisma__TenantUserClient<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantUsers.
     * @param {TenantUserCreateManyArgs} args - Arguments to create many TenantUsers.
     * @example
     * // Create many TenantUsers
     * const tenantUser = await prisma.tenantUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantUserCreateManyArgs>(args?: SelectSubset<T, TenantUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantUsers and returns the data saved in the database.
     * @param {TenantUserCreateManyAndReturnArgs} args - Arguments to create many TenantUsers.
     * @example
     * // Create many TenantUsers
     * const tenantUser = await prisma.tenantUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantUsers and only return the `id`
     * const tenantUserWithIdOnly = await prisma.tenantUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantUserCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantUser.
     * @param {TenantUserDeleteArgs} args - Arguments to delete one TenantUser.
     * @example
     * // Delete one TenantUser
     * const TenantUser = await prisma.tenantUser.delete({
     *   where: {
     *     // ... filter to delete one TenantUser
     *   }
     * })
     * 
     */
    delete<T extends TenantUserDeleteArgs>(args: SelectSubset<T, TenantUserDeleteArgs<ExtArgs>>): Prisma__TenantUserClient<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantUser.
     * @param {TenantUserUpdateArgs} args - Arguments to update one TenantUser.
     * @example
     * // Update one TenantUser
     * const tenantUser = await prisma.tenantUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUserUpdateArgs>(args: SelectSubset<T, TenantUserUpdateArgs<ExtArgs>>): Prisma__TenantUserClient<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantUsers.
     * @param {TenantUserDeleteManyArgs} args - Arguments to filter TenantUsers to delete.
     * @example
     * // Delete a few TenantUsers
     * const { count } = await prisma.tenantUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantUserDeleteManyArgs>(args?: SelectSubset<T, TenantUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantUsers
     * const tenantUser = await prisma.tenantUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUserUpdateManyArgs>(args: SelectSubset<T, TenantUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantUsers and returns the data updated in the database.
     * @param {TenantUserUpdateManyAndReturnArgs} args - Arguments to update many TenantUsers.
     * @example
     * // Update many TenantUsers
     * const tenantUser = await prisma.tenantUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantUsers and only return the `id`
     * const tenantUserWithIdOnly = await prisma.tenantUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUserUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantUser.
     * @param {TenantUserUpsertArgs} args - Arguments to update or create a TenantUser.
     * @example
     * // Update or create a TenantUser
     * const tenantUser = await prisma.tenantUser.upsert({
     *   create: {
     *     // ... data to create a TenantUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantUser we want to update
     *   }
     * })
     */
    upsert<T extends TenantUserUpsertArgs>(args: SelectSubset<T, TenantUserUpsertArgs<ExtArgs>>): Prisma__TenantUserClient<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUserCountArgs} args - Arguments to filter TenantUsers to count.
     * @example
     * // Count the number of TenantUsers
     * const count = await prisma.tenantUser.count({
     *   where: {
     *     // ... the filter for the TenantUsers we want to count
     *   }
     * })
    **/
    count<T extends TenantUserCountArgs>(
      args?: Subset<T, TenantUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantUserAggregateArgs>(args: Subset<T, TenantUserAggregateArgs>): Prisma.PrismaPromise<GetTenantUserAggregateType<T>>

    /**
     * Group by TenantUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantUserGroupByArgs['orderBy'] }
        : { orderBy?: TenantUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantUser model
   */
  readonly fields: TenantUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantUser model
   */
  interface TenantUserFieldRefs {
    readonly id: FieldRef<"TenantUser", 'String'>
    readonly tenantId: FieldRef<"TenantUser", 'String'>
    readonly userId: FieldRef<"TenantUser", 'String'>
    readonly role: FieldRef<"TenantUser", 'String'>
    readonly permissions: FieldRef<"TenantUser", 'String'>
    readonly isActive: FieldRef<"TenantUser", 'Boolean'>
    readonly createdAt: FieldRef<"TenantUser", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantUser findUnique
   */
  export type TenantUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    /**
     * Filter, which TenantUser to fetch.
     */
    where: TenantUserWhereUniqueInput
  }

  /**
   * TenantUser findUniqueOrThrow
   */
  export type TenantUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    /**
     * Filter, which TenantUser to fetch.
     */
    where: TenantUserWhereUniqueInput
  }

  /**
   * TenantUser findFirst
   */
  export type TenantUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    /**
     * Filter, which TenantUser to fetch.
     */
    where?: TenantUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantUsers to fetch.
     */
    orderBy?: TenantUserOrderByWithRelationInput | TenantUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantUsers.
     */
    cursor?: TenantUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantUsers.
     */
    distinct?: TenantUserScalarFieldEnum | TenantUserScalarFieldEnum[]
  }

  /**
   * TenantUser findFirstOrThrow
   */
  export type TenantUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    /**
     * Filter, which TenantUser to fetch.
     */
    where?: TenantUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantUsers to fetch.
     */
    orderBy?: TenantUserOrderByWithRelationInput | TenantUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantUsers.
     */
    cursor?: TenantUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantUsers.
     */
    distinct?: TenantUserScalarFieldEnum | TenantUserScalarFieldEnum[]
  }

  /**
   * TenantUser findMany
   */
  export type TenantUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    /**
     * Filter, which TenantUsers to fetch.
     */
    where?: TenantUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantUsers to fetch.
     */
    orderBy?: TenantUserOrderByWithRelationInput | TenantUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantUsers.
     */
    cursor?: TenantUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantUsers.
     */
    skip?: number
    distinct?: TenantUserScalarFieldEnum | TenantUserScalarFieldEnum[]
  }

  /**
   * TenantUser create
   */
  export type TenantUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantUser.
     */
    data: XOR<TenantUserCreateInput, TenantUserUncheckedCreateInput>
  }

  /**
   * TenantUser createMany
   */
  export type TenantUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantUsers.
     */
    data: TenantUserCreateManyInput | TenantUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantUser createManyAndReturn
   */
  export type TenantUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * The data used to create many TenantUsers.
     */
    data: TenantUserCreateManyInput | TenantUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantUser update
   */
  export type TenantUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantUser.
     */
    data: XOR<TenantUserUpdateInput, TenantUserUncheckedUpdateInput>
    /**
     * Choose, which TenantUser to update.
     */
    where: TenantUserWhereUniqueInput
  }

  /**
   * TenantUser updateMany
   */
  export type TenantUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantUsers.
     */
    data: XOR<TenantUserUpdateManyMutationInput, TenantUserUncheckedUpdateManyInput>
    /**
     * Filter which TenantUsers to update
     */
    where?: TenantUserWhereInput
    /**
     * Limit how many TenantUsers to update.
     */
    limit?: number
  }

  /**
   * TenantUser updateManyAndReturn
   */
  export type TenantUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * The data used to update TenantUsers.
     */
    data: XOR<TenantUserUpdateManyMutationInput, TenantUserUncheckedUpdateManyInput>
    /**
     * Filter which TenantUsers to update
     */
    where?: TenantUserWhereInput
    /**
     * Limit how many TenantUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantUser upsert
   */
  export type TenantUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantUser to update in case it exists.
     */
    where: TenantUserWhereUniqueInput
    /**
     * In case the TenantUser found by the `where` argument doesn't exist, create a new TenantUser with this data.
     */
    create: XOR<TenantUserCreateInput, TenantUserUncheckedCreateInput>
    /**
     * In case the TenantUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUserUpdateInput, TenantUserUncheckedUpdateInput>
  }

  /**
   * TenantUser delete
   */
  export type TenantUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    /**
     * Filter which TenantUser to delete.
     */
    where: TenantUserWhereUniqueInput
  }

  /**
   * TenantUser deleteMany
   */
  export type TenantUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantUsers to delete
     */
    where?: TenantUserWhereInput
    /**
     * Limit how many TenantUsers to delete.
     */
    limit?: number
  }

  /**
   * TenantUser without action
   */
  export type TenantUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
  }


  /**
   * Model Driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverMinAggregateOutputType = {
    id: string | null
    name: string | null
    phoneNumber: string | null
    tenantId: string | null
    createdAt: Date | null
  }

  export type DriverMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phoneNumber: string | null
    tenantId: string | null
    createdAt: Date | null
  }

  export type DriverCountAggregateOutputType = {
    id: number
    name: number
    phoneNumber: number
    tenantId: number
    createdAt: number
    _all: number
  }


  export type DriverMinAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    tenantId?: true
    createdAt?: true
  }

  export type DriverMaxAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    tenantId?: true
    createdAt?: true
  }

  export type DriverCountAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    tenantId?: true
    createdAt?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Driver to aggregate.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithAggregationInput | DriverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    id: string
    name: string
    phoneNumber: string | null
    tenantId: string | null
    createdAt: Date
    _count: DriverCountAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    tenantId?: boolean
    createdAt?: boolean
    reservations?: boolean | Driver$reservationsArgs<ExtArgs>
    tenant?: boolean | Driver$tenantArgs<ExtArgs>
    tourBookings?: boolean | Driver$tourBookingsArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    tenantId?: boolean
    createdAt?: boolean
    tenant?: boolean | Driver$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    tenantId?: boolean
    createdAt?: boolean
    tenant?: boolean | Driver$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectScalar = {
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    tenantId?: boolean
    createdAt?: boolean
  }

  export type DriverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phoneNumber" | "tenantId" | "createdAt", ExtArgs["result"]["driver"]>
  export type DriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | Driver$reservationsArgs<ExtArgs>
    tenant?: boolean | Driver$tenantArgs<ExtArgs>
    tourBookings?: boolean | Driver$tourBookingsArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Driver$tenantArgs<ExtArgs>
  }
  export type DriverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Driver$tenantArgs<ExtArgs>
  }

  export type $DriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Driver"
    objects: {
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      tourBookings: Prisma.$TourBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phoneNumber: string | null
      tenantId: string | null
      createdAt: Date
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }

  type DriverGetPayload<S extends boolean | null | undefined | DriverDefaultArgs> = $Result.GetResult<Prisma.$DriverPayload, S>

  type DriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface DriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Driver'], meta: { name: 'Driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverFindUniqueArgs>(args: SelectSubset<T, DriverFindUniqueArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Driver that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverFindFirstArgs>(args?: SelectSubset<T, DriverFindFirstArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverFindManyArgs>(args?: SelectSubset<T, DriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
     */
    create<T extends DriverCreateArgs>(args: SelectSubset<T, DriverCreateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drivers.
     * @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverCreateManyArgs>(args?: SelectSubset<T, DriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drivers and returns the data saved in the database.
     * @param {DriverCreateManyAndReturnArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drivers and only return the `id`
     * const driverWithIdOnly = await prisma.driver.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
     */
    delete<T extends DriverDeleteArgs>(args: SelectSubset<T, DriverDeleteArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverUpdateArgs>(args: SelectSubset<T, DriverUpdateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverDeleteManyArgs>(args?: SelectSubset<T, DriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverUpdateManyArgs>(args: SelectSubset<T, DriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers and returns the data updated in the database.
     * @param {DriverUpdateManyAndReturnArgs} args - Arguments to update many Drivers.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drivers and only return the `id`
     * const driverWithIdOnly = await prisma.driver.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriverUpdateManyAndReturnArgs>(args: SelectSubset<T, DriverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
     */
    upsert<T extends DriverUpsertArgs>(args: SelectSubset<T, DriverUpsertArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Driver model
   */
  readonly fields: DriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservations<T extends Driver$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends Driver$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Driver$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tourBookings<T extends Driver$tourBookingsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$tourBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Driver model
   */
  interface DriverFieldRefs {
    readonly id: FieldRef<"Driver", 'String'>
    readonly name: FieldRef<"Driver", 'String'>
    readonly phoneNumber: FieldRef<"Driver", 'String'>
    readonly tenantId: FieldRef<"Driver", 'String'>
    readonly createdAt: FieldRef<"Driver", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Driver findUnique
   */
  export type DriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findFirst
   */
  export type DriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver create
   */
  export type DriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to create a Driver.
     */
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }

  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver createManyAndReturn
   */
  export type DriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Driver update
   */
  export type DriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to update a Driver.
     */
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
  }

  /**
   * Driver updateManyAndReturn
   */
  export type DriverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Driver upsert
   */
  export type DriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The filter to search for the Driver to update in case it exists.
     */
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     */
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }

  /**
   * Driver delete
   */
  export type DriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter which Driver to delete.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to delete.
     */
    limit?: number
  }

  /**
   * Driver.reservations
   */
  export type Driver$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Driver.tenant
   */
  export type Driver$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Driver.tourBookings
   */
  export type Driver$tourBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    where?: TourBookingWhereInput
    orderBy?: TourBookingOrderByWithRelationInput | TourBookingOrderByWithRelationInput[]
    cursor?: TourBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourBookingScalarFieldEnum | TourBookingScalarFieldEnum[]
  }

  /**
   * Driver without action
   */
  export type DriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    name: number
    role: number
    isActive: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    password: string
    name: string
    role: $Enums.UserRole
    isActive: boolean
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activities?: boolean | User$activitiesArgs<ExtArgs>
    reservations?: boolean | User$reservationsArgs<ExtArgs>
    creator?: boolean | User$creatorArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    hotelRequests?: boolean | User$hotelRequestsArgs<ExtArgs>
    tenantUsers?: boolean | User$tenantUsersArgs<ExtArgs>
    tour_bookings?: boolean | User$tour_bookingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | User$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | User$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "name" | "role" | "isActive" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | User$activitiesArgs<ExtArgs>
    reservations?: boolean | User$reservationsArgs<ExtArgs>
    creator?: boolean | User$creatorArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    hotelRequests?: boolean | User$hotelRequestsArgs<ExtArgs>
    tenantUsers?: boolean | User$tenantUsersArgs<ExtArgs>
    tour_bookings?: boolean | User$tour_bookingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | User$creatorArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | User$creatorArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs> | null
      createdUsers: Prisma.$UserPayload<ExtArgs>[]
      permissions: Prisma.$UserPermissionPayload<ExtArgs>[]
      hotelRequests: Prisma.$HotelRequestPayload<ExtArgs>[]
      tenantUsers: Prisma.$TenantUserPayload<ExtArgs>[]
      tour_bookings: Prisma.$TourBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      password: string
      name: string
      role: $Enums.UserRole
      isActive: boolean
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends User$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, User$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creator<T extends User$creatorArgs<ExtArgs> = {}>(args?: Subset<T, User$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends User$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hotelRequests<T extends User$hotelRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$hotelRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenantUsers<T extends User$tenantUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tour_bookings<T extends User$tour_bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$tour_bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdBy: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.reservations
   */
  export type User$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * User.creator
   */
  export type User$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.permissions
   */
  export type User$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    where?: UserPermissionWhereInput
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    cursor?: UserPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * User.hotelRequests
   */
  export type User$hotelRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    where?: HotelRequestWhereInput
    orderBy?: HotelRequestOrderByWithRelationInput | HotelRequestOrderByWithRelationInput[]
    cursor?: HotelRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelRequestScalarFieldEnum | HotelRequestScalarFieldEnum[]
  }

  /**
   * User.tenantUsers
   */
  export type User$tenantUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantUser
     */
    select?: TenantUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantUser
     */
    omit?: TenantUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantUserInclude<ExtArgs> | null
    where?: TenantUserWhereInput
    orderBy?: TenantUserOrderByWithRelationInput | TenantUserOrderByWithRelationInput[]
    cursor?: TenantUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantUserScalarFieldEnum | TenantUserScalarFieldEnum[]
  }

  /**
   * User.tour_bookings
   */
  export type User$tour_bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    where?: TourBookingWhereInput
    orderBy?: TourBookingOrderByWithRelationInput | TourBookingOrderByWithRelationInput[]
    cursor?: TourBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourBookingScalarFieldEnum | TourBookingScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserPermission
   */

  export type AggregateUserPermission = {
    _count: UserPermissionCountAggregateOutputType | null
    _min: UserPermissionMinAggregateOutputType | null
    _max: UserPermissionMaxAggregateOutputType | null
  }

  export type UserPermissionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    permission: string | null
    grantedBy: string | null
    grantedAt: Date | null
    isActive: boolean | null
  }

  export type UserPermissionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    permission: string | null
    grantedBy: string | null
    grantedAt: Date | null
    isActive: boolean | null
  }

  export type UserPermissionCountAggregateOutputType = {
    id: number
    userId: number
    permission: number
    grantedBy: number
    grantedAt: number
    isActive: number
    _all: number
  }


  export type UserPermissionMinAggregateInputType = {
    id?: true
    userId?: true
    permission?: true
    grantedBy?: true
    grantedAt?: true
    isActive?: true
  }

  export type UserPermissionMaxAggregateInputType = {
    id?: true
    userId?: true
    permission?: true
    grantedBy?: true
    grantedAt?: true
    isActive?: true
  }

  export type UserPermissionCountAggregateInputType = {
    id?: true
    userId?: true
    permission?: true
    grantedBy?: true
    grantedAt?: true
    isActive?: true
    _all?: true
  }

  export type UserPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPermission to aggregate.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPermissions
    **/
    _count?: true | UserPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPermissionMaxAggregateInputType
  }

  export type GetUserPermissionAggregateType<T extends UserPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPermission[P]>
      : GetScalarType<T[P], AggregateUserPermission[P]>
  }




  export type UserPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionWhereInput
    orderBy?: UserPermissionOrderByWithAggregationInput | UserPermissionOrderByWithAggregationInput[]
    by: UserPermissionScalarFieldEnum[] | UserPermissionScalarFieldEnum
    having?: UserPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPermissionCountAggregateInputType | true
    _min?: UserPermissionMinAggregateInputType
    _max?: UserPermissionMaxAggregateInputType
  }

  export type UserPermissionGroupByOutputType = {
    id: string
    userId: string
    permission: string
    grantedBy: string | null
    grantedAt: Date
    isActive: boolean
    _count: UserPermissionCountAggregateOutputType | null
    _min: UserPermissionMinAggregateOutputType | null
    _max: UserPermissionMaxAggregateOutputType | null
  }

  type GetUserPermissionGroupByPayload<T extends UserPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], UserPermissionGroupByOutputType[P]>
        }
      >
    >


  export type UserPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permission?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPermission"]>

  export type UserPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permission?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPermission"]>

  export type UserPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permission?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPermission"]>

  export type UserPermissionSelectScalar = {
    id?: boolean
    userId?: boolean
    permission?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    isActive?: boolean
  }

  export type UserPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "permission" | "grantedBy" | "grantedAt" | "isActive", ExtArgs["result"]["userPermission"]>
  export type UserPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPermission"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      permission: string
      grantedBy: string | null
      grantedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["userPermission"]>
    composites: {}
  }

  type UserPermissionGetPayload<S extends boolean | null | undefined | UserPermissionDefaultArgs> = $Result.GetResult<Prisma.$UserPermissionPayload, S>

  type UserPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPermissionCountAggregateInputType | true
    }

  export interface UserPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPermission'], meta: { name: 'UserPermission' } }
    /**
     * Find zero or one UserPermission that matches the filter.
     * @param {UserPermissionFindUniqueArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPermissionFindUniqueArgs>(args: SelectSubset<T, UserPermissionFindUniqueArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPermissionFindUniqueOrThrowArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionFindFirstArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPermissionFindFirstArgs>(args?: SelectSubset<T, UserPermissionFindFirstArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionFindFirstOrThrowArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPermissions
     * const userPermissions = await prisma.userPermission.findMany()
     * 
     * // Get first 10 UserPermissions
     * const userPermissions = await prisma.userPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPermissionWithIdOnly = await prisma.userPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPermissionFindManyArgs>(args?: SelectSubset<T, UserPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPermission.
     * @param {UserPermissionCreateArgs} args - Arguments to create a UserPermission.
     * @example
     * // Create one UserPermission
     * const UserPermission = await prisma.userPermission.create({
     *   data: {
     *     // ... data to create a UserPermission
     *   }
     * })
     * 
     */
    create<T extends UserPermissionCreateArgs>(args: SelectSubset<T, UserPermissionCreateArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPermissions.
     * @param {UserPermissionCreateManyArgs} args - Arguments to create many UserPermissions.
     * @example
     * // Create many UserPermissions
     * const userPermission = await prisma.userPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPermissionCreateManyArgs>(args?: SelectSubset<T, UserPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPermissions and returns the data saved in the database.
     * @param {UserPermissionCreateManyAndReturnArgs} args - Arguments to create many UserPermissions.
     * @example
     * // Create many UserPermissions
     * const userPermission = await prisma.userPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPermissions and only return the `id`
     * const userPermissionWithIdOnly = await prisma.userPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPermission.
     * @param {UserPermissionDeleteArgs} args - Arguments to delete one UserPermission.
     * @example
     * // Delete one UserPermission
     * const UserPermission = await prisma.userPermission.delete({
     *   where: {
     *     // ... filter to delete one UserPermission
     *   }
     * })
     * 
     */
    delete<T extends UserPermissionDeleteArgs>(args: SelectSubset<T, UserPermissionDeleteArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPermission.
     * @param {UserPermissionUpdateArgs} args - Arguments to update one UserPermission.
     * @example
     * // Update one UserPermission
     * const userPermission = await prisma.userPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPermissionUpdateArgs>(args: SelectSubset<T, UserPermissionUpdateArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPermissions.
     * @param {UserPermissionDeleteManyArgs} args - Arguments to filter UserPermissions to delete.
     * @example
     * // Delete a few UserPermissions
     * const { count } = await prisma.userPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPermissionDeleteManyArgs>(args?: SelectSubset<T, UserPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPermissions
     * const userPermission = await prisma.userPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPermissionUpdateManyArgs>(args: SelectSubset<T, UserPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPermissions and returns the data updated in the database.
     * @param {UserPermissionUpdateManyAndReturnArgs} args - Arguments to update many UserPermissions.
     * @example
     * // Update many UserPermissions
     * const userPermission = await prisma.userPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPermissions and only return the `id`
     * const userPermissionWithIdOnly = await prisma.userPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPermission.
     * @param {UserPermissionUpsertArgs} args - Arguments to update or create a UserPermission.
     * @example
     * // Update or create a UserPermission
     * const userPermission = await prisma.userPermission.upsert({
     *   create: {
     *     // ... data to create a UserPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPermission we want to update
     *   }
     * })
     */
    upsert<T extends UserPermissionUpsertArgs>(args: SelectSubset<T, UserPermissionUpsertArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionCountArgs} args - Arguments to filter UserPermissions to count.
     * @example
     * // Count the number of UserPermissions
     * const count = await prisma.userPermission.count({
     *   where: {
     *     // ... the filter for the UserPermissions we want to count
     *   }
     * })
    **/
    count<T extends UserPermissionCountArgs>(
      args?: Subset<T, UserPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPermissionAggregateArgs>(args: Subset<T, UserPermissionAggregateArgs>): Prisma.PrismaPromise<GetUserPermissionAggregateType<T>>

    /**
     * Group by UserPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPermissionGroupByArgs['orderBy'] }
        : { orderBy?: UserPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPermission model
   */
  readonly fields: UserPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPermission model
   */
  interface UserPermissionFieldRefs {
    readonly id: FieldRef<"UserPermission", 'String'>
    readonly userId: FieldRef<"UserPermission", 'String'>
    readonly permission: FieldRef<"UserPermission", 'String'>
    readonly grantedBy: FieldRef<"UserPermission", 'String'>
    readonly grantedAt: FieldRef<"UserPermission", 'DateTime'>
    readonly isActive: FieldRef<"UserPermission", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserPermission findUnique
   */
  export type UserPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission findUniqueOrThrow
   */
  export type UserPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission findFirst
   */
  export type UserPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPermissions.
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPermissions.
     */
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * UserPermission findFirstOrThrow
   */
  export type UserPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPermissions.
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPermissions.
     */
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * UserPermission findMany
   */
  export type UserPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermissions to fetch.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPermissions.
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * UserPermission create
   */
  export type UserPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPermission.
     */
    data: XOR<UserPermissionCreateInput, UserPermissionUncheckedCreateInput>
  }

  /**
   * UserPermission createMany
   */
  export type UserPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPermissions.
     */
    data: UserPermissionCreateManyInput | UserPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPermission createManyAndReturn
   */
  export type UserPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many UserPermissions.
     */
    data: UserPermissionCreateManyInput | UserPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPermission update
   */
  export type UserPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPermission.
     */
    data: XOR<UserPermissionUpdateInput, UserPermissionUncheckedUpdateInput>
    /**
     * Choose, which UserPermission to update.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission updateMany
   */
  export type UserPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPermissions.
     */
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyInput>
    /**
     * Filter which UserPermissions to update
     */
    where?: UserPermissionWhereInput
    /**
     * Limit how many UserPermissions to update.
     */
    limit?: number
  }

  /**
   * UserPermission updateManyAndReturn
   */
  export type UserPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * The data used to update UserPermissions.
     */
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyInput>
    /**
     * Filter which UserPermissions to update
     */
    where?: UserPermissionWhereInput
    /**
     * Limit how many UserPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPermission upsert
   */
  export type UserPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPermission to update in case it exists.
     */
    where: UserPermissionWhereUniqueInput
    /**
     * In case the UserPermission found by the `where` argument doesn't exist, create a new UserPermission with this data.
     */
    create: XOR<UserPermissionCreateInput, UserPermissionUncheckedCreateInput>
    /**
     * In case the UserPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPermissionUpdateInput, UserPermissionUncheckedUpdateInput>
  }

  /**
   * UserPermission delete
   */
  export type UserPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter which UserPermission to delete.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission deleteMany
   */
  export type UserPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPermissions to delete
     */
    where?: UserPermissionWhereInput
    /**
     * Limit how many UserPermissions to delete.
     */
    limit?: number
  }

  /**
   * UserPermission without action
   */
  export type UserPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    tenantId: string | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    tenantId: string | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    description: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    tenantId: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    tenantId?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    tenantId?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    tenantId?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string | null
    description: string
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    tenantId: string | null
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    tenantId?: boolean
    tenant?: boolean | Activity$tenantArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    tenantId?: boolean
    tenant?: boolean | Activity$tenantArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    tenantId?: boolean
    tenant?: boolean | Activity$tenantArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    tenantId?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "description" | "details" | "ipAddress" | "userAgent" | "createdAt" | "tenantId", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Activity$tenantArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Activity$tenantArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Activity$tenantArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: string
      entityId: string | null
      description: string
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      tenantId: string | null
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends Activity$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Activity$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly userId: FieldRef<"Activity", 'String'>
    readonly action: FieldRef<"Activity", 'String'>
    readonly entityType: FieldRef<"Activity", 'String'>
    readonly entityId: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly details: FieldRef<"Activity", 'Json'>
    readonly ipAddress: FieldRef<"Activity", 'String'>
    readonly userAgent: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly tenantId: FieldRef<"Activity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.tenant
   */
  export type Activity$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    luggageCount: number | null
    price: number | null
    driverFee: number | null
    distanceKm: number | null
  }

  export type ReservationSumAggregateOutputType = {
    luggageCount: number | null
    price: number | null
    driverFee: number | null
    distanceKm: number | null
  }

  export type ReservationMinAggregateOutputType = {
    id: string | null
    date: string | null
    time: string | null
    from: string | null
    to: string | null
    flightCode: string | null
    passengerNames: string | null
    luggageCount: number | null
    price: number | null
    currency: string | null
    phoneNumber: string | null
    voucherNumber: string | null
    driverFee: number | null
    driverId: string | null
    paymentStatus: string | null
    createdAt: Date | null
    returnTransferId: string | null
    isReturn: boolean | null
    distanceKm: number | null
    userId: string | null
    tenantId: string | null
    companyCommissionStatus: string | null
    notes: string | null
    email: string | null
    type: string | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: string | null
    date: string | null
    time: string | null
    from: string | null
    to: string | null
    flightCode: string | null
    passengerNames: string | null
    luggageCount: number | null
    price: number | null
    currency: string | null
    phoneNumber: string | null
    voucherNumber: string | null
    driverFee: number | null
    driverId: string | null
    paymentStatus: string | null
    createdAt: Date | null
    returnTransferId: string | null
    isReturn: boolean | null
    distanceKm: number | null
    userId: string | null
    tenantId: string | null
    companyCommissionStatus: string | null
    notes: string | null
    email: string | null
    type: string | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    date: number
    time: number
    from: number
    to: number
    flightCode: number
    passengerNames: number
    luggageCount: number
    price: number
    currency: number
    phoneNumber: number
    voucherNumber: number
    driverFee: number
    driverId: number
    paymentStatus: number
    createdAt: number
    returnTransferId: number
    isReturn: number
    distanceKm: number
    userId: number
    tenantId: number
    companyCommissionStatus: number
    notes: number
    email: number
    type: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    luggageCount?: true
    price?: true
    driverFee?: true
    distanceKm?: true
  }

  export type ReservationSumAggregateInputType = {
    luggageCount?: true
    price?: true
    driverFee?: true
    distanceKm?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    date?: true
    time?: true
    from?: true
    to?: true
    flightCode?: true
    passengerNames?: true
    luggageCount?: true
    price?: true
    currency?: true
    phoneNumber?: true
    voucherNumber?: true
    driverFee?: true
    driverId?: true
    paymentStatus?: true
    createdAt?: true
    returnTransferId?: true
    isReturn?: true
    distanceKm?: true
    userId?: true
    tenantId?: true
    companyCommissionStatus?: true
    notes?: true
    email?: true
    type?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    date?: true
    time?: true
    from?: true
    to?: true
    flightCode?: true
    passengerNames?: true
    luggageCount?: true
    price?: true
    currency?: true
    phoneNumber?: true
    voucherNumber?: true
    driverFee?: true
    driverId?: true
    paymentStatus?: true
    createdAt?: true
    returnTransferId?: true
    isReturn?: true
    distanceKm?: true
    userId?: true
    tenantId?: true
    companyCommissionStatus?: true
    notes?: true
    email?: true
    type?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    date?: true
    time?: true
    from?: true
    to?: true
    flightCode?: true
    passengerNames?: true
    luggageCount?: true
    price?: true
    currency?: true
    phoneNumber?: true
    voucherNumber?: true
    driverFee?: true
    driverId?: true
    paymentStatus?: true
    createdAt?: true
    returnTransferId?: true
    isReturn?: true
    distanceKm?: true
    userId?: true
    tenantId?: true
    companyCommissionStatus?: true
    notes?: true
    email?: true
    type?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber: string | null
    voucherNumber: string
    driverFee: number | null
    driverId: string | null
    paymentStatus: string
    createdAt: Date
    returnTransferId: string | null
    isReturn: boolean
    distanceKm: number | null
    userId: string | null
    tenantId: string | null
    companyCommissionStatus: string
    notes: string | null
    email: string | null
    type: string
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    from?: boolean
    to?: boolean
    flightCode?: boolean
    passengerNames?: boolean
    luggageCount?: boolean
    price?: boolean
    currency?: boolean
    phoneNumber?: boolean
    voucherNumber?: boolean
    driverFee?: boolean
    driverId?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    returnTransferId?: boolean
    isReturn?: boolean
    distanceKm?: boolean
    userId?: boolean
    tenantId?: boolean
    companyCommissionStatus?: boolean
    notes?: boolean
    email?: boolean
    type?: boolean
    driver?: boolean | Reservation$driverArgs<ExtArgs>
    returnTransfer?: boolean | Reservation$returnTransferArgs<ExtArgs>
    originalTransfer?: boolean | Reservation$originalTransferArgs<ExtArgs>
    tenant?: boolean | Reservation$tenantArgs<ExtArgs>
    user?: boolean | Reservation$userArgs<ExtArgs>
    hotelBookings?: boolean | Reservation$hotelBookingsArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    from?: boolean
    to?: boolean
    flightCode?: boolean
    passengerNames?: boolean
    luggageCount?: boolean
    price?: boolean
    currency?: boolean
    phoneNumber?: boolean
    voucherNumber?: boolean
    driverFee?: boolean
    driverId?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    returnTransferId?: boolean
    isReturn?: boolean
    distanceKm?: boolean
    userId?: boolean
    tenantId?: boolean
    companyCommissionStatus?: boolean
    notes?: boolean
    email?: boolean
    type?: boolean
    driver?: boolean | Reservation$driverArgs<ExtArgs>
    returnTransfer?: boolean | Reservation$returnTransferArgs<ExtArgs>
    tenant?: boolean | Reservation$tenantArgs<ExtArgs>
    user?: boolean | Reservation$userArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    from?: boolean
    to?: boolean
    flightCode?: boolean
    passengerNames?: boolean
    luggageCount?: boolean
    price?: boolean
    currency?: boolean
    phoneNumber?: boolean
    voucherNumber?: boolean
    driverFee?: boolean
    driverId?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    returnTransferId?: boolean
    isReturn?: boolean
    distanceKm?: boolean
    userId?: boolean
    tenantId?: boolean
    companyCommissionStatus?: boolean
    notes?: boolean
    email?: boolean
    type?: boolean
    driver?: boolean | Reservation$driverArgs<ExtArgs>
    returnTransfer?: boolean | Reservation$returnTransferArgs<ExtArgs>
    tenant?: boolean | Reservation$tenantArgs<ExtArgs>
    user?: boolean | Reservation$userArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    date?: boolean
    time?: boolean
    from?: boolean
    to?: boolean
    flightCode?: boolean
    passengerNames?: boolean
    luggageCount?: boolean
    price?: boolean
    currency?: boolean
    phoneNumber?: boolean
    voucherNumber?: boolean
    driverFee?: boolean
    driverId?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    returnTransferId?: boolean
    isReturn?: boolean
    distanceKm?: boolean
    userId?: boolean
    tenantId?: boolean
    companyCommissionStatus?: boolean
    notes?: boolean
    email?: boolean
    type?: boolean
  }

  export type ReservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "time" | "from" | "to" | "flightCode" | "passengerNames" | "luggageCount" | "price" | "currency" | "phoneNumber" | "voucherNumber" | "driverFee" | "driverId" | "paymentStatus" | "createdAt" | "returnTransferId" | "isReturn" | "distanceKm" | "userId" | "tenantId" | "companyCommissionStatus" | "notes" | "email" | "type", ExtArgs["result"]["reservation"]>
  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | Reservation$driverArgs<ExtArgs>
    returnTransfer?: boolean | Reservation$returnTransferArgs<ExtArgs>
    originalTransfer?: boolean | Reservation$originalTransferArgs<ExtArgs>
    tenant?: boolean | Reservation$tenantArgs<ExtArgs>
    user?: boolean | Reservation$userArgs<ExtArgs>
    hotelBookings?: boolean | Reservation$hotelBookingsArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | Reservation$driverArgs<ExtArgs>
    returnTransfer?: boolean | Reservation$returnTransferArgs<ExtArgs>
    tenant?: boolean | Reservation$tenantArgs<ExtArgs>
    user?: boolean | Reservation$userArgs<ExtArgs>
  }
  export type ReservationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | Reservation$driverArgs<ExtArgs>
    returnTransfer?: boolean | Reservation$returnTransferArgs<ExtArgs>
    tenant?: boolean | Reservation$tenantArgs<ExtArgs>
    user?: boolean | Reservation$userArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      driver: Prisma.$DriverPayload<ExtArgs> | null
      returnTransfer: Prisma.$ReservationPayload<ExtArgs> | null
      originalTransfer: Prisma.$ReservationPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      hotelBookings: Prisma.$HotelBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: string
      time: string
      from: string
      to: string
      flightCode: string
      passengerNames: string
      luggageCount: number
      price: number
      currency: string
      phoneNumber: string | null
      voucherNumber: string
      driverFee: number | null
      driverId: string | null
      paymentStatus: string
      createdAt: Date
      returnTransferId: string | null
      isReturn: boolean
      distanceKm: number | null
      userId: string | null
      tenantId: string | null
      companyCommissionStatus: string
      notes: string | null
      email: string | null
      type: string
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations and returns the data updated in the database.
     * @param {ReservationUpdateManyAndReturnArgs} args - Arguments to update many Reservations.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReservationUpdateManyAndReturnArgs>(args: SelectSubset<T, ReservationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends Reservation$driverArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$driverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    returnTransfer<T extends Reservation$returnTransferArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$returnTransferArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    originalTransfer<T extends Reservation$originalTransferArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$originalTransferArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends Reservation$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Reservation$userArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hotelBookings<T extends Reservation$hotelBookingsArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$hotelBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'String'>
    readonly date: FieldRef<"Reservation", 'String'>
    readonly time: FieldRef<"Reservation", 'String'>
    readonly from: FieldRef<"Reservation", 'String'>
    readonly to: FieldRef<"Reservation", 'String'>
    readonly flightCode: FieldRef<"Reservation", 'String'>
    readonly passengerNames: FieldRef<"Reservation", 'String'>
    readonly luggageCount: FieldRef<"Reservation", 'Int'>
    readonly price: FieldRef<"Reservation", 'Float'>
    readonly currency: FieldRef<"Reservation", 'String'>
    readonly phoneNumber: FieldRef<"Reservation", 'String'>
    readonly voucherNumber: FieldRef<"Reservation", 'String'>
    readonly driverFee: FieldRef<"Reservation", 'Float'>
    readonly driverId: FieldRef<"Reservation", 'String'>
    readonly paymentStatus: FieldRef<"Reservation", 'String'>
    readonly createdAt: FieldRef<"Reservation", 'DateTime'>
    readonly returnTransferId: FieldRef<"Reservation", 'String'>
    readonly isReturn: FieldRef<"Reservation", 'Boolean'>
    readonly distanceKm: FieldRef<"Reservation", 'Float'>
    readonly userId: FieldRef<"Reservation", 'String'>
    readonly tenantId: FieldRef<"Reservation", 'String'>
    readonly companyCommissionStatus: FieldRef<"Reservation", 'String'>
    readonly notes: FieldRef<"Reservation", 'String'>
    readonly email: FieldRef<"Reservation", 'String'>
    readonly type: FieldRef<"Reservation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
  }

  /**
   * Reservation updateManyAndReturn
   */
  export type ReservationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to delete.
     */
    limit?: number
  }

  /**
   * Reservation.driver
   */
  export type Reservation$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * Reservation.returnTransfer
   */
  export type Reservation$returnTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
  }

  /**
   * Reservation.originalTransfer
   */
  export type Reservation$originalTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
  }

  /**
   * Reservation.tenant
   */
  export type Reservation$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Reservation.user
   */
  export type Reservation$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Reservation.hotelBookings
   */
  export type Reservation$hotelBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    where?: HotelBookingWhereInput
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    cursor?: HotelBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model HotelRequest
   */

  export type AggregateHotelRequest = {
    _count: HotelRequestCountAggregateOutputType | null
    _avg: HotelRequestAvgAggregateOutputType | null
    _sum: HotelRequestSumAggregateOutputType | null
    _min: HotelRequestMinAggregateOutputType | null
    _max: HotelRequestMaxAggregateOutputType | null
  }

  export type HotelRequestAvgAggregateOutputType = {
    adults: number | null
    children: number | null
    rooms: number | null
    budget: number | null
  }

  export type HotelRequestSumAggregateOutputType = {
    adults: number | null
    children: number | null
    rooms: number | null
    budget: number | null
  }

  export type HotelRequestMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    customerName: string | null
    customerEmail: string | null
    customerPhone: string | null
    checkin: Date | null
    checkout: Date | null
    adults: number | null
    children: number | null
    rooms: number | null
    city: string | null
    region: string | null
    budget: number | null
    roomType: string | null
    breakfast: boolean | null
    amenities: string | null
    specialRequests: string | null
    status: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelRequestMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    customerName: string | null
    customerEmail: string | null
    customerPhone: string | null
    checkin: Date | null
    checkout: Date | null
    adults: number | null
    children: number | null
    rooms: number | null
    city: string | null
    region: string | null
    budget: number | null
    roomType: string | null
    breakfast: boolean | null
    amenities: string | null
    specialRequests: string | null
    status: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelRequestCountAggregateOutputType = {
    id: number
    tenantId: number
    customerName: number
    customerEmail: number
    customerPhone: number
    checkin: number
    checkout: number
    adults: number
    children: number
    rooms: number
    city: number
    region: number
    budget: number
    roomType: number
    breakfast: number
    amenities: number
    specialRequests: number
    status: number
    assignedTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelRequestAvgAggregateInputType = {
    adults?: true
    children?: true
    rooms?: true
    budget?: true
  }

  export type HotelRequestSumAggregateInputType = {
    adults?: true
    children?: true
    rooms?: true
    budget?: true
  }

  export type HotelRequestMinAggregateInputType = {
    id?: true
    tenantId?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    checkin?: true
    checkout?: true
    adults?: true
    children?: true
    rooms?: true
    city?: true
    region?: true
    budget?: true
    roomType?: true
    breakfast?: true
    amenities?: true
    specialRequests?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelRequestMaxAggregateInputType = {
    id?: true
    tenantId?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    checkin?: true
    checkout?: true
    adults?: true
    children?: true
    rooms?: true
    city?: true
    region?: true
    budget?: true
    roomType?: true
    breakfast?: true
    amenities?: true
    specialRequests?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelRequestCountAggregateInputType = {
    id?: true
    tenantId?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    checkin?: true
    checkout?: true
    adults?: true
    children?: true
    rooms?: true
    city?: true
    region?: true
    budget?: true
    roomType?: true
    breakfast?: true
    amenities?: true
    specialRequests?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelRequest to aggregate.
     */
    where?: HotelRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRequests to fetch.
     */
    orderBy?: HotelRequestOrderByWithRelationInput | HotelRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelRequests
    **/
    _count?: true | HotelRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelRequestMaxAggregateInputType
  }

  export type GetHotelRequestAggregateType<T extends HotelRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelRequest[P]>
      : GetScalarType<T[P], AggregateHotelRequest[P]>
  }




  export type HotelRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelRequestWhereInput
    orderBy?: HotelRequestOrderByWithAggregationInput | HotelRequestOrderByWithAggregationInput[]
    by: HotelRequestScalarFieldEnum[] | HotelRequestScalarFieldEnum
    having?: HotelRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelRequestCountAggregateInputType | true
    _avg?: HotelRequestAvgAggregateInputType
    _sum?: HotelRequestSumAggregateInputType
    _min?: HotelRequestMinAggregateInputType
    _max?: HotelRequestMaxAggregateInputType
  }

  export type HotelRequestGroupByOutputType = {
    id: string
    tenantId: string | null
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date
    checkout: Date
    adults: number
    children: number
    rooms: number
    city: string
    region: string | null
    budget: number | null
    roomType: string | null
    breakfast: boolean
    amenities: string
    specialRequests: string | null
    status: string
    assignedTo: string | null
    createdAt: Date
    updatedAt: Date
    _count: HotelRequestCountAggregateOutputType | null
    _avg: HotelRequestAvgAggregateOutputType | null
    _sum: HotelRequestSumAggregateOutputType | null
    _min: HotelRequestMinAggregateOutputType | null
    _max: HotelRequestMaxAggregateOutputType | null
  }

  type GetHotelRequestGroupByPayload<T extends HotelRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelRequestGroupByOutputType[P]>
            : GetScalarType<T[P], HotelRequestGroupByOutputType[P]>
        }
      >
    >


  export type HotelRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    checkin?: boolean
    checkout?: boolean
    adults?: boolean
    children?: boolean
    rooms?: boolean
    city?: boolean
    region?: boolean
    budget?: boolean
    roomType?: boolean
    breakfast?: boolean
    amenities?: boolean
    specialRequests?: boolean
    status?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelBookings?: boolean | HotelRequest$hotelBookingsArgs<ExtArgs>
    user?: boolean | HotelRequest$userArgs<ExtArgs>
    tenant?: boolean | HotelRequest$tenantArgs<ExtArgs>
    _count?: boolean | HotelRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelRequest"]>

  export type HotelRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    checkin?: boolean
    checkout?: boolean
    adults?: boolean
    children?: boolean
    rooms?: boolean
    city?: boolean
    region?: boolean
    budget?: boolean
    roomType?: boolean
    breakfast?: boolean
    amenities?: boolean
    specialRequests?: boolean
    status?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | HotelRequest$userArgs<ExtArgs>
    tenant?: boolean | HotelRequest$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["hotelRequest"]>

  export type HotelRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    checkin?: boolean
    checkout?: boolean
    adults?: boolean
    children?: boolean
    rooms?: boolean
    city?: boolean
    region?: boolean
    budget?: boolean
    roomType?: boolean
    breakfast?: boolean
    amenities?: boolean
    specialRequests?: boolean
    status?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | HotelRequest$userArgs<ExtArgs>
    tenant?: boolean | HotelRequest$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["hotelRequest"]>

  export type HotelRequestSelectScalar = {
    id?: boolean
    tenantId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    checkin?: boolean
    checkout?: boolean
    adults?: boolean
    children?: boolean
    rooms?: boolean
    city?: boolean
    region?: boolean
    budget?: boolean
    roomType?: boolean
    breakfast?: boolean
    amenities?: boolean
    specialRequests?: boolean
    status?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "customerName" | "customerEmail" | "customerPhone" | "checkin" | "checkout" | "adults" | "children" | "rooms" | "city" | "region" | "budget" | "roomType" | "breakfast" | "amenities" | "specialRequests" | "status" | "assignedTo" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelRequest"]>
  export type HotelRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelBookings?: boolean | HotelRequest$hotelBookingsArgs<ExtArgs>
    user?: boolean | HotelRequest$userArgs<ExtArgs>
    tenant?: boolean | HotelRequest$tenantArgs<ExtArgs>
    _count?: boolean | HotelRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | HotelRequest$userArgs<ExtArgs>
    tenant?: boolean | HotelRequest$tenantArgs<ExtArgs>
  }
  export type HotelRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | HotelRequest$userArgs<ExtArgs>
    tenant?: boolean | HotelRequest$tenantArgs<ExtArgs>
  }

  export type $HotelRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelRequest"
    objects: {
      hotelBookings: Prisma.$HotelBookingPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      customerName: string
      customerEmail: string
      customerPhone: string
      checkin: Date
      checkout: Date
      adults: number
      children: number
      rooms: number
      city: string
      region: string | null
      budget: number | null
      roomType: string | null
      breakfast: boolean
      amenities: string
      specialRequests: string | null
      status: string
      assignedTo: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelRequest"]>
    composites: {}
  }

  type HotelRequestGetPayload<S extends boolean | null | undefined | HotelRequestDefaultArgs> = $Result.GetResult<Prisma.$HotelRequestPayload, S>

  type HotelRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelRequestCountAggregateInputType | true
    }

  export interface HotelRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelRequest'], meta: { name: 'HotelRequest' } }
    /**
     * Find zero or one HotelRequest that matches the filter.
     * @param {HotelRequestFindUniqueArgs} args - Arguments to find a HotelRequest
     * @example
     * // Get one HotelRequest
     * const hotelRequest = await prisma.hotelRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelRequestFindUniqueArgs>(args: SelectSubset<T, HotelRequestFindUniqueArgs<ExtArgs>>): Prisma__HotelRequestClient<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelRequestFindUniqueOrThrowArgs} args - Arguments to find a HotelRequest
     * @example
     * // Get one HotelRequest
     * const hotelRequest = await prisma.hotelRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelRequestClient<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRequestFindFirstArgs} args - Arguments to find a HotelRequest
     * @example
     * // Get one HotelRequest
     * const hotelRequest = await prisma.hotelRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelRequestFindFirstArgs>(args?: SelectSubset<T, HotelRequestFindFirstArgs<ExtArgs>>): Prisma__HotelRequestClient<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRequestFindFirstOrThrowArgs} args - Arguments to find a HotelRequest
     * @example
     * // Get one HotelRequest
     * const hotelRequest = await prisma.hotelRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelRequestClient<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelRequests
     * const hotelRequests = await prisma.hotelRequest.findMany()
     * 
     * // Get first 10 HotelRequests
     * const hotelRequests = await prisma.hotelRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelRequestWithIdOnly = await prisma.hotelRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelRequestFindManyArgs>(args?: SelectSubset<T, HotelRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelRequest.
     * @param {HotelRequestCreateArgs} args - Arguments to create a HotelRequest.
     * @example
     * // Create one HotelRequest
     * const HotelRequest = await prisma.hotelRequest.create({
     *   data: {
     *     // ... data to create a HotelRequest
     *   }
     * })
     * 
     */
    create<T extends HotelRequestCreateArgs>(args: SelectSubset<T, HotelRequestCreateArgs<ExtArgs>>): Prisma__HotelRequestClient<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelRequests.
     * @param {HotelRequestCreateManyArgs} args - Arguments to create many HotelRequests.
     * @example
     * // Create many HotelRequests
     * const hotelRequest = await prisma.hotelRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelRequestCreateManyArgs>(args?: SelectSubset<T, HotelRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelRequests and returns the data saved in the database.
     * @param {HotelRequestCreateManyAndReturnArgs} args - Arguments to create many HotelRequests.
     * @example
     * // Create many HotelRequests
     * const hotelRequest = await prisma.hotelRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelRequests and only return the `id`
     * const hotelRequestWithIdOnly = await prisma.hotelRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelRequest.
     * @param {HotelRequestDeleteArgs} args - Arguments to delete one HotelRequest.
     * @example
     * // Delete one HotelRequest
     * const HotelRequest = await prisma.hotelRequest.delete({
     *   where: {
     *     // ... filter to delete one HotelRequest
     *   }
     * })
     * 
     */
    delete<T extends HotelRequestDeleteArgs>(args: SelectSubset<T, HotelRequestDeleteArgs<ExtArgs>>): Prisma__HotelRequestClient<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelRequest.
     * @param {HotelRequestUpdateArgs} args - Arguments to update one HotelRequest.
     * @example
     * // Update one HotelRequest
     * const hotelRequest = await prisma.hotelRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelRequestUpdateArgs>(args: SelectSubset<T, HotelRequestUpdateArgs<ExtArgs>>): Prisma__HotelRequestClient<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelRequests.
     * @param {HotelRequestDeleteManyArgs} args - Arguments to filter HotelRequests to delete.
     * @example
     * // Delete a few HotelRequests
     * const { count } = await prisma.hotelRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelRequestDeleteManyArgs>(args?: SelectSubset<T, HotelRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelRequests
     * const hotelRequest = await prisma.hotelRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelRequestUpdateManyArgs>(args: SelectSubset<T, HotelRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelRequests and returns the data updated in the database.
     * @param {HotelRequestUpdateManyAndReturnArgs} args - Arguments to update many HotelRequests.
     * @example
     * // Update many HotelRequests
     * const hotelRequest = await prisma.hotelRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelRequests and only return the `id`
     * const hotelRequestWithIdOnly = await prisma.hotelRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelRequest.
     * @param {HotelRequestUpsertArgs} args - Arguments to update or create a HotelRequest.
     * @example
     * // Update or create a HotelRequest
     * const hotelRequest = await prisma.hotelRequest.upsert({
     *   create: {
     *     // ... data to create a HotelRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelRequest we want to update
     *   }
     * })
     */
    upsert<T extends HotelRequestUpsertArgs>(args: SelectSubset<T, HotelRequestUpsertArgs<ExtArgs>>): Prisma__HotelRequestClient<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRequestCountArgs} args - Arguments to filter HotelRequests to count.
     * @example
     * // Count the number of HotelRequests
     * const count = await prisma.hotelRequest.count({
     *   where: {
     *     // ... the filter for the HotelRequests we want to count
     *   }
     * })
    **/
    count<T extends HotelRequestCountArgs>(
      args?: Subset<T, HotelRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelRequestAggregateArgs>(args: Subset<T, HotelRequestAggregateArgs>): Prisma.PrismaPromise<GetHotelRequestAggregateType<T>>

    /**
     * Group by HotelRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelRequestGroupByArgs['orderBy'] }
        : { orderBy?: HotelRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelRequest model
   */
  readonly fields: HotelRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotelBookings<T extends HotelRequest$hotelBookingsArgs<ExtArgs> = {}>(args?: Subset<T, HotelRequest$hotelBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends HotelRequest$userArgs<ExtArgs> = {}>(args?: Subset<T, HotelRequest$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends HotelRequest$tenantArgs<ExtArgs> = {}>(args?: Subset<T, HotelRequest$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelRequest model
   */
  interface HotelRequestFieldRefs {
    readonly id: FieldRef<"HotelRequest", 'String'>
    readonly tenantId: FieldRef<"HotelRequest", 'String'>
    readonly customerName: FieldRef<"HotelRequest", 'String'>
    readonly customerEmail: FieldRef<"HotelRequest", 'String'>
    readonly customerPhone: FieldRef<"HotelRequest", 'String'>
    readonly checkin: FieldRef<"HotelRequest", 'DateTime'>
    readonly checkout: FieldRef<"HotelRequest", 'DateTime'>
    readonly adults: FieldRef<"HotelRequest", 'Int'>
    readonly children: FieldRef<"HotelRequest", 'Int'>
    readonly rooms: FieldRef<"HotelRequest", 'Int'>
    readonly city: FieldRef<"HotelRequest", 'String'>
    readonly region: FieldRef<"HotelRequest", 'String'>
    readonly budget: FieldRef<"HotelRequest", 'Float'>
    readonly roomType: FieldRef<"HotelRequest", 'String'>
    readonly breakfast: FieldRef<"HotelRequest", 'Boolean'>
    readonly amenities: FieldRef<"HotelRequest", 'String'>
    readonly specialRequests: FieldRef<"HotelRequest", 'String'>
    readonly status: FieldRef<"HotelRequest", 'String'>
    readonly assignedTo: FieldRef<"HotelRequest", 'String'>
    readonly createdAt: FieldRef<"HotelRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelRequest findUnique
   */
  export type HotelRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    /**
     * Filter, which HotelRequest to fetch.
     */
    where: HotelRequestWhereUniqueInput
  }

  /**
   * HotelRequest findUniqueOrThrow
   */
  export type HotelRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    /**
     * Filter, which HotelRequest to fetch.
     */
    where: HotelRequestWhereUniqueInput
  }

  /**
   * HotelRequest findFirst
   */
  export type HotelRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    /**
     * Filter, which HotelRequest to fetch.
     */
    where?: HotelRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRequests to fetch.
     */
    orderBy?: HotelRequestOrderByWithRelationInput | HotelRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelRequests.
     */
    cursor?: HotelRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelRequests.
     */
    distinct?: HotelRequestScalarFieldEnum | HotelRequestScalarFieldEnum[]
  }

  /**
   * HotelRequest findFirstOrThrow
   */
  export type HotelRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    /**
     * Filter, which HotelRequest to fetch.
     */
    where?: HotelRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRequests to fetch.
     */
    orderBy?: HotelRequestOrderByWithRelationInput | HotelRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelRequests.
     */
    cursor?: HotelRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelRequests.
     */
    distinct?: HotelRequestScalarFieldEnum | HotelRequestScalarFieldEnum[]
  }

  /**
   * HotelRequest findMany
   */
  export type HotelRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    /**
     * Filter, which HotelRequests to fetch.
     */
    where?: HotelRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRequests to fetch.
     */
    orderBy?: HotelRequestOrderByWithRelationInput | HotelRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelRequests.
     */
    cursor?: HotelRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRequests.
     */
    skip?: number
    distinct?: HotelRequestScalarFieldEnum | HotelRequestScalarFieldEnum[]
  }

  /**
   * HotelRequest create
   */
  export type HotelRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelRequest.
     */
    data: XOR<HotelRequestCreateInput, HotelRequestUncheckedCreateInput>
  }

  /**
   * HotelRequest createMany
   */
  export type HotelRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelRequests.
     */
    data: HotelRequestCreateManyInput | HotelRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelRequest createManyAndReturn
   */
  export type HotelRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * The data used to create many HotelRequests.
     */
    data: HotelRequestCreateManyInput | HotelRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelRequest update
   */
  export type HotelRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelRequest.
     */
    data: XOR<HotelRequestUpdateInput, HotelRequestUncheckedUpdateInput>
    /**
     * Choose, which HotelRequest to update.
     */
    where: HotelRequestWhereUniqueInput
  }

  /**
   * HotelRequest updateMany
   */
  export type HotelRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelRequests.
     */
    data: XOR<HotelRequestUpdateManyMutationInput, HotelRequestUncheckedUpdateManyInput>
    /**
     * Filter which HotelRequests to update
     */
    where?: HotelRequestWhereInput
    /**
     * Limit how many HotelRequests to update.
     */
    limit?: number
  }

  /**
   * HotelRequest updateManyAndReturn
   */
  export type HotelRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * The data used to update HotelRequests.
     */
    data: XOR<HotelRequestUpdateManyMutationInput, HotelRequestUncheckedUpdateManyInput>
    /**
     * Filter which HotelRequests to update
     */
    where?: HotelRequestWhereInput
    /**
     * Limit how many HotelRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelRequest upsert
   */
  export type HotelRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelRequest to update in case it exists.
     */
    where: HotelRequestWhereUniqueInput
    /**
     * In case the HotelRequest found by the `where` argument doesn't exist, create a new HotelRequest with this data.
     */
    create: XOR<HotelRequestCreateInput, HotelRequestUncheckedCreateInput>
    /**
     * In case the HotelRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelRequestUpdateInput, HotelRequestUncheckedUpdateInput>
  }

  /**
   * HotelRequest delete
   */
  export type HotelRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    /**
     * Filter which HotelRequest to delete.
     */
    where: HotelRequestWhereUniqueInput
  }

  /**
   * HotelRequest deleteMany
   */
  export type HotelRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelRequests to delete
     */
    where?: HotelRequestWhereInput
    /**
     * Limit how many HotelRequests to delete.
     */
    limit?: number
  }

  /**
   * HotelRequest.hotelBookings
   */
  export type HotelRequest$hotelBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    where?: HotelBookingWhereInput
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    cursor?: HotelBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelRequest.user
   */
  export type HotelRequest$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * HotelRequest.tenant
   */
  export type HotelRequest$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * HotelRequest without action
   */
  export type HotelRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
  }


  /**
   * Model HotelBooking
   */

  export type AggregateHotelBooking = {
    _count: HotelBookingCountAggregateOutputType | null
    _avg: HotelBookingAvgAggregateOutputType | null
    _sum: HotelBookingSumAggregateOutputType | null
    _min: HotelBookingMinAggregateOutputType | null
    _max: HotelBookingMaxAggregateOutputType | null
  }

  export type HotelBookingAvgAggregateOutputType = {
    adults: number | null
    children: number | null
    rooms: number | null
    totalPrice: number | null
    agentPrice: number | null
    customerPrice: number | null
    profitMargin: number | null
  }

  export type HotelBookingSumAggregateOutputType = {
    adults: number | null
    children: number | null
    rooms: number | null
    totalPrice: number | null
    agentPrice: number | null
    customerPrice: number | null
    profitMargin: number | null
  }

  export type HotelBookingMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    requestId: string | null
    reservationId: string | null
    hotelId: string | null
    hotelName: string | null
    hotelAddress: string | null
    roomType: string | null
    checkin: Date | null
    checkout: Date | null
    adults: number | null
    children: number | null
    rooms: number | null
    totalPrice: number | null
    currency: string | null
    bookingReference: string | null
    status: string | null
    specialRequests: string | null
    cancellationPolicy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    agentPrice: number | null
    customerPrice: number | null
    profitMargin: number | null
    voucherNumber: string | null
  }

  export type HotelBookingMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    requestId: string | null
    reservationId: string | null
    hotelId: string | null
    hotelName: string | null
    hotelAddress: string | null
    roomType: string | null
    checkin: Date | null
    checkout: Date | null
    adults: number | null
    children: number | null
    rooms: number | null
    totalPrice: number | null
    currency: string | null
    bookingReference: string | null
    status: string | null
    specialRequests: string | null
    cancellationPolicy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    agentPrice: number | null
    customerPrice: number | null
    profitMargin: number | null
    voucherNumber: string | null
  }

  export type HotelBookingCountAggregateOutputType = {
    id: number
    tenantId: number
    requestId: number
    reservationId: number
    hotelId: number
    hotelName: number
    hotelAddress: number
    roomType: number
    checkin: number
    checkout: number
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency: number
    bookingReference: number
    status: number
    customerInfo: number
    specialRequests: number
    cancellationPolicy: number
    createdAt: number
    updatedAt: number
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: number
    _all: number
  }


  export type HotelBookingAvgAggregateInputType = {
    adults?: true
    children?: true
    rooms?: true
    totalPrice?: true
    agentPrice?: true
    customerPrice?: true
    profitMargin?: true
  }

  export type HotelBookingSumAggregateInputType = {
    adults?: true
    children?: true
    rooms?: true
    totalPrice?: true
    agentPrice?: true
    customerPrice?: true
    profitMargin?: true
  }

  export type HotelBookingMinAggregateInputType = {
    id?: true
    tenantId?: true
    requestId?: true
    reservationId?: true
    hotelId?: true
    hotelName?: true
    hotelAddress?: true
    roomType?: true
    checkin?: true
    checkout?: true
    adults?: true
    children?: true
    rooms?: true
    totalPrice?: true
    currency?: true
    bookingReference?: true
    status?: true
    specialRequests?: true
    cancellationPolicy?: true
    createdAt?: true
    updatedAt?: true
    agentPrice?: true
    customerPrice?: true
    profitMargin?: true
    voucherNumber?: true
  }

  export type HotelBookingMaxAggregateInputType = {
    id?: true
    tenantId?: true
    requestId?: true
    reservationId?: true
    hotelId?: true
    hotelName?: true
    hotelAddress?: true
    roomType?: true
    checkin?: true
    checkout?: true
    adults?: true
    children?: true
    rooms?: true
    totalPrice?: true
    currency?: true
    bookingReference?: true
    status?: true
    specialRequests?: true
    cancellationPolicy?: true
    createdAt?: true
    updatedAt?: true
    agentPrice?: true
    customerPrice?: true
    profitMargin?: true
    voucherNumber?: true
  }

  export type HotelBookingCountAggregateInputType = {
    id?: true
    tenantId?: true
    requestId?: true
    reservationId?: true
    hotelId?: true
    hotelName?: true
    hotelAddress?: true
    roomType?: true
    checkin?: true
    checkout?: true
    adults?: true
    children?: true
    rooms?: true
    totalPrice?: true
    currency?: true
    bookingReference?: true
    status?: true
    customerInfo?: true
    specialRequests?: true
    cancellationPolicy?: true
    createdAt?: true
    updatedAt?: true
    agentPrice?: true
    customerPrice?: true
    profitMargin?: true
    voucherNumber?: true
    _all?: true
  }

  export type HotelBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelBooking to aggregate.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelBookings
    **/
    _count?: true | HotelBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelBookingMaxAggregateInputType
  }

  export type GetHotelBookingAggregateType<T extends HotelBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelBooking[P]>
      : GetScalarType<T[P], AggregateHotelBooking[P]>
  }




  export type HotelBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelBookingWhereInput
    orderBy?: HotelBookingOrderByWithAggregationInput | HotelBookingOrderByWithAggregationInput[]
    by: HotelBookingScalarFieldEnum[] | HotelBookingScalarFieldEnum
    having?: HotelBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelBookingCountAggregateInputType | true
    _avg?: HotelBookingAvgAggregateInputType
    _sum?: HotelBookingSumAggregateInputType
    _min?: HotelBookingMinAggregateInputType
    _max?: HotelBookingMaxAggregateInputType
  }

  export type HotelBookingGroupByOutputType = {
    id: string
    tenantId: string | null
    requestId: string | null
    reservationId: string | null
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date
    checkout: Date
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency: string
    bookingReference: string
    status: string
    customerInfo: JsonValue
    specialRequests: string | null
    cancellationPolicy: string | null
    createdAt: Date
    updatedAt: Date
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
    _count: HotelBookingCountAggregateOutputType | null
    _avg: HotelBookingAvgAggregateOutputType | null
    _sum: HotelBookingSumAggregateOutputType | null
    _min: HotelBookingMinAggregateOutputType | null
    _max: HotelBookingMaxAggregateOutputType | null
  }

  type GetHotelBookingGroupByPayload<T extends HotelBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelBookingGroupByOutputType[P]>
            : GetScalarType<T[P], HotelBookingGroupByOutputType[P]>
        }
      >
    >


  export type HotelBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    requestId?: boolean
    reservationId?: boolean
    hotelId?: boolean
    hotelName?: boolean
    hotelAddress?: boolean
    roomType?: boolean
    checkin?: boolean
    checkout?: boolean
    adults?: boolean
    children?: boolean
    rooms?: boolean
    totalPrice?: boolean
    currency?: boolean
    bookingReference?: boolean
    status?: boolean
    customerInfo?: boolean
    specialRequests?: boolean
    cancellationPolicy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentPrice?: boolean
    customerPrice?: boolean
    profitMargin?: boolean
    voucherNumber?: boolean
    request?: boolean | HotelBooking$requestArgs<ExtArgs>
    reservation?: boolean | HotelBooking$reservationArgs<ExtArgs>
    tenant?: boolean | HotelBooking$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["hotelBooking"]>

  export type HotelBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    requestId?: boolean
    reservationId?: boolean
    hotelId?: boolean
    hotelName?: boolean
    hotelAddress?: boolean
    roomType?: boolean
    checkin?: boolean
    checkout?: boolean
    adults?: boolean
    children?: boolean
    rooms?: boolean
    totalPrice?: boolean
    currency?: boolean
    bookingReference?: boolean
    status?: boolean
    customerInfo?: boolean
    specialRequests?: boolean
    cancellationPolicy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentPrice?: boolean
    customerPrice?: boolean
    profitMargin?: boolean
    voucherNumber?: boolean
    request?: boolean | HotelBooking$requestArgs<ExtArgs>
    reservation?: boolean | HotelBooking$reservationArgs<ExtArgs>
    tenant?: boolean | HotelBooking$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["hotelBooking"]>

  export type HotelBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    requestId?: boolean
    reservationId?: boolean
    hotelId?: boolean
    hotelName?: boolean
    hotelAddress?: boolean
    roomType?: boolean
    checkin?: boolean
    checkout?: boolean
    adults?: boolean
    children?: boolean
    rooms?: boolean
    totalPrice?: boolean
    currency?: boolean
    bookingReference?: boolean
    status?: boolean
    customerInfo?: boolean
    specialRequests?: boolean
    cancellationPolicy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentPrice?: boolean
    customerPrice?: boolean
    profitMargin?: boolean
    voucherNumber?: boolean
    request?: boolean | HotelBooking$requestArgs<ExtArgs>
    reservation?: boolean | HotelBooking$reservationArgs<ExtArgs>
    tenant?: boolean | HotelBooking$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["hotelBooking"]>

  export type HotelBookingSelectScalar = {
    id?: boolean
    tenantId?: boolean
    requestId?: boolean
    reservationId?: boolean
    hotelId?: boolean
    hotelName?: boolean
    hotelAddress?: boolean
    roomType?: boolean
    checkin?: boolean
    checkout?: boolean
    adults?: boolean
    children?: boolean
    rooms?: boolean
    totalPrice?: boolean
    currency?: boolean
    bookingReference?: boolean
    status?: boolean
    customerInfo?: boolean
    specialRequests?: boolean
    cancellationPolicy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentPrice?: boolean
    customerPrice?: boolean
    profitMargin?: boolean
    voucherNumber?: boolean
  }

  export type HotelBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "requestId" | "reservationId" | "hotelId" | "hotelName" | "hotelAddress" | "roomType" | "checkin" | "checkout" | "adults" | "children" | "rooms" | "totalPrice" | "currency" | "bookingReference" | "status" | "customerInfo" | "specialRequests" | "cancellationPolicy" | "createdAt" | "updatedAt" | "agentPrice" | "customerPrice" | "profitMargin" | "voucherNumber", ExtArgs["result"]["hotelBooking"]>
  export type HotelBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | HotelBooking$requestArgs<ExtArgs>
    reservation?: boolean | HotelBooking$reservationArgs<ExtArgs>
    tenant?: boolean | HotelBooking$tenantArgs<ExtArgs>
  }
  export type HotelBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | HotelBooking$requestArgs<ExtArgs>
    reservation?: boolean | HotelBooking$reservationArgs<ExtArgs>
    tenant?: boolean | HotelBooking$tenantArgs<ExtArgs>
  }
  export type HotelBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | HotelBooking$requestArgs<ExtArgs>
    reservation?: boolean | HotelBooking$reservationArgs<ExtArgs>
    tenant?: boolean | HotelBooking$tenantArgs<ExtArgs>
  }

  export type $HotelBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelBooking"
    objects: {
      request: Prisma.$HotelRequestPayload<ExtArgs> | null
      reservation: Prisma.$ReservationPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      requestId: string | null
      reservationId: string | null
      hotelId: string
      hotelName: string
      hotelAddress: string
      roomType: string
      checkin: Date
      checkout: Date
      adults: number
      children: number
      rooms: number
      totalPrice: number
      currency: string
      bookingReference: string
      status: string
      customerInfo: Prisma.JsonValue
      specialRequests: string | null
      cancellationPolicy: string | null
      createdAt: Date
      updatedAt: Date
      agentPrice: number
      customerPrice: number
      profitMargin: number
      voucherNumber: string
    }, ExtArgs["result"]["hotelBooking"]>
    composites: {}
  }

  type HotelBookingGetPayload<S extends boolean | null | undefined | HotelBookingDefaultArgs> = $Result.GetResult<Prisma.$HotelBookingPayload, S>

  type HotelBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelBookingCountAggregateInputType | true
    }

  export interface HotelBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelBooking'], meta: { name: 'HotelBooking' } }
    /**
     * Find zero or one HotelBooking that matches the filter.
     * @param {HotelBookingFindUniqueArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelBookingFindUniqueArgs>(args: SelectSubset<T, HotelBookingFindUniqueArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelBookingFindUniqueOrThrowArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingFindFirstArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelBookingFindFirstArgs>(args?: SelectSubset<T, HotelBookingFindFirstArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingFindFirstOrThrowArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelBookings
     * const hotelBookings = await prisma.hotelBooking.findMany()
     * 
     * // Get first 10 HotelBookings
     * const hotelBookings = await prisma.hotelBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelBookingWithIdOnly = await prisma.hotelBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelBookingFindManyArgs>(args?: SelectSubset<T, HotelBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelBooking.
     * @param {HotelBookingCreateArgs} args - Arguments to create a HotelBooking.
     * @example
     * // Create one HotelBooking
     * const HotelBooking = await prisma.hotelBooking.create({
     *   data: {
     *     // ... data to create a HotelBooking
     *   }
     * })
     * 
     */
    create<T extends HotelBookingCreateArgs>(args: SelectSubset<T, HotelBookingCreateArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelBookings.
     * @param {HotelBookingCreateManyArgs} args - Arguments to create many HotelBookings.
     * @example
     * // Create many HotelBookings
     * const hotelBooking = await prisma.hotelBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelBookingCreateManyArgs>(args?: SelectSubset<T, HotelBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelBookings and returns the data saved in the database.
     * @param {HotelBookingCreateManyAndReturnArgs} args - Arguments to create many HotelBookings.
     * @example
     * // Create many HotelBookings
     * const hotelBooking = await prisma.hotelBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelBookings and only return the `id`
     * const hotelBookingWithIdOnly = await prisma.hotelBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelBooking.
     * @param {HotelBookingDeleteArgs} args - Arguments to delete one HotelBooking.
     * @example
     * // Delete one HotelBooking
     * const HotelBooking = await prisma.hotelBooking.delete({
     *   where: {
     *     // ... filter to delete one HotelBooking
     *   }
     * })
     * 
     */
    delete<T extends HotelBookingDeleteArgs>(args: SelectSubset<T, HotelBookingDeleteArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelBooking.
     * @param {HotelBookingUpdateArgs} args - Arguments to update one HotelBooking.
     * @example
     * // Update one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelBookingUpdateArgs>(args: SelectSubset<T, HotelBookingUpdateArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelBookings.
     * @param {HotelBookingDeleteManyArgs} args - Arguments to filter HotelBookings to delete.
     * @example
     * // Delete a few HotelBookings
     * const { count } = await prisma.hotelBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelBookingDeleteManyArgs>(args?: SelectSubset<T, HotelBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelBookings
     * const hotelBooking = await prisma.hotelBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelBookingUpdateManyArgs>(args: SelectSubset<T, HotelBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelBookings and returns the data updated in the database.
     * @param {HotelBookingUpdateManyAndReturnArgs} args - Arguments to update many HotelBookings.
     * @example
     * // Update many HotelBookings
     * const hotelBooking = await prisma.hotelBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelBookings and only return the `id`
     * const hotelBookingWithIdOnly = await prisma.hotelBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelBooking.
     * @param {HotelBookingUpsertArgs} args - Arguments to update or create a HotelBooking.
     * @example
     * // Update or create a HotelBooking
     * const hotelBooking = await prisma.hotelBooking.upsert({
     *   create: {
     *     // ... data to create a HotelBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelBooking we want to update
     *   }
     * })
     */
    upsert<T extends HotelBookingUpsertArgs>(args: SelectSubset<T, HotelBookingUpsertArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingCountArgs} args - Arguments to filter HotelBookings to count.
     * @example
     * // Count the number of HotelBookings
     * const count = await prisma.hotelBooking.count({
     *   where: {
     *     // ... the filter for the HotelBookings we want to count
     *   }
     * })
    **/
    count<T extends HotelBookingCountArgs>(
      args?: Subset<T, HotelBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelBookingAggregateArgs>(args: Subset<T, HotelBookingAggregateArgs>): Prisma.PrismaPromise<GetHotelBookingAggregateType<T>>

    /**
     * Group by HotelBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelBookingGroupByArgs['orderBy'] }
        : { orderBy?: HotelBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelBooking model
   */
  readonly fields: HotelBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends HotelBooking$requestArgs<ExtArgs> = {}>(args?: Subset<T, HotelBooking$requestArgs<ExtArgs>>): Prisma__HotelRequestClient<$Result.GetResult<Prisma.$HotelRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reservation<T extends HotelBooking$reservationArgs<ExtArgs> = {}>(args?: Subset<T, HotelBooking$reservationArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends HotelBooking$tenantArgs<ExtArgs> = {}>(args?: Subset<T, HotelBooking$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelBooking model
   */
  interface HotelBookingFieldRefs {
    readonly id: FieldRef<"HotelBooking", 'String'>
    readonly tenantId: FieldRef<"HotelBooking", 'String'>
    readonly requestId: FieldRef<"HotelBooking", 'String'>
    readonly reservationId: FieldRef<"HotelBooking", 'String'>
    readonly hotelId: FieldRef<"HotelBooking", 'String'>
    readonly hotelName: FieldRef<"HotelBooking", 'String'>
    readonly hotelAddress: FieldRef<"HotelBooking", 'String'>
    readonly roomType: FieldRef<"HotelBooking", 'String'>
    readonly checkin: FieldRef<"HotelBooking", 'DateTime'>
    readonly checkout: FieldRef<"HotelBooking", 'DateTime'>
    readonly adults: FieldRef<"HotelBooking", 'Int'>
    readonly children: FieldRef<"HotelBooking", 'Int'>
    readonly rooms: FieldRef<"HotelBooking", 'Int'>
    readonly totalPrice: FieldRef<"HotelBooking", 'Float'>
    readonly currency: FieldRef<"HotelBooking", 'String'>
    readonly bookingReference: FieldRef<"HotelBooking", 'String'>
    readonly status: FieldRef<"HotelBooking", 'String'>
    readonly customerInfo: FieldRef<"HotelBooking", 'Json'>
    readonly specialRequests: FieldRef<"HotelBooking", 'String'>
    readonly cancellationPolicy: FieldRef<"HotelBooking", 'String'>
    readonly createdAt: FieldRef<"HotelBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelBooking", 'DateTime'>
    readonly agentPrice: FieldRef<"HotelBooking", 'Float'>
    readonly customerPrice: FieldRef<"HotelBooking", 'Float'>
    readonly profitMargin: FieldRef<"HotelBooking", 'Float'>
    readonly voucherNumber: FieldRef<"HotelBooking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HotelBooking findUnique
   */
  export type HotelBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking findUniqueOrThrow
   */
  export type HotelBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking findFirst
   */
  export type HotelBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelBookings.
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelBookings.
     */
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelBooking findFirstOrThrow
   */
  export type HotelBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelBookings.
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelBookings.
     */
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelBooking findMany
   */
  export type HotelBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBookings to fetch.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelBookings.
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelBooking create
   */
  export type HotelBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelBooking.
     */
    data: XOR<HotelBookingCreateInput, HotelBookingUncheckedCreateInput>
  }

  /**
   * HotelBooking createMany
   */
  export type HotelBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelBookings.
     */
    data: HotelBookingCreateManyInput | HotelBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelBooking createManyAndReturn
   */
  export type HotelBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * The data used to create many HotelBookings.
     */
    data: HotelBookingCreateManyInput | HotelBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelBooking update
   */
  export type HotelBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelBooking.
     */
    data: XOR<HotelBookingUpdateInput, HotelBookingUncheckedUpdateInput>
    /**
     * Choose, which HotelBooking to update.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking updateMany
   */
  export type HotelBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelBookings.
     */
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyInput>
    /**
     * Filter which HotelBookings to update
     */
    where?: HotelBookingWhereInput
    /**
     * Limit how many HotelBookings to update.
     */
    limit?: number
  }

  /**
   * HotelBooking updateManyAndReturn
   */
  export type HotelBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * The data used to update HotelBookings.
     */
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyInput>
    /**
     * Filter which HotelBookings to update
     */
    where?: HotelBookingWhereInput
    /**
     * Limit how many HotelBookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelBooking upsert
   */
  export type HotelBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelBooking to update in case it exists.
     */
    where: HotelBookingWhereUniqueInput
    /**
     * In case the HotelBooking found by the `where` argument doesn't exist, create a new HotelBooking with this data.
     */
    create: XOR<HotelBookingCreateInput, HotelBookingUncheckedCreateInput>
    /**
     * In case the HotelBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelBookingUpdateInput, HotelBookingUncheckedUpdateInput>
  }

  /**
   * HotelBooking delete
   */
  export type HotelBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter which HotelBooking to delete.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking deleteMany
   */
  export type HotelBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelBookings to delete
     */
    where?: HotelBookingWhereInput
    /**
     * Limit how many HotelBookings to delete.
     */
    limit?: number
  }

  /**
   * HotelBooking.request
   */
  export type HotelBooking$requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRequest
     */
    select?: HotelRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelRequest
     */
    omit?: HotelRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRequestInclude<ExtArgs> | null
    where?: HotelRequestWhereInput
  }

  /**
   * HotelBooking.reservation
   */
  export type HotelBooking$reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
  }

  /**
   * HotelBooking.tenant
   */
  export type HotelBooking$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * HotelBooking without action
   */
  export type HotelBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelBooking
     */
    omit?: HotelBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
  }


  /**
   * Model HotelPricePool
   */

  export type AggregateHotelPricePool = {
    _count: HotelPricePoolCountAggregateOutputType | null
    _avg: HotelPricePoolAvgAggregateOutputType | null
    _sum: HotelPricePoolSumAggregateOutputType | null
    _min: HotelPricePoolMinAggregateOutputType | null
    _max: HotelPricePoolMaxAggregateOutputType | null
  }

  export type HotelPricePoolAvgAggregateOutputType = {
    hotelRating: number | null
    hotelStars: number | null
    maxOccupancy: number | null
    basePrice: number | null
    agentPrice: number | null
    customerPrice: number | null
    profitMargin: number | null
    profitPercentage: number | null
  }

  export type HotelPricePoolSumAggregateOutputType = {
    hotelRating: number | null
    hotelStars: number | null
    maxOccupancy: number | null
    basePrice: number | null
    agentPrice: number | null
    customerPrice: number | null
    profitMargin: number | null
    profitPercentage: number | null
  }

  export type HotelPricePoolMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    hotelId: string | null
    hotelName: string | null
    hotelAddress: string | null
    hotelCity: string | null
    hotelCountry: string | null
    hotelRating: number | null
    hotelStars: number | null
    hotelImage: string | null
    hotelAmenities: string | null
    roomType: string | null
    roomName: string | null
    roomDescription: string | null
    roomAmenities: string | null
    maxOccupancy: number | null
    bedType: string | null
    roomSize: string | null
    roomView: string | null
    basePrice: number | null
    agentPrice: number | null
    customerPrice: number | null
    profitMargin: number | null
    profitPercentage: number | null
    currency: string | null
    validFrom: Date | null
    validTo: Date | null
    cancellationPolicy: string | null
    breakfastIncluded: boolean | null
    freeCancellation: boolean | null
    source: string | null
    lastUpdated: Date | null
    updatedBy: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelPricePoolMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    hotelId: string | null
    hotelName: string | null
    hotelAddress: string | null
    hotelCity: string | null
    hotelCountry: string | null
    hotelRating: number | null
    hotelStars: number | null
    hotelImage: string | null
    hotelAmenities: string | null
    roomType: string | null
    roomName: string | null
    roomDescription: string | null
    roomAmenities: string | null
    maxOccupancy: number | null
    bedType: string | null
    roomSize: string | null
    roomView: string | null
    basePrice: number | null
    agentPrice: number | null
    customerPrice: number | null
    profitMargin: number | null
    profitPercentage: number | null
    currency: string | null
    validFrom: Date | null
    validTo: Date | null
    cancellationPolicy: string | null
    breakfastIncluded: boolean | null
    freeCancellation: boolean | null
    source: string | null
    lastUpdated: Date | null
    updatedBy: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelPricePoolCountAggregateOutputType = {
    id: number
    tenantId: number
    hotelId: number
    hotelName: number
    hotelAddress: number
    hotelCity: number
    hotelCountry: number
    hotelRating: number
    hotelStars: number
    hotelImage: number
    hotelAmenities: number
    roomType: number
    roomName: number
    roomDescription: number
    roomAmenities: number
    maxOccupancy: number
    bedType: number
    roomSize: number
    roomView: number
    basePrice: number
    agentPrice: number
    customerPrice: number
    profitMargin: number
    profitPercentage: number
    currency: number
    validFrom: number
    validTo: number
    cancellationPolicy: number
    breakfastIncluded: number
    freeCancellation: number
    source: number
    lastUpdated: number
    updatedBy: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelPricePoolAvgAggregateInputType = {
    hotelRating?: true
    hotelStars?: true
    maxOccupancy?: true
    basePrice?: true
    agentPrice?: true
    customerPrice?: true
    profitMargin?: true
    profitPercentage?: true
  }

  export type HotelPricePoolSumAggregateInputType = {
    hotelRating?: true
    hotelStars?: true
    maxOccupancy?: true
    basePrice?: true
    agentPrice?: true
    customerPrice?: true
    profitMargin?: true
    profitPercentage?: true
  }

  export type HotelPricePoolMinAggregateInputType = {
    id?: true
    tenantId?: true
    hotelId?: true
    hotelName?: true
    hotelAddress?: true
    hotelCity?: true
    hotelCountry?: true
    hotelRating?: true
    hotelStars?: true
    hotelImage?: true
    hotelAmenities?: true
    roomType?: true
    roomName?: true
    roomDescription?: true
    roomAmenities?: true
    maxOccupancy?: true
    bedType?: true
    roomSize?: true
    roomView?: true
    basePrice?: true
    agentPrice?: true
    customerPrice?: true
    profitMargin?: true
    profitPercentage?: true
    currency?: true
    validFrom?: true
    validTo?: true
    cancellationPolicy?: true
    breakfastIncluded?: true
    freeCancellation?: true
    source?: true
    lastUpdated?: true
    updatedBy?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelPricePoolMaxAggregateInputType = {
    id?: true
    tenantId?: true
    hotelId?: true
    hotelName?: true
    hotelAddress?: true
    hotelCity?: true
    hotelCountry?: true
    hotelRating?: true
    hotelStars?: true
    hotelImage?: true
    hotelAmenities?: true
    roomType?: true
    roomName?: true
    roomDescription?: true
    roomAmenities?: true
    maxOccupancy?: true
    bedType?: true
    roomSize?: true
    roomView?: true
    basePrice?: true
    agentPrice?: true
    customerPrice?: true
    profitMargin?: true
    profitPercentage?: true
    currency?: true
    validFrom?: true
    validTo?: true
    cancellationPolicy?: true
    breakfastIncluded?: true
    freeCancellation?: true
    source?: true
    lastUpdated?: true
    updatedBy?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelPricePoolCountAggregateInputType = {
    id?: true
    tenantId?: true
    hotelId?: true
    hotelName?: true
    hotelAddress?: true
    hotelCity?: true
    hotelCountry?: true
    hotelRating?: true
    hotelStars?: true
    hotelImage?: true
    hotelAmenities?: true
    roomType?: true
    roomName?: true
    roomDescription?: true
    roomAmenities?: true
    maxOccupancy?: true
    bedType?: true
    roomSize?: true
    roomView?: true
    basePrice?: true
    agentPrice?: true
    customerPrice?: true
    profitMargin?: true
    profitPercentage?: true
    currency?: true
    validFrom?: true
    validTo?: true
    cancellationPolicy?: true
    breakfastIncluded?: true
    freeCancellation?: true
    source?: true
    lastUpdated?: true
    updatedBy?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelPricePoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelPricePool to aggregate.
     */
    where?: HotelPricePoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelPricePools to fetch.
     */
    orderBy?: HotelPricePoolOrderByWithRelationInput | HotelPricePoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelPricePoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelPricePools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelPricePools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelPricePools
    **/
    _count?: true | HotelPricePoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelPricePoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelPricePoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelPricePoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelPricePoolMaxAggregateInputType
  }

  export type GetHotelPricePoolAggregateType<T extends HotelPricePoolAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelPricePool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelPricePool[P]>
      : GetScalarType<T[P], AggregateHotelPricePool[P]>
  }




  export type HotelPricePoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelPricePoolWhereInput
    orderBy?: HotelPricePoolOrderByWithAggregationInput | HotelPricePoolOrderByWithAggregationInput[]
    by: HotelPricePoolScalarFieldEnum[] | HotelPricePoolScalarFieldEnum
    having?: HotelPricePoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelPricePoolCountAggregateInputType | true
    _avg?: HotelPricePoolAvgAggregateInputType
    _sum?: HotelPricePoolSumAggregateInputType
    _min?: HotelPricePoolMinAggregateInputType
    _max?: HotelPricePoolMaxAggregateInputType
  }

  export type HotelPricePoolGroupByOutputType = {
    id: string
    tenantId: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    hotelCity: string
    hotelCountry: string
    hotelRating: number
    hotelStars: number
    hotelImage: string | null
    hotelAmenities: string
    roomType: string
    roomName: string
    roomDescription: string | null
    roomAmenities: string
    maxOccupancy: number
    bedType: string
    roomSize: string | null
    roomView: string | null
    basePrice: number
    agentPrice: number
    customerPrice: number
    profitMargin: number
    profitPercentage: number
    currency: string
    validFrom: Date
    validTo: Date
    cancellationPolicy: string | null
    breakfastIncluded: boolean
    freeCancellation: boolean
    source: string
    lastUpdated: Date
    updatedBy: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: HotelPricePoolCountAggregateOutputType | null
    _avg: HotelPricePoolAvgAggregateOutputType | null
    _sum: HotelPricePoolSumAggregateOutputType | null
    _min: HotelPricePoolMinAggregateOutputType | null
    _max: HotelPricePoolMaxAggregateOutputType | null
  }

  type GetHotelPricePoolGroupByPayload<T extends HotelPricePoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelPricePoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelPricePoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelPricePoolGroupByOutputType[P]>
            : GetScalarType<T[P], HotelPricePoolGroupByOutputType[P]>
        }
      >
    >


  export type HotelPricePoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    hotelId?: boolean
    hotelName?: boolean
    hotelAddress?: boolean
    hotelCity?: boolean
    hotelCountry?: boolean
    hotelRating?: boolean
    hotelStars?: boolean
    hotelImage?: boolean
    hotelAmenities?: boolean
    roomType?: boolean
    roomName?: boolean
    roomDescription?: boolean
    roomAmenities?: boolean
    maxOccupancy?: boolean
    bedType?: boolean
    roomSize?: boolean
    roomView?: boolean
    basePrice?: boolean
    agentPrice?: boolean
    customerPrice?: boolean
    profitMargin?: boolean
    profitPercentage?: boolean
    currency?: boolean
    validFrom?: boolean
    validTo?: boolean
    cancellationPolicy?: boolean
    breakfastIncluded?: boolean
    freeCancellation?: boolean
    source?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelPricePool"]>

  export type HotelPricePoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    hotelId?: boolean
    hotelName?: boolean
    hotelAddress?: boolean
    hotelCity?: boolean
    hotelCountry?: boolean
    hotelRating?: boolean
    hotelStars?: boolean
    hotelImage?: boolean
    hotelAmenities?: boolean
    roomType?: boolean
    roomName?: boolean
    roomDescription?: boolean
    roomAmenities?: boolean
    maxOccupancy?: boolean
    bedType?: boolean
    roomSize?: boolean
    roomView?: boolean
    basePrice?: boolean
    agentPrice?: boolean
    customerPrice?: boolean
    profitMargin?: boolean
    profitPercentage?: boolean
    currency?: boolean
    validFrom?: boolean
    validTo?: boolean
    cancellationPolicy?: boolean
    breakfastIncluded?: boolean
    freeCancellation?: boolean
    source?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelPricePool"]>

  export type HotelPricePoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    hotelId?: boolean
    hotelName?: boolean
    hotelAddress?: boolean
    hotelCity?: boolean
    hotelCountry?: boolean
    hotelRating?: boolean
    hotelStars?: boolean
    hotelImage?: boolean
    hotelAmenities?: boolean
    roomType?: boolean
    roomName?: boolean
    roomDescription?: boolean
    roomAmenities?: boolean
    maxOccupancy?: boolean
    bedType?: boolean
    roomSize?: boolean
    roomView?: boolean
    basePrice?: boolean
    agentPrice?: boolean
    customerPrice?: boolean
    profitMargin?: boolean
    profitPercentage?: boolean
    currency?: boolean
    validFrom?: boolean
    validTo?: boolean
    cancellationPolicy?: boolean
    breakfastIncluded?: boolean
    freeCancellation?: boolean
    source?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelPricePool"]>

  export type HotelPricePoolSelectScalar = {
    id?: boolean
    tenantId?: boolean
    hotelId?: boolean
    hotelName?: boolean
    hotelAddress?: boolean
    hotelCity?: boolean
    hotelCountry?: boolean
    hotelRating?: boolean
    hotelStars?: boolean
    hotelImage?: boolean
    hotelAmenities?: boolean
    roomType?: boolean
    roomName?: boolean
    roomDescription?: boolean
    roomAmenities?: boolean
    maxOccupancy?: boolean
    bedType?: boolean
    roomSize?: boolean
    roomView?: boolean
    basePrice?: boolean
    agentPrice?: boolean
    customerPrice?: boolean
    profitMargin?: boolean
    profitPercentage?: boolean
    currency?: boolean
    validFrom?: boolean
    validTo?: boolean
    cancellationPolicy?: boolean
    breakfastIncluded?: boolean
    freeCancellation?: boolean
    source?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelPricePoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "hotelId" | "hotelName" | "hotelAddress" | "hotelCity" | "hotelCountry" | "hotelRating" | "hotelStars" | "hotelImage" | "hotelAmenities" | "roomType" | "roomName" | "roomDescription" | "roomAmenities" | "maxOccupancy" | "bedType" | "roomSize" | "roomView" | "basePrice" | "agentPrice" | "customerPrice" | "profitMargin" | "profitPercentage" | "currency" | "validFrom" | "validTo" | "cancellationPolicy" | "breakfastIncluded" | "freeCancellation" | "source" | "lastUpdated" | "updatedBy" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelPricePool"]>
  export type HotelPricePoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type HotelPricePoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type HotelPricePoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $HotelPricePoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelPricePool"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      hotelId: string
      hotelName: string
      hotelAddress: string
      hotelCity: string
      hotelCountry: string
      hotelRating: number
      hotelStars: number
      hotelImage: string | null
      hotelAmenities: string
      roomType: string
      roomName: string
      roomDescription: string | null
      roomAmenities: string
      maxOccupancy: number
      bedType: string
      roomSize: string | null
      roomView: string | null
      basePrice: number
      agentPrice: number
      customerPrice: number
      profitMargin: number
      profitPercentage: number
      currency: string
      validFrom: Date
      validTo: Date
      cancellationPolicy: string | null
      breakfastIncluded: boolean
      freeCancellation: boolean
      source: string
      lastUpdated: Date
      updatedBy: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelPricePool"]>
    composites: {}
  }

  type HotelPricePoolGetPayload<S extends boolean | null | undefined | HotelPricePoolDefaultArgs> = $Result.GetResult<Prisma.$HotelPricePoolPayload, S>

  type HotelPricePoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelPricePoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelPricePoolCountAggregateInputType | true
    }

  export interface HotelPricePoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelPricePool'], meta: { name: 'HotelPricePool' } }
    /**
     * Find zero or one HotelPricePool that matches the filter.
     * @param {HotelPricePoolFindUniqueArgs} args - Arguments to find a HotelPricePool
     * @example
     * // Get one HotelPricePool
     * const hotelPricePool = await prisma.hotelPricePool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelPricePoolFindUniqueArgs>(args: SelectSubset<T, HotelPricePoolFindUniqueArgs<ExtArgs>>): Prisma__HotelPricePoolClient<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelPricePool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelPricePoolFindUniqueOrThrowArgs} args - Arguments to find a HotelPricePool
     * @example
     * // Get one HotelPricePool
     * const hotelPricePool = await prisma.hotelPricePool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelPricePoolFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelPricePoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelPricePoolClient<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelPricePool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPricePoolFindFirstArgs} args - Arguments to find a HotelPricePool
     * @example
     * // Get one HotelPricePool
     * const hotelPricePool = await prisma.hotelPricePool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelPricePoolFindFirstArgs>(args?: SelectSubset<T, HotelPricePoolFindFirstArgs<ExtArgs>>): Prisma__HotelPricePoolClient<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelPricePool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPricePoolFindFirstOrThrowArgs} args - Arguments to find a HotelPricePool
     * @example
     * // Get one HotelPricePool
     * const hotelPricePool = await prisma.hotelPricePool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelPricePoolFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelPricePoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelPricePoolClient<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelPricePools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPricePoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelPricePools
     * const hotelPricePools = await prisma.hotelPricePool.findMany()
     * 
     * // Get first 10 HotelPricePools
     * const hotelPricePools = await prisma.hotelPricePool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelPricePoolWithIdOnly = await prisma.hotelPricePool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelPricePoolFindManyArgs>(args?: SelectSubset<T, HotelPricePoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelPricePool.
     * @param {HotelPricePoolCreateArgs} args - Arguments to create a HotelPricePool.
     * @example
     * // Create one HotelPricePool
     * const HotelPricePool = await prisma.hotelPricePool.create({
     *   data: {
     *     // ... data to create a HotelPricePool
     *   }
     * })
     * 
     */
    create<T extends HotelPricePoolCreateArgs>(args: SelectSubset<T, HotelPricePoolCreateArgs<ExtArgs>>): Prisma__HotelPricePoolClient<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelPricePools.
     * @param {HotelPricePoolCreateManyArgs} args - Arguments to create many HotelPricePools.
     * @example
     * // Create many HotelPricePools
     * const hotelPricePool = await prisma.hotelPricePool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelPricePoolCreateManyArgs>(args?: SelectSubset<T, HotelPricePoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelPricePools and returns the data saved in the database.
     * @param {HotelPricePoolCreateManyAndReturnArgs} args - Arguments to create many HotelPricePools.
     * @example
     * // Create many HotelPricePools
     * const hotelPricePool = await prisma.hotelPricePool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelPricePools and only return the `id`
     * const hotelPricePoolWithIdOnly = await prisma.hotelPricePool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelPricePoolCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelPricePoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelPricePool.
     * @param {HotelPricePoolDeleteArgs} args - Arguments to delete one HotelPricePool.
     * @example
     * // Delete one HotelPricePool
     * const HotelPricePool = await prisma.hotelPricePool.delete({
     *   where: {
     *     // ... filter to delete one HotelPricePool
     *   }
     * })
     * 
     */
    delete<T extends HotelPricePoolDeleteArgs>(args: SelectSubset<T, HotelPricePoolDeleteArgs<ExtArgs>>): Prisma__HotelPricePoolClient<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelPricePool.
     * @param {HotelPricePoolUpdateArgs} args - Arguments to update one HotelPricePool.
     * @example
     * // Update one HotelPricePool
     * const hotelPricePool = await prisma.hotelPricePool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelPricePoolUpdateArgs>(args: SelectSubset<T, HotelPricePoolUpdateArgs<ExtArgs>>): Prisma__HotelPricePoolClient<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelPricePools.
     * @param {HotelPricePoolDeleteManyArgs} args - Arguments to filter HotelPricePools to delete.
     * @example
     * // Delete a few HotelPricePools
     * const { count } = await prisma.hotelPricePool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelPricePoolDeleteManyArgs>(args?: SelectSubset<T, HotelPricePoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelPricePools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPricePoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelPricePools
     * const hotelPricePool = await prisma.hotelPricePool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelPricePoolUpdateManyArgs>(args: SelectSubset<T, HotelPricePoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelPricePools and returns the data updated in the database.
     * @param {HotelPricePoolUpdateManyAndReturnArgs} args - Arguments to update many HotelPricePools.
     * @example
     * // Update many HotelPricePools
     * const hotelPricePool = await prisma.hotelPricePool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelPricePools and only return the `id`
     * const hotelPricePoolWithIdOnly = await prisma.hotelPricePool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelPricePoolUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelPricePoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelPricePool.
     * @param {HotelPricePoolUpsertArgs} args - Arguments to update or create a HotelPricePool.
     * @example
     * // Update or create a HotelPricePool
     * const hotelPricePool = await prisma.hotelPricePool.upsert({
     *   create: {
     *     // ... data to create a HotelPricePool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelPricePool we want to update
     *   }
     * })
     */
    upsert<T extends HotelPricePoolUpsertArgs>(args: SelectSubset<T, HotelPricePoolUpsertArgs<ExtArgs>>): Prisma__HotelPricePoolClient<$Result.GetResult<Prisma.$HotelPricePoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelPricePools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPricePoolCountArgs} args - Arguments to filter HotelPricePools to count.
     * @example
     * // Count the number of HotelPricePools
     * const count = await prisma.hotelPricePool.count({
     *   where: {
     *     // ... the filter for the HotelPricePools we want to count
     *   }
     * })
    **/
    count<T extends HotelPricePoolCountArgs>(
      args?: Subset<T, HotelPricePoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelPricePoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelPricePool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPricePoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelPricePoolAggregateArgs>(args: Subset<T, HotelPricePoolAggregateArgs>): Prisma.PrismaPromise<GetHotelPricePoolAggregateType<T>>

    /**
     * Group by HotelPricePool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPricePoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelPricePoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelPricePoolGroupByArgs['orderBy'] }
        : { orderBy?: HotelPricePoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelPricePoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelPricePoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelPricePool model
   */
  readonly fields: HotelPricePoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelPricePool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelPricePoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelPricePool model
   */
  interface HotelPricePoolFieldRefs {
    readonly id: FieldRef<"HotelPricePool", 'String'>
    readonly tenantId: FieldRef<"HotelPricePool", 'String'>
    readonly hotelId: FieldRef<"HotelPricePool", 'String'>
    readonly hotelName: FieldRef<"HotelPricePool", 'String'>
    readonly hotelAddress: FieldRef<"HotelPricePool", 'String'>
    readonly hotelCity: FieldRef<"HotelPricePool", 'String'>
    readonly hotelCountry: FieldRef<"HotelPricePool", 'String'>
    readonly hotelRating: FieldRef<"HotelPricePool", 'Float'>
    readonly hotelStars: FieldRef<"HotelPricePool", 'Int'>
    readonly hotelImage: FieldRef<"HotelPricePool", 'String'>
    readonly hotelAmenities: FieldRef<"HotelPricePool", 'String'>
    readonly roomType: FieldRef<"HotelPricePool", 'String'>
    readonly roomName: FieldRef<"HotelPricePool", 'String'>
    readonly roomDescription: FieldRef<"HotelPricePool", 'String'>
    readonly roomAmenities: FieldRef<"HotelPricePool", 'String'>
    readonly maxOccupancy: FieldRef<"HotelPricePool", 'Int'>
    readonly bedType: FieldRef<"HotelPricePool", 'String'>
    readonly roomSize: FieldRef<"HotelPricePool", 'String'>
    readonly roomView: FieldRef<"HotelPricePool", 'String'>
    readonly basePrice: FieldRef<"HotelPricePool", 'Float'>
    readonly agentPrice: FieldRef<"HotelPricePool", 'Float'>
    readonly customerPrice: FieldRef<"HotelPricePool", 'Float'>
    readonly profitMargin: FieldRef<"HotelPricePool", 'Float'>
    readonly profitPercentage: FieldRef<"HotelPricePool", 'Float'>
    readonly currency: FieldRef<"HotelPricePool", 'String'>
    readonly validFrom: FieldRef<"HotelPricePool", 'DateTime'>
    readonly validTo: FieldRef<"HotelPricePool", 'DateTime'>
    readonly cancellationPolicy: FieldRef<"HotelPricePool", 'String'>
    readonly breakfastIncluded: FieldRef<"HotelPricePool", 'Boolean'>
    readonly freeCancellation: FieldRef<"HotelPricePool", 'Boolean'>
    readonly source: FieldRef<"HotelPricePool", 'String'>
    readonly lastUpdated: FieldRef<"HotelPricePool", 'DateTime'>
    readonly updatedBy: FieldRef<"HotelPricePool", 'String'>
    readonly isActive: FieldRef<"HotelPricePool", 'Boolean'>
    readonly createdAt: FieldRef<"HotelPricePool", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelPricePool", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelPricePool findUnique
   */
  export type HotelPricePoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
    /**
     * Filter, which HotelPricePool to fetch.
     */
    where: HotelPricePoolWhereUniqueInput
  }

  /**
   * HotelPricePool findUniqueOrThrow
   */
  export type HotelPricePoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
    /**
     * Filter, which HotelPricePool to fetch.
     */
    where: HotelPricePoolWhereUniqueInput
  }

  /**
   * HotelPricePool findFirst
   */
  export type HotelPricePoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
    /**
     * Filter, which HotelPricePool to fetch.
     */
    where?: HotelPricePoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelPricePools to fetch.
     */
    orderBy?: HotelPricePoolOrderByWithRelationInput | HotelPricePoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelPricePools.
     */
    cursor?: HotelPricePoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelPricePools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelPricePools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelPricePools.
     */
    distinct?: HotelPricePoolScalarFieldEnum | HotelPricePoolScalarFieldEnum[]
  }

  /**
   * HotelPricePool findFirstOrThrow
   */
  export type HotelPricePoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
    /**
     * Filter, which HotelPricePool to fetch.
     */
    where?: HotelPricePoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelPricePools to fetch.
     */
    orderBy?: HotelPricePoolOrderByWithRelationInput | HotelPricePoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelPricePools.
     */
    cursor?: HotelPricePoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelPricePools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelPricePools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelPricePools.
     */
    distinct?: HotelPricePoolScalarFieldEnum | HotelPricePoolScalarFieldEnum[]
  }

  /**
   * HotelPricePool findMany
   */
  export type HotelPricePoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
    /**
     * Filter, which HotelPricePools to fetch.
     */
    where?: HotelPricePoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelPricePools to fetch.
     */
    orderBy?: HotelPricePoolOrderByWithRelationInput | HotelPricePoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelPricePools.
     */
    cursor?: HotelPricePoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelPricePools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelPricePools.
     */
    skip?: number
    distinct?: HotelPricePoolScalarFieldEnum | HotelPricePoolScalarFieldEnum[]
  }

  /**
   * HotelPricePool create
   */
  export type HotelPricePoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelPricePool.
     */
    data: XOR<HotelPricePoolCreateInput, HotelPricePoolUncheckedCreateInput>
  }

  /**
   * HotelPricePool createMany
   */
  export type HotelPricePoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelPricePools.
     */
    data: HotelPricePoolCreateManyInput | HotelPricePoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelPricePool createManyAndReturn
   */
  export type HotelPricePoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * The data used to create many HotelPricePools.
     */
    data: HotelPricePoolCreateManyInput | HotelPricePoolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelPricePool update
   */
  export type HotelPricePoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelPricePool.
     */
    data: XOR<HotelPricePoolUpdateInput, HotelPricePoolUncheckedUpdateInput>
    /**
     * Choose, which HotelPricePool to update.
     */
    where: HotelPricePoolWhereUniqueInput
  }

  /**
   * HotelPricePool updateMany
   */
  export type HotelPricePoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelPricePools.
     */
    data: XOR<HotelPricePoolUpdateManyMutationInput, HotelPricePoolUncheckedUpdateManyInput>
    /**
     * Filter which HotelPricePools to update
     */
    where?: HotelPricePoolWhereInput
    /**
     * Limit how many HotelPricePools to update.
     */
    limit?: number
  }

  /**
   * HotelPricePool updateManyAndReturn
   */
  export type HotelPricePoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * The data used to update HotelPricePools.
     */
    data: XOR<HotelPricePoolUpdateManyMutationInput, HotelPricePoolUncheckedUpdateManyInput>
    /**
     * Filter which HotelPricePools to update
     */
    where?: HotelPricePoolWhereInput
    /**
     * Limit how many HotelPricePools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelPricePool upsert
   */
  export type HotelPricePoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelPricePool to update in case it exists.
     */
    where: HotelPricePoolWhereUniqueInput
    /**
     * In case the HotelPricePool found by the `where` argument doesn't exist, create a new HotelPricePool with this data.
     */
    create: XOR<HotelPricePoolCreateInput, HotelPricePoolUncheckedCreateInput>
    /**
     * In case the HotelPricePool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelPricePoolUpdateInput, HotelPricePoolUncheckedUpdateInput>
  }

  /**
   * HotelPricePool delete
   */
  export type HotelPricePoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
    /**
     * Filter which HotelPricePool to delete.
     */
    where: HotelPricePoolWhereUniqueInput
  }

  /**
   * HotelPricePool deleteMany
   */
  export type HotelPricePoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelPricePools to delete
     */
    where?: HotelPricePoolWhereInput
    /**
     * Limit how many HotelPricePools to delete.
     */
    limit?: number
  }

  /**
   * HotelPricePool without action
   */
  export type HotelPricePoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPricePool
     */
    select?: HotelPricePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPricePool
     */
    omit?: HotelPricePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPricePoolInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    capacity: number | null
  }

  export type VehicleSumAggregateOutputType = {
    capacity: number | null
  }

  export type VehicleMinAggregateOutputType = {
    id: string | null
    type: string | null
    capacity: number | null
    licensePlate: string | null
    driverName: string | null
    driverPhone: string | null
    isAvailable: boolean | null
    lastMaintenance: Date | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: string | null
    type: string | null
    capacity: number | null
    licensePlate: string | null
    driverName: string | null
    driverPhone: string | null
    isAvailable: boolean | null
    lastMaintenance: Date | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    type: number
    capacity: number
    licensePlate: number
    driverName: number
    driverPhone: number
    isAvailable: number
    lastMaintenance: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    capacity?: true
  }

  export type VehicleSumAggregateInputType = {
    capacity?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    type?: true
    capacity?: true
    licensePlate?: true
    driverName?: true
    driverPhone?: true
    isAvailable?: true
    lastMaintenance?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    type?: true
    capacity?: true
    licensePlate?: true
    driverName?: true
    driverPhone?: true
    isAvailable?: true
    lastMaintenance?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    type?: true
    capacity?: true
    licensePlate?: true
    driverName?: true
    driverPhone?: true
    isAvailable?: true
    lastMaintenance?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: string
    type: string
    capacity: number
    licensePlate: string
    driverName: string | null
    driverPhone: string | null
    isAvailable: boolean
    lastMaintenance: Date | null
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    capacity?: boolean
    licensePlate?: boolean
    driverName?: boolean
    driverPhone?: boolean
    isAvailable?: boolean
    lastMaintenance?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    capacity?: boolean
    licensePlate?: boolean
    driverName?: boolean
    driverPhone?: boolean
    isAvailable?: boolean
    lastMaintenance?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    capacity?: boolean
    licensePlate?: boolean
    driverName?: boolean
    driverPhone?: boolean
    isAvailable?: boolean
    lastMaintenance?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    type?: boolean
    capacity?: boolean
    licensePlate?: boolean
    driverName?: boolean
    driverPhone?: boolean
    isAvailable?: boolean
    lastMaintenance?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "capacity" | "licensePlate" | "driverName" | "driverPhone" | "isAvailable" | "lastMaintenance" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle"]>
  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      capacity: number
      licensePlate: string
      driverName: string | null
      driverPhone: string | null
      isAvailable: boolean
      lastMaintenance: Date | null
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {VehicleUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'String'>
    readonly type: FieldRef<"Vehicle", 'String'>
    readonly capacity: FieldRef<"Vehicle", 'Int'>
    readonly licensePlate: FieldRef<"Vehicle", 'String'>
    readonly driverName: FieldRef<"Vehicle", 'String'>
    readonly driverPhone: FieldRef<"Vehicle", 'String'>
    readonly isAvailable: FieldRef<"Vehicle", 'Boolean'>
    readonly lastMaintenance: FieldRef<"Vehicle", 'DateTime'>
    readonly tenantId: FieldRef<"Vehicle", 'String'>
    readonly createdAt: FieldRef<"Vehicle", 'DateTime'>
    readonly updatedAt: FieldRef<"Vehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle updateManyAndReturn
   */
  export type VehicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to delete.
     */
    limit?: number
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model TourBooking
   */

  export type AggregateTourBooking = {
    _count: TourBookingCountAggregateOutputType | null
    _avg: TourBookingAvgAggregateOutputType | null
    _sum: TourBookingSumAggregateOutputType | null
    _min: TourBookingMinAggregateOutputType | null
    _max: TourBookingMaxAggregateOutputType | null
  }

  export type TourBookingAvgAggregateOutputType = {
    groupSize: number | null
    price: number | null
    driverFee: number | null
    tourDuration: number | null
  }

  export type TourBookingSumAggregateOutputType = {
    groupSize: number | null
    price: number | null
    driverFee: number | null
    tourDuration: number | null
  }

  export type TourBookingMinAggregateOutputType = {
    id: string | null
    voucherNumber: string | null
    routeName: string | null
    vehicleType: string | null
    groupSize: number | null
    price: number | null
    currency: string | null
    pickupLocation: string | null
    tourDate: Date | null
    tourTime: string | null
    passengerNames: string | null
    notes: string | null
    status: string | null
    tenantId: string | null
    userId: string | null
    driverId: string | null
    driverFee: number | null
    createdAt: Date | null
    updatedAt: Date | null
    tourDuration: number | null
  }

  export type TourBookingMaxAggregateOutputType = {
    id: string | null
    voucherNumber: string | null
    routeName: string | null
    vehicleType: string | null
    groupSize: number | null
    price: number | null
    currency: string | null
    pickupLocation: string | null
    tourDate: Date | null
    tourTime: string | null
    passengerNames: string | null
    notes: string | null
    status: string | null
    tenantId: string | null
    userId: string | null
    driverId: string | null
    driverFee: number | null
    createdAt: Date | null
    updatedAt: Date | null
    tourDuration: number | null
  }

  export type TourBookingCountAggregateOutputType = {
    id: number
    voucherNumber: number
    routeName: number
    vehicleType: number
    groupSize: number
    price: number
    currency: number
    pickupLocation: number
    tourDate: number
    tourTime: number
    passengerNames: number
    notes: number
    status: number
    tenantId: number
    userId: number
    driverId: number
    driverFee: number
    createdAt: number
    updatedAt: number
    tourDuration: number
    _all: number
  }


  export type TourBookingAvgAggregateInputType = {
    groupSize?: true
    price?: true
    driverFee?: true
    tourDuration?: true
  }

  export type TourBookingSumAggregateInputType = {
    groupSize?: true
    price?: true
    driverFee?: true
    tourDuration?: true
  }

  export type TourBookingMinAggregateInputType = {
    id?: true
    voucherNumber?: true
    routeName?: true
    vehicleType?: true
    groupSize?: true
    price?: true
    currency?: true
    pickupLocation?: true
    tourDate?: true
    tourTime?: true
    passengerNames?: true
    notes?: true
    status?: true
    tenantId?: true
    userId?: true
    driverId?: true
    driverFee?: true
    createdAt?: true
    updatedAt?: true
    tourDuration?: true
  }

  export type TourBookingMaxAggregateInputType = {
    id?: true
    voucherNumber?: true
    routeName?: true
    vehicleType?: true
    groupSize?: true
    price?: true
    currency?: true
    pickupLocation?: true
    tourDate?: true
    tourTime?: true
    passengerNames?: true
    notes?: true
    status?: true
    tenantId?: true
    userId?: true
    driverId?: true
    driverFee?: true
    createdAt?: true
    updatedAt?: true
    tourDuration?: true
  }

  export type TourBookingCountAggregateInputType = {
    id?: true
    voucherNumber?: true
    routeName?: true
    vehicleType?: true
    groupSize?: true
    price?: true
    currency?: true
    pickupLocation?: true
    tourDate?: true
    tourTime?: true
    passengerNames?: true
    notes?: true
    status?: true
    tenantId?: true
    userId?: true
    driverId?: true
    driverFee?: true
    createdAt?: true
    updatedAt?: true
    tourDuration?: true
    _all?: true
  }

  export type TourBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourBooking to aggregate.
     */
    where?: TourBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourBookings to fetch.
     */
    orderBy?: TourBookingOrderByWithRelationInput | TourBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TourBookings
    **/
    _count?: true | TourBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourBookingMaxAggregateInputType
  }

  export type GetTourBookingAggregateType<T extends TourBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateTourBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourBooking[P]>
      : GetScalarType<T[P], AggregateTourBooking[P]>
  }




  export type TourBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourBookingWhereInput
    orderBy?: TourBookingOrderByWithAggregationInput | TourBookingOrderByWithAggregationInput[]
    by: TourBookingScalarFieldEnum[] | TourBookingScalarFieldEnum
    having?: TourBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourBookingCountAggregateInputType | true
    _avg?: TourBookingAvgAggregateInputType
    _sum?: TourBookingSumAggregateInputType
    _min?: TourBookingMinAggregateInputType
    _max?: TourBookingMaxAggregateInputType
  }

  export type TourBookingGroupByOutputType = {
    id: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency: string
    pickupLocation: string
    tourDate: Date
    tourTime: string | null
    passengerNames: string
    notes: string | null
    status: string
    tenantId: string
    userId: string | null
    driverId: string | null
    driverFee: number | null
    createdAt: Date
    updatedAt: Date
    tourDuration: number
    _count: TourBookingCountAggregateOutputType | null
    _avg: TourBookingAvgAggregateOutputType | null
    _sum: TourBookingSumAggregateOutputType | null
    _min: TourBookingMinAggregateOutputType | null
    _max: TourBookingMaxAggregateOutputType | null
  }

  type GetTourBookingGroupByPayload<T extends TourBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourBookingGroupByOutputType[P]>
            : GetScalarType<T[P], TourBookingGroupByOutputType[P]>
        }
      >
    >


  export type TourBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherNumber?: boolean
    routeName?: boolean
    vehicleType?: boolean
    groupSize?: boolean
    price?: boolean
    currency?: boolean
    pickupLocation?: boolean
    tourDate?: boolean
    tourTime?: boolean
    passengerNames?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    userId?: boolean
    driverId?: boolean
    driverFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tourDuration?: boolean
    driver?: boolean | TourBooking$driverArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TourBooking$UserArgs<ExtArgs>
  }, ExtArgs["result"]["tourBooking"]>

  export type TourBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherNumber?: boolean
    routeName?: boolean
    vehicleType?: boolean
    groupSize?: boolean
    price?: boolean
    currency?: boolean
    pickupLocation?: boolean
    tourDate?: boolean
    tourTime?: boolean
    passengerNames?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    userId?: boolean
    driverId?: boolean
    driverFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tourDuration?: boolean
    driver?: boolean | TourBooking$driverArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TourBooking$UserArgs<ExtArgs>
  }, ExtArgs["result"]["tourBooking"]>

  export type TourBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherNumber?: boolean
    routeName?: boolean
    vehicleType?: boolean
    groupSize?: boolean
    price?: boolean
    currency?: boolean
    pickupLocation?: boolean
    tourDate?: boolean
    tourTime?: boolean
    passengerNames?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    userId?: boolean
    driverId?: boolean
    driverFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tourDuration?: boolean
    driver?: boolean | TourBooking$driverArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TourBooking$UserArgs<ExtArgs>
  }, ExtArgs["result"]["tourBooking"]>

  export type TourBookingSelectScalar = {
    id?: boolean
    voucherNumber?: boolean
    routeName?: boolean
    vehicleType?: boolean
    groupSize?: boolean
    price?: boolean
    currency?: boolean
    pickupLocation?: boolean
    tourDate?: boolean
    tourTime?: boolean
    passengerNames?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    userId?: boolean
    driverId?: boolean
    driverFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tourDuration?: boolean
  }

  export type TourBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voucherNumber" | "routeName" | "vehicleType" | "groupSize" | "price" | "currency" | "pickupLocation" | "tourDate" | "tourTime" | "passengerNames" | "notes" | "status" | "tenantId" | "userId" | "driverId" | "driverFee" | "createdAt" | "updatedAt" | "tourDuration", ExtArgs["result"]["tourBooking"]>
  export type TourBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | TourBooking$driverArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TourBooking$UserArgs<ExtArgs>
  }
  export type TourBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | TourBooking$driverArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TourBooking$UserArgs<ExtArgs>
  }
  export type TourBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | TourBooking$driverArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TourBooking$UserArgs<ExtArgs>
  }

  export type $TourBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TourBooking"
    objects: {
      driver: Prisma.$DriverPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      voucherNumber: string
      routeName: string
      vehicleType: string
      groupSize: number
      price: number
      currency: string
      pickupLocation: string
      tourDate: Date
      tourTime: string | null
      passengerNames: string
      notes: string | null
      status: string
      tenantId: string
      userId: string | null
      driverId: string | null
      driverFee: number | null
      createdAt: Date
      updatedAt: Date
      tourDuration: number
    }, ExtArgs["result"]["tourBooking"]>
    composites: {}
  }

  type TourBookingGetPayload<S extends boolean | null | undefined | TourBookingDefaultArgs> = $Result.GetResult<Prisma.$TourBookingPayload, S>

  type TourBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TourBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TourBookingCountAggregateInputType | true
    }

  export interface TourBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TourBooking'], meta: { name: 'TourBooking' } }
    /**
     * Find zero or one TourBooking that matches the filter.
     * @param {TourBookingFindUniqueArgs} args - Arguments to find a TourBooking
     * @example
     * // Get one TourBooking
     * const tourBooking = await prisma.tourBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourBookingFindUniqueArgs>(args: SelectSubset<T, TourBookingFindUniqueArgs<ExtArgs>>): Prisma__TourBookingClient<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TourBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TourBookingFindUniqueOrThrowArgs} args - Arguments to find a TourBooking
     * @example
     * // Get one TourBooking
     * const tourBooking = await prisma.tourBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, TourBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourBookingClient<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TourBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBookingFindFirstArgs} args - Arguments to find a TourBooking
     * @example
     * // Get one TourBooking
     * const tourBooking = await prisma.tourBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourBookingFindFirstArgs>(args?: SelectSubset<T, TourBookingFindFirstArgs<ExtArgs>>): Prisma__TourBookingClient<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TourBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBookingFindFirstOrThrowArgs} args - Arguments to find a TourBooking
     * @example
     * // Get one TourBooking
     * const tourBooking = await prisma.tourBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, TourBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourBookingClient<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TourBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TourBookings
     * const tourBookings = await prisma.tourBooking.findMany()
     * 
     * // Get first 10 TourBookings
     * const tourBookings = await prisma.tourBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourBookingWithIdOnly = await prisma.tourBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourBookingFindManyArgs>(args?: SelectSubset<T, TourBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TourBooking.
     * @param {TourBookingCreateArgs} args - Arguments to create a TourBooking.
     * @example
     * // Create one TourBooking
     * const TourBooking = await prisma.tourBooking.create({
     *   data: {
     *     // ... data to create a TourBooking
     *   }
     * })
     * 
     */
    create<T extends TourBookingCreateArgs>(args: SelectSubset<T, TourBookingCreateArgs<ExtArgs>>): Prisma__TourBookingClient<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TourBookings.
     * @param {TourBookingCreateManyArgs} args - Arguments to create many TourBookings.
     * @example
     * // Create many TourBookings
     * const tourBooking = await prisma.tourBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourBookingCreateManyArgs>(args?: SelectSubset<T, TourBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TourBookings and returns the data saved in the database.
     * @param {TourBookingCreateManyAndReturnArgs} args - Arguments to create many TourBookings.
     * @example
     * // Create many TourBookings
     * const tourBooking = await prisma.tourBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TourBookings and only return the `id`
     * const tourBookingWithIdOnly = await prisma.tourBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, TourBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TourBooking.
     * @param {TourBookingDeleteArgs} args - Arguments to delete one TourBooking.
     * @example
     * // Delete one TourBooking
     * const TourBooking = await prisma.tourBooking.delete({
     *   where: {
     *     // ... filter to delete one TourBooking
     *   }
     * })
     * 
     */
    delete<T extends TourBookingDeleteArgs>(args: SelectSubset<T, TourBookingDeleteArgs<ExtArgs>>): Prisma__TourBookingClient<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TourBooking.
     * @param {TourBookingUpdateArgs} args - Arguments to update one TourBooking.
     * @example
     * // Update one TourBooking
     * const tourBooking = await prisma.tourBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourBookingUpdateArgs>(args: SelectSubset<T, TourBookingUpdateArgs<ExtArgs>>): Prisma__TourBookingClient<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TourBookings.
     * @param {TourBookingDeleteManyArgs} args - Arguments to filter TourBookings to delete.
     * @example
     * // Delete a few TourBookings
     * const { count } = await prisma.tourBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourBookingDeleteManyArgs>(args?: SelectSubset<T, TourBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TourBookings
     * const tourBooking = await prisma.tourBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourBookingUpdateManyArgs>(args: SelectSubset<T, TourBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourBookings and returns the data updated in the database.
     * @param {TourBookingUpdateManyAndReturnArgs} args - Arguments to update many TourBookings.
     * @example
     * // Update many TourBookings
     * const tourBooking = await prisma.tourBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TourBookings and only return the `id`
     * const tourBookingWithIdOnly = await prisma.tourBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TourBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, TourBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TourBooking.
     * @param {TourBookingUpsertArgs} args - Arguments to update or create a TourBooking.
     * @example
     * // Update or create a TourBooking
     * const tourBooking = await prisma.tourBooking.upsert({
     *   create: {
     *     // ... data to create a TourBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TourBooking we want to update
     *   }
     * })
     */
    upsert<T extends TourBookingUpsertArgs>(args: SelectSubset<T, TourBookingUpsertArgs<ExtArgs>>): Prisma__TourBookingClient<$Result.GetResult<Prisma.$TourBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TourBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBookingCountArgs} args - Arguments to filter TourBookings to count.
     * @example
     * // Count the number of TourBookings
     * const count = await prisma.tourBooking.count({
     *   where: {
     *     // ... the filter for the TourBookings we want to count
     *   }
     * })
    **/
    count<T extends TourBookingCountArgs>(
      args?: Subset<T, TourBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TourBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourBookingAggregateArgs>(args: Subset<T, TourBookingAggregateArgs>): Prisma.PrismaPromise<GetTourBookingAggregateType<T>>

    /**
     * Group by TourBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourBookingGroupByArgs['orderBy'] }
        : { orderBy?: TourBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TourBooking model
   */
  readonly fields: TourBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TourBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends TourBooking$driverArgs<ExtArgs> = {}>(args?: Subset<T, TourBooking$driverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends TourBooking$UserArgs<ExtArgs> = {}>(args?: Subset<T, TourBooking$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TourBooking model
   */
  interface TourBookingFieldRefs {
    readonly id: FieldRef<"TourBooking", 'String'>
    readonly voucherNumber: FieldRef<"TourBooking", 'String'>
    readonly routeName: FieldRef<"TourBooking", 'String'>
    readonly vehicleType: FieldRef<"TourBooking", 'String'>
    readonly groupSize: FieldRef<"TourBooking", 'Int'>
    readonly price: FieldRef<"TourBooking", 'Float'>
    readonly currency: FieldRef<"TourBooking", 'String'>
    readonly pickupLocation: FieldRef<"TourBooking", 'String'>
    readonly tourDate: FieldRef<"TourBooking", 'DateTime'>
    readonly tourTime: FieldRef<"TourBooking", 'String'>
    readonly passengerNames: FieldRef<"TourBooking", 'String'>
    readonly notes: FieldRef<"TourBooking", 'String'>
    readonly status: FieldRef<"TourBooking", 'String'>
    readonly tenantId: FieldRef<"TourBooking", 'String'>
    readonly userId: FieldRef<"TourBooking", 'String'>
    readonly driverId: FieldRef<"TourBooking", 'String'>
    readonly driverFee: FieldRef<"TourBooking", 'Float'>
    readonly createdAt: FieldRef<"TourBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"TourBooking", 'DateTime'>
    readonly tourDuration: FieldRef<"TourBooking", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TourBooking findUnique
   */
  export type TourBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    /**
     * Filter, which TourBooking to fetch.
     */
    where: TourBookingWhereUniqueInput
  }

  /**
   * TourBooking findUniqueOrThrow
   */
  export type TourBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    /**
     * Filter, which TourBooking to fetch.
     */
    where: TourBookingWhereUniqueInput
  }

  /**
   * TourBooking findFirst
   */
  export type TourBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    /**
     * Filter, which TourBooking to fetch.
     */
    where?: TourBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourBookings to fetch.
     */
    orderBy?: TourBookingOrderByWithRelationInput | TourBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourBookings.
     */
    cursor?: TourBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourBookings.
     */
    distinct?: TourBookingScalarFieldEnum | TourBookingScalarFieldEnum[]
  }

  /**
   * TourBooking findFirstOrThrow
   */
  export type TourBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    /**
     * Filter, which TourBooking to fetch.
     */
    where?: TourBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourBookings to fetch.
     */
    orderBy?: TourBookingOrderByWithRelationInput | TourBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourBookings.
     */
    cursor?: TourBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourBookings.
     */
    distinct?: TourBookingScalarFieldEnum | TourBookingScalarFieldEnum[]
  }

  /**
   * TourBooking findMany
   */
  export type TourBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    /**
     * Filter, which TourBookings to fetch.
     */
    where?: TourBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourBookings to fetch.
     */
    orderBy?: TourBookingOrderByWithRelationInput | TourBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TourBookings.
     */
    cursor?: TourBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourBookings.
     */
    skip?: number
    distinct?: TourBookingScalarFieldEnum | TourBookingScalarFieldEnum[]
  }

  /**
   * TourBooking create
   */
  export type TourBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a TourBooking.
     */
    data: XOR<TourBookingCreateInput, TourBookingUncheckedCreateInput>
  }

  /**
   * TourBooking createMany
   */
  export type TourBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TourBookings.
     */
    data: TourBookingCreateManyInput | TourBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourBooking createManyAndReturn
   */
  export type TourBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * The data used to create many TourBookings.
     */
    data: TourBookingCreateManyInput | TourBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TourBooking update
   */
  export type TourBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a TourBooking.
     */
    data: XOR<TourBookingUpdateInput, TourBookingUncheckedUpdateInput>
    /**
     * Choose, which TourBooking to update.
     */
    where: TourBookingWhereUniqueInput
  }

  /**
   * TourBooking updateMany
   */
  export type TourBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TourBookings.
     */
    data: XOR<TourBookingUpdateManyMutationInput, TourBookingUncheckedUpdateManyInput>
    /**
     * Filter which TourBookings to update
     */
    where?: TourBookingWhereInput
    /**
     * Limit how many TourBookings to update.
     */
    limit?: number
  }

  /**
   * TourBooking updateManyAndReturn
   */
  export type TourBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * The data used to update TourBookings.
     */
    data: XOR<TourBookingUpdateManyMutationInput, TourBookingUncheckedUpdateManyInput>
    /**
     * Filter which TourBookings to update
     */
    where?: TourBookingWhereInput
    /**
     * Limit how many TourBookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TourBooking upsert
   */
  export type TourBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the TourBooking to update in case it exists.
     */
    where: TourBookingWhereUniqueInput
    /**
     * In case the TourBooking found by the `where` argument doesn't exist, create a new TourBooking with this data.
     */
    create: XOR<TourBookingCreateInput, TourBookingUncheckedCreateInput>
    /**
     * In case the TourBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourBookingUpdateInput, TourBookingUncheckedUpdateInput>
  }

  /**
   * TourBooking delete
   */
  export type TourBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
    /**
     * Filter which TourBooking to delete.
     */
    where: TourBookingWhereUniqueInput
  }

  /**
   * TourBooking deleteMany
   */
  export type TourBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourBookings to delete
     */
    where?: TourBookingWhereInput
    /**
     * Limit how many TourBookings to delete.
     */
    limit?: number
  }

  /**
   * TourBooking.driver
   */
  export type TourBooking$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * TourBooking.User
   */
  export type TourBooking$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TourBooking without action
   */
  export type TourBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBooking
     */
    select?: TourBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourBooking
     */
    omit?: TourBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBookingInclude<ExtArgs> | null
  }


  /**
   * Model TenantWebsite
   */

  export type AggregateTenantWebsite = {
    _count: TenantWebsiteCountAggregateOutputType | null
    _min: TenantWebsiteMinAggregateOutputType | null
    _max: TenantWebsiteMaxAggregateOutputType | null
  }

  export type TenantWebsiteMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    domain: string | null
    subdomain: string | null
    isActive: boolean | null
    theme: string | null
    customCSS: string | null
    favicon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantWebsiteMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    domain: string | null
    subdomain: string | null
    isActive: boolean | null
    theme: string | null
    customCSS: string | null
    favicon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantWebsiteCountAggregateOutputType = {
    id: number
    tenantId: number
    domain: number
    subdomain: number
    isActive: number
    theme: number
    customCSS: number
    favicon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantWebsiteMinAggregateInputType = {
    id?: true
    tenantId?: true
    domain?: true
    subdomain?: true
    isActive?: true
    theme?: true
    customCSS?: true
    favicon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantWebsiteMaxAggregateInputType = {
    id?: true
    tenantId?: true
    domain?: true
    subdomain?: true
    isActive?: true
    theme?: true
    customCSS?: true
    favicon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantWebsiteCountAggregateInputType = {
    id?: true
    tenantId?: true
    domain?: true
    subdomain?: true
    isActive?: true
    theme?: true
    customCSS?: true
    favicon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantWebsiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantWebsite to aggregate.
     */
    where?: TenantWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantWebsites to fetch.
     */
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantWebsites
    **/
    _count?: true | TenantWebsiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantWebsiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantWebsiteMaxAggregateInputType
  }

  export type GetTenantWebsiteAggregateType<T extends TenantWebsiteAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantWebsite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantWebsite[P]>
      : GetScalarType<T[P], AggregateTenantWebsite[P]>
  }




  export type TenantWebsiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWebsiteWhereInput
    orderBy?: TenantWebsiteOrderByWithAggregationInput | TenantWebsiteOrderByWithAggregationInput[]
    by: TenantWebsiteScalarFieldEnum[] | TenantWebsiteScalarFieldEnum
    having?: TenantWebsiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantWebsiteCountAggregateInputType | true
    _min?: TenantWebsiteMinAggregateInputType
    _max?: TenantWebsiteMaxAggregateInputType
  }

  export type TenantWebsiteGroupByOutputType = {
    id: string
    tenantId: string
    domain: string | null
    subdomain: string | null
    isActive: boolean
    theme: string
    customCSS: string | null
    favicon: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantWebsiteCountAggregateOutputType | null
    _min: TenantWebsiteMinAggregateOutputType | null
    _max: TenantWebsiteMaxAggregateOutputType | null
  }

  type GetTenantWebsiteGroupByPayload<T extends TenantWebsiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantWebsiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantWebsiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantWebsiteGroupByOutputType[P]>
            : GetScalarType<T[P], TenantWebsiteGroupByOutputType[P]>
        }
      >
    >


  export type TenantWebsiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    domain?: boolean
    subdomain?: boolean
    isActive?: boolean
    theme?: boolean
    customCSS?: boolean
    favicon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    pages?: boolean | TenantWebsite$pagesArgs<ExtArgs>
    settings?: boolean | TenantWebsite$settingsArgs<ExtArgs>
    sections?: boolean | TenantWebsite$sectionsArgs<ExtArgs>
    _count?: boolean | TenantWebsiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantWebsite"]>

  export type TenantWebsiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    domain?: boolean
    subdomain?: boolean
    isActive?: boolean
    theme?: boolean
    customCSS?: boolean
    favicon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantWebsite"]>

  export type TenantWebsiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    domain?: boolean
    subdomain?: boolean
    isActive?: boolean
    theme?: boolean
    customCSS?: boolean
    favicon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantWebsite"]>

  export type TenantWebsiteSelectScalar = {
    id?: boolean
    tenantId?: boolean
    domain?: boolean
    subdomain?: boolean
    isActive?: boolean
    theme?: boolean
    customCSS?: boolean
    favicon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantWebsiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "domain" | "subdomain" | "isActive" | "theme" | "customCSS" | "favicon" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantWebsite"]>
  export type TenantWebsiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    pages?: boolean | TenantWebsite$pagesArgs<ExtArgs>
    settings?: boolean | TenantWebsite$settingsArgs<ExtArgs>
    sections?: boolean | TenantWebsite$sectionsArgs<ExtArgs>
    _count?: boolean | TenantWebsiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantWebsiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantWebsiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantWebsitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantWebsite"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      pages: Prisma.$WebsitePagePayload<ExtArgs>[]
      settings: Prisma.$WebsiteSettingsPayload<ExtArgs> | null
      sections: Prisma.$WebsiteSectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      domain: string | null
      subdomain: string | null
      isActive: boolean
      theme: string
      customCSS: string | null
      favicon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantWebsite"]>
    composites: {}
  }

  type TenantWebsiteGetPayload<S extends boolean | null | undefined | TenantWebsiteDefaultArgs> = $Result.GetResult<Prisma.$TenantWebsitePayload, S>

  type TenantWebsiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantWebsiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantWebsiteCountAggregateInputType | true
    }

  export interface TenantWebsiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantWebsite'], meta: { name: 'TenantWebsite' } }
    /**
     * Find zero or one TenantWebsite that matches the filter.
     * @param {TenantWebsiteFindUniqueArgs} args - Arguments to find a TenantWebsite
     * @example
     * // Get one TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantWebsiteFindUniqueArgs>(args: SelectSubset<T, TenantWebsiteFindUniqueArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantWebsite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantWebsiteFindUniqueOrThrowArgs} args - Arguments to find a TenantWebsite
     * @example
     * // Get one TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantWebsiteFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantWebsiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantWebsite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteFindFirstArgs} args - Arguments to find a TenantWebsite
     * @example
     * // Get one TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantWebsiteFindFirstArgs>(args?: SelectSubset<T, TenantWebsiteFindFirstArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantWebsite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteFindFirstOrThrowArgs} args - Arguments to find a TenantWebsite
     * @example
     * // Get one TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantWebsiteFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantWebsiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantWebsites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantWebsites
     * const tenantWebsites = await prisma.tenantWebsite.findMany()
     * 
     * // Get first 10 TenantWebsites
     * const tenantWebsites = await prisma.tenantWebsite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWebsiteWithIdOnly = await prisma.tenantWebsite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantWebsiteFindManyArgs>(args?: SelectSubset<T, TenantWebsiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantWebsite.
     * @param {TenantWebsiteCreateArgs} args - Arguments to create a TenantWebsite.
     * @example
     * // Create one TenantWebsite
     * const TenantWebsite = await prisma.tenantWebsite.create({
     *   data: {
     *     // ... data to create a TenantWebsite
     *   }
     * })
     * 
     */
    create<T extends TenantWebsiteCreateArgs>(args: SelectSubset<T, TenantWebsiteCreateArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantWebsites.
     * @param {TenantWebsiteCreateManyArgs} args - Arguments to create many TenantWebsites.
     * @example
     * // Create many TenantWebsites
     * const tenantWebsite = await prisma.tenantWebsite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantWebsiteCreateManyArgs>(args?: SelectSubset<T, TenantWebsiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantWebsites and returns the data saved in the database.
     * @param {TenantWebsiteCreateManyAndReturnArgs} args - Arguments to create many TenantWebsites.
     * @example
     * // Create many TenantWebsites
     * const tenantWebsite = await prisma.tenantWebsite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantWebsites and only return the `id`
     * const tenantWebsiteWithIdOnly = await prisma.tenantWebsite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantWebsiteCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantWebsiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantWebsite.
     * @param {TenantWebsiteDeleteArgs} args - Arguments to delete one TenantWebsite.
     * @example
     * // Delete one TenantWebsite
     * const TenantWebsite = await prisma.tenantWebsite.delete({
     *   where: {
     *     // ... filter to delete one TenantWebsite
     *   }
     * })
     * 
     */
    delete<T extends TenantWebsiteDeleteArgs>(args: SelectSubset<T, TenantWebsiteDeleteArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantWebsite.
     * @param {TenantWebsiteUpdateArgs} args - Arguments to update one TenantWebsite.
     * @example
     * // Update one TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantWebsiteUpdateArgs>(args: SelectSubset<T, TenantWebsiteUpdateArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantWebsites.
     * @param {TenantWebsiteDeleteManyArgs} args - Arguments to filter TenantWebsites to delete.
     * @example
     * // Delete a few TenantWebsites
     * const { count } = await prisma.tenantWebsite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantWebsiteDeleteManyArgs>(args?: SelectSubset<T, TenantWebsiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantWebsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantWebsites
     * const tenantWebsite = await prisma.tenantWebsite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantWebsiteUpdateManyArgs>(args: SelectSubset<T, TenantWebsiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantWebsites and returns the data updated in the database.
     * @param {TenantWebsiteUpdateManyAndReturnArgs} args - Arguments to update many TenantWebsites.
     * @example
     * // Update many TenantWebsites
     * const tenantWebsite = await prisma.tenantWebsite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantWebsites and only return the `id`
     * const tenantWebsiteWithIdOnly = await prisma.tenantWebsite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantWebsiteUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantWebsiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantWebsite.
     * @param {TenantWebsiteUpsertArgs} args - Arguments to update or create a TenantWebsite.
     * @example
     * // Update or create a TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.upsert({
     *   create: {
     *     // ... data to create a TenantWebsite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantWebsite we want to update
     *   }
     * })
     */
    upsert<T extends TenantWebsiteUpsertArgs>(args: SelectSubset<T, TenantWebsiteUpsertArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantWebsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteCountArgs} args - Arguments to filter TenantWebsites to count.
     * @example
     * // Count the number of TenantWebsites
     * const count = await prisma.tenantWebsite.count({
     *   where: {
     *     // ... the filter for the TenantWebsites we want to count
     *   }
     * })
    **/
    count<T extends TenantWebsiteCountArgs>(
      args?: Subset<T, TenantWebsiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantWebsiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantWebsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantWebsiteAggregateArgs>(args: Subset<T, TenantWebsiteAggregateArgs>): Prisma.PrismaPromise<GetTenantWebsiteAggregateType<T>>

    /**
     * Group by TenantWebsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantWebsiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantWebsiteGroupByArgs['orderBy'] }
        : { orderBy?: TenantWebsiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantWebsiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantWebsiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantWebsite model
   */
  readonly fields: TenantWebsiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantWebsite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantWebsiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pages<T extends TenantWebsite$pagesArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsite$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends TenantWebsite$settingsArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsite$settingsArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sections<T extends TenantWebsite$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsite$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantWebsite model
   */
  interface TenantWebsiteFieldRefs {
    readonly id: FieldRef<"TenantWebsite", 'String'>
    readonly tenantId: FieldRef<"TenantWebsite", 'String'>
    readonly domain: FieldRef<"TenantWebsite", 'String'>
    readonly subdomain: FieldRef<"TenantWebsite", 'String'>
    readonly isActive: FieldRef<"TenantWebsite", 'Boolean'>
    readonly theme: FieldRef<"TenantWebsite", 'String'>
    readonly customCSS: FieldRef<"TenantWebsite", 'String'>
    readonly favicon: FieldRef<"TenantWebsite", 'String'>
    readonly createdAt: FieldRef<"TenantWebsite", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantWebsite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantWebsite findUnique
   */
  export type TenantWebsiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which TenantWebsite to fetch.
     */
    where: TenantWebsiteWhereUniqueInput
  }

  /**
   * TenantWebsite findUniqueOrThrow
   */
  export type TenantWebsiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which TenantWebsite to fetch.
     */
    where: TenantWebsiteWhereUniqueInput
  }

  /**
   * TenantWebsite findFirst
   */
  export type TenantWebsiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which TenantWebsite to fetch.
     */
    where?: TenantWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantWebsites to fetch.
     */
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantWebsites.
     */
    cursor?: TenantWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantWebsites.
     */
    distinct?: TenantWebsiteScalarFieldEnum | TenantWebsiteScalarFieldEnum[]
  }

  /**
   * TenantWebsite findFirstOrThrow
   */
  export type TenantWebsiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which TenantWebsite to fetch.
     */
    where?: TenantWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantWebsites to fetch.
     */
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantWebsites.
     */
    cursor?: TenantWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantWebsites.
     */
    distinct?: TenantWebsiteScalarFieldEnum | TenantWebsiteScalarFieldEnum[]
  }

  /**
   * TenantWebsite findMany
   */
  export type TenantWebsiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which TenantWebsites to fetch.
     */
    where?: TenantWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantWebsites to fetch.
     */
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantWebsites.
     */
    cursor?: TenantWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantWebsites.
     */
    skip?: number
    distinct?: TenantWebsiteScalarFieldEnum | TenantWebsiteScalarFieldEnum[]
  }

  /**
   * TenantWebsite create
   */
  export type TenantWebsiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantWebsite.
     */
    data: XOR<TenantWebsiteCreateInput, TenantWebsiteUncheckedCreateInput>
  }

  /**
   * TenantWebsite createMany
   */
  export type TenantWebsiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantWebsites.
     */
    data: TenantWebsiteCreateManyInput | TenantWebsiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantWebsite createManyAndReturn
   */
  export type TenantWebsiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * The data used to create many TenantWebsites.
     */
    data: TenantWebsiteCreateManyInput | TenantWebsiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantWebsite update
   */
  export type TenantWebsiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantWebsite.
     */
    data: XOR<TenantWebsiteUpdateInput, TenantWebsiteUncheckedUpdateInput>
    /**
     * Choose, which TenantWebsite to update.
     */
    where: TenantWebsiteWhereUniqueInput
  }

  /**
   * TenantWebsite updateMany
   */
  export type TenantWebsiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantWebsites.
     */
    data: XOR<TenantWebsiteUpdateManyMutationInput, TenantWebsiteUncheckedUpdateManyInput>
    /**
     * Filter which TenantWebsites to update
     */
    where?: TenantWebsiteWhereInput
    /**
     * Limit how many TenantWebsites to update.
     */
    limit?: number
  }

  /**
   * TenantWebsite updateManyAndReturn
   */
  export type TenantWebsiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * The data used to update TenantWebsites.
     */
    data: XOR<TenantWebsiteUpdateManyMutationInput, TenantWebsiteUncheckedUpdateManyInput>
    /**
     * Filter which TenantWebsites to update
     */
    where?: TenantWebsiteWhereInput
    /**
     * Limit how many TenantWebsites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantWebsite upsert
   */
  export type TenantWebsiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantWebsite to update in case it exists.
     */
    where: TenantWebsiteWhereUniqueInput
    /**
     * In case the TenantWebsite found by the `where` argument doesn't exist, create a new TenantWebsite with this data.
     */
    create: XOR<TenantWebsiteCreateInput, TenantWebsiteUncheckedCreateInput>
    /**
     * In case the TenantWebsite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantWebsiteUpdateInput, TenantWebsiteUncheckedUpdateInput>
  }

  /**
   * TenantWebsite delete
   */
  export type TenantWebsiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter which TenantWebsite to delete.
     */
    where: TenantWebsiteWhereUniqueInput
  }

  /**
   * TenantWebsite deleteMany
   */
  export type TenantWebsiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantWebsites to delete
     */
    where?: TenantWebsiteWhereInput
    /**
     * Limit how many TenantWebsites to delete.
     */
    limit?: number
  }

  /**
   * TenantWebsite.pages
   */
  export type TenantWebsite$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
    where?: WebsitePageWhereInput
    orderBy?: WebsitePageOrderByWithRelationInput | WebsitePageOrderByWithRelationInput[]
    cursor?: WebsitePageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebsitePageScalarFieldEnum | WebsitePageScalarFieldEnum[]
  }

  /**
   * TenantWebsite.settings
   */
  export type TenantWebsite$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
    where?: WebsiteSettingsWhereInput
  }

  /**
   * TenantWebsite.sections
   */
  export type TenantWebsite$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
    where?: WebsiteSectionWhereInput
    orderBy?: WebsiteSectionOrderByWithRelationInput | WebsiteSectionOrderByWithRelationInput[]
    cursor?: WebsiteSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebsiteSectionScalarFieldEnum | WebsiteSectionScalarFieldEnum[]
  }

  /**
   * TenantWebsite without action
   */
  export type TenantWebsiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
  }


  /**
   * Model WebsitePage
   */

  export type AggregateWebsitePage = {
    _count: WebsitePageCountAggregateOutputType | null
    _avg: WebsitePageAvgAggregateOutputType | null
    _sum: WebsitePageSumAggregateOutputType | null
    _min: WebsitePageMinAggregateOutputType | null
    _max: WebsitePageMaxAggregateOutputType | null
  }

  export type WebsitePageAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type WebsitePageSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type WebsitePageMinAggregateOutputType = {
    id: string | null
    websiteId: string | null
    slug: string | null
    title: string | null
    metaTitle: string | null
    metaDescription: string | null
    isPublished: boolean | null
    isHomepage: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsitePageMaxAggregateOutputType = {
    id: string | null
    websiteId: string | null
    slug: string | null
    title: string | null
    metaTitle: string | null
    metaDescription: string | null
    isPublished: boolean | null
    isHomepage: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsitePageCountAggregateOutputType = {
    id: number
    websiteId: number
    slug: number
    title: number
    content: number
    metaTitle: number
    metaDescription: number
    isPublished: number
    isHomepage: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebsitePageAvgAggregateInputType = {
    sortOrder?: true
  }

  export type WebsitePageSumAggregateInputType = {
    sortOrder?: true
  }

  export type WebsitePageMinAggregateInputType = {
    id?: true
    websiteId?: true
    slug?: true
    title?: true
    metaTitle?: true
    metaDescription?: true
    isPublished?: true
    isHomepage?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsitePageMaxAggregateInputType = {
    id?: true
    websiteId?: true
    slug?: true
    title?: true
    metaTitle?: true
    metaDescription?: true
    isPublished?: true
    isHomepage?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsitePageCountAggregateInputType = {
    id?: true
    websiteId?: true
    slug?: true
    title?: true
    content?: true
    metaTitle?: true
    metaDescription?: true
    isPublished?: true
    isHomepage?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebsitePageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsitePage to aggregate.
     */
    where?: WebsitePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsitePages to fetch.
     */
    orderBy?: WebsitePageOrderByWithRelationInput | WebsitePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebsitePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsitePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsitePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebsitePages
    **/
    _count?: true | WebsitePageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebsitePageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebsitePageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebsitePageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebsitePageMaxAggregateInputType
  }

  export type GetWebsitePageAggregateType<T extends WebsitePageAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsitePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsitePage[P]>
      : GetScalarType<T[P], AggregateWebsitePage[P]>
  }




  export type WebsitePageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsitePageWhereInput
    orderBy?: WebsitePageOrderByWithAggregationInput | WebsitePageOrderByWithAggregationInput[]
    by: WebsitePageScalarFieldEnum[] | WebsitePageScalarFieldEnum
    having?: WebsitePageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebsitePageCountAggregateInputType | true
    _avg?: WebsitePageAvgAggregateInputType
    _sum?: WebsitePageSumAggregateInputType
    _min?: WebsitePageMinAggregateInputType
    _max?: WebsitePageMaxAggregateInputType
  }

  export type WebsitePageGroupByOutputType = {
    id: string
    websiteId: string
    slug: string
    title: string
    content: JsonValue
    metaTitle: string | null
    metaDescription: string | null
    isPublished: boolean
    isHomepage: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: WebsitePageCountAggregateOutputType | null
    _avg: WebsitePageAvgAggregateOutputType | null
    _sum: WebsitePageSumAggregateOutputType | null
    _min: WebsitePageMinAggregateOutputType | null
    _max: WebsitePageMaxAggregateOutputType | null
  }

  type GetWebsitePageGroupByPayload<T extends WebsitePageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebsitePageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebsitePageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebsitePageGroupByOutputType[P]>
            : GetScalarType<T[P], WebsitePageGroupByOutputType[P]>
        }
      >
    >


  export type WebsitePageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteId?: boolean
    slug?: boolean
    title?: boolean
    content?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    isPublished?: boolean
    isHomepage?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websitePage"]>

  export type WebsitePageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteId?: boolean
    slug?: boolean
    title?: boolean
    content?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    isPublished?: boolean
    isHomepage?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websitePage"]>

  export type WebsitePageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteId?: boolean
    slug?: boolean
    title?: boolean
    content?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    isPublished?: boolean
    isHomepage?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websitePage"]>

  export type WebsitePageSelectScalar = {
    id?: boolean
    websiteId?: boolean
    slug?: boolean
    title?: boolean
    content?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    isPublished?: boolean
    isHomepage?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebsitePageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "websiteId" | "slug" | "title" | "content" | "metaTitle" | "metaDescription" | "isPublished" | "isHomepage" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["websitePage"]>
  export type WebsitePageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type WebsitePageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type WebsitePageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }

  export type $WebsitePagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebsitePage"
    objects: {
      website: Prisma.$TenantWebsitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      websiteId: string
      slug: string
      title: string
      content: Prisma.JsonValue
      metaTitle: string | null
      metaDescription: string | null
      isPublished: boolean
      isHomepage: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["websitePage"]>
    composites: {}
  }

  type WebsitePageGetPayload<S extends boolean | null | undefined | WebsitePageDefaultArgs> = $Result.GetResult<Prisma.$WebsitePagePayload, S>

  type WebsitePageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebsitePageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebsitePageCountAggregateInputType | true
    }

  export interface WebsitePageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebsitePage'], meta: { name: 'WebsitePage' } }
    /**
     * Find zero or one WebsitePage that matches the filter.
     * @param {WebsitePageFindUniqueArgs} args - Arguments to find a WebsitePage
     * @example
     * // Get one WebsitePage
     * const websitePage = await prisma.websitePage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebsitePageFindUniqueArgs>(args: SelectSubset<T, WebsitePageFindUniqueArgs<ExtArgs>>): Prisma__WebsitePageClient<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebsitePage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebsitePageFindUniqueOrThrowArgs} args - Arguments to find a WebsitePage
     * @example
     * // Get one WebsitePage
     * const websitePage = await prisma.websitePage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebsitePageFindUniqueOrThrowArgs>(args: SelectSubset<T, WebsitePageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebsitePageClient<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebsitePage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsitePageFindFirstArgs} args - Arguments to find a WebsitePage
     * @example
     * // Get one WebsitePage
     * const websitePage = await prisma.websitePage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebsitePageFindFirstArgs>(args?: SelectSubset<T, WebsitePageFindFirstArgs<ExtArgs>>): Prisma__WebsitePageClient<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebsitePage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsitePageFindFirstOrThrowArgs} args - Arguments to find a WebsitePage
     * @example
     * // Get one WebsitePage
     * const websitePage = await prisma.websitePage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebsitePageFindFirstOrThrowArgs>(args?: SelectSubset<T, WebsitePageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebsitePageClient<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebsitePages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsitePageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebsitePages
     * const websitePages = await prisma.websitePage.findMany()
     * 
     * // Get first 10 WebsitePages
     * const websitePages = await prisma.websitePage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const websitePageWithIdOnly = await prisma.websitePage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebsitePageFindManyArgs>(args?: SelectSubset<T, WebsitePageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebsitePage.
     * @param {WebsitePageCreateArgs} args - Arguments to create a WebsitePage.
     * @example
     * // Create one WebsitePage
     * const WebsitePage = await prisma.websitePage.create({
     *   data: {
     *     // ... data to create a WebsitePage
     *   }
     * })
     * 
     */
    create<T extends WebsitePageCreateArgs>(args: SelectSubset<T, WebsitePageCreateArgs<ExtArgs>>): Prisma__WebsitePageClient<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebsitePages.
     * @param {WebsitePageCreateManyArgs} args - Arguments to create many WebsitePages.
     * @example
     * // Create many WebsitePages
     * const websitePage = await prisma.websitePage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebsitePageCreateManyArgs>(args?: SelectSubset<T, WebsitePageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebsitePages and returns the data saved in the database.
     * @param {WebsitePageCreateManyAndReturnArgs} args - Arguments to create many WebsitePages.
     * @example
     * // Create many WebsitePages
     * const websitePage = await prisma.websitePage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebsitePages and only return the `id`
     * const websitePageWithIdOnly = await prisma.websitePage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebsitePageCreateManyAndReturnArgs>(args?: SelectSubset<T, WebsitePageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebsitePage.
     * @param {WebsitePageDeleteArgs} args - Arguments to delete one WebsitePage.
     * @example
     * // Delete one WebsitePage
     * const WebsitePage = await prisma.websitePage.delete({
     *   where: {
     *     // ... filter to delete one WebsitePage
     *   }
     * })
     * 
     */
    delete<T extends WebsitePageDeleteArgs>(args: SelectSubset<T, WebsitePageDeleteArgs<ExtArgs>>): Prisma__WebsitePageClient<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebsitePage.
     * @param {WebsitePageUpdateArgs} args - Arguments to update one WebsitePage.
     * @example
     * // Update one WebsitePage
     * const websitePage = await prisma.websitePage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebsitePageUpdateArgs>(args: SelectSubset<T, WebsitePageUpdateArgs<ExtArgs>>): Prisma__WebsitePageClient<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebsitePages.
     * @param {WebsitePageDeleteManyArgs} args - Arguments to filter WebsitePages to delete.
     * @example
     * // Delete a few WebsitePages
     * const { count } = await prisma.websitePage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebsitePageDeleteManyArgs>(args?: SelectSubset<T, WebsitePageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebsitePages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsitePageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebsitePages
     * const websitePage = await prisma.websitePage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebsitePageUpdateManyArgs>(args: SelectSubset<T, WebsitePageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebsitePages and returns the data updated in the database.
     * @param {WebsitePageUpdateManyAndReturnArgs} args - Arguments to update many WebsitePages.
     * @example
     * // Update many WebsitePages
     * const websitePage = await prisma.websitePage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebsitePages and only return the `id`
     * const websitePageWithIdOnly = await prisma.websitePage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebsitePageUpdateManyAndReturnArgs>(args: SelectSubset<T, WebsitePageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebsitePage.
     * @param {WebsitePageUpsertArgs} args - Arguments to update or create a WebsitePage.
     * @example
     * // Update or create a WebsitePage
     * const websitePage = await prisma.websitePage.upsert({
     *   create: {
     *     // ... data to create a WebsitePage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebsitePage we want to update
     *   }
     * })
     */
    upsert<T extends WebsitePageUpsertArgs>(args: SelectSubset<T, WebsitePageUpsertArgs<ExtArgs>>): Prisma__WebsitePageClient<$Result.GetResult<Prisma.$WebsitePagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebsitePages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsitePageCountArgs} args - Arguments to filter WebsitePages to count.
     * @example
     * // Count the number of WebsitePages
     * const count = await prisma.websitePage.count({
     *   where: {
     *     // ... the filter for the WebsitePages we want to count
     *   }
     * })
    **/
    count<T extends WebsitePageCountArgs>(
      args?: Subset<T, WebsitePageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebsitePageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebsitePage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsitePageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebsitePageAggregateArgs>(args: Subset<T, WebsitePageAggregateArgs>): Prisma.PrismaPromise<GetWebsitePageAggregateType<T>>

    /**
     * Group by WebsitePage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsitePageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebsitePageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebsitePageGroupByArgs['orderBy'] }
        : { orderBy?: WebsitePageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebsitePageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsitePageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebsitePage model
   */
  readonly fields: WebsitePageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebsitePage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebsitePageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    website<T extends TenantWebsiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsiteDefaultArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebsitePage model
   */
  interface WebsitePageFieldRefs {
    readonly id: FieldRef<"WebsitePage", 'String'>
    readonly websiteId: FieldRef<"WebsitePage", 'String'>
    readonly slug: FieldRef<"WebsitePage", 'String'>
    readonly title: FieldRef<"WebsitePage", 'String'>
    readonly content: FieldRef<"WebsitePage", 'Json'>
    readonly metaTitle: FieldRef<"WebsitePage", 'String'>
    readonly metaDescription: FieldRef<"WebsitePage", 'String'>
    readonly isPublished: FieldRef<"WebsitePage", 'Boolean'>
    readonly isHomepage: FieldRef<"WebsitePage", 'Boolean'>
    readonly sortOrder: FieldRef<"WebsitePage", 'Int'>
    readonly createdAt: FieldRef<"WebsitePage", 'DateTime'>
    readonly updatedAt: FieldRef<"WebsitePage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebsitePage findUnique
   */
  export type WebsitePageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
    /**
     * Filter, which WebsitePage to fetch.
     */
    where: WebsitePageWhereUniqueInput
  }

  /**
   * WebsitePage findUniqueOrThrow
   */
  export type WebsitePageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
    /**
     * Filter, which WebsitePage to fetch.
     */
    where: WebsitePageWhereUniqueInput
  }

  /**
   * WebsitePage findFirst
   */
  export type WebsitePageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
    /**
     * Filter, which WebsitePage to fetch.
     */
    where?: WebsitePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsitePages to fetch.
     */
    orderBy?: WebsitePageOrderByWithRelationInput | WebsitePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsitePages.
     */
    cursor?: WebsitePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsitePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsitePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsitePages.
     */
    distinct?: WebsitePageScalarFieldEnum | WebsitePageScalarFieldEnum[]
  }

  /**
   * WebsitePage findFirstOrThrow
   */
  export type WebsitePageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
    /**
     * Filter, which WebsitePage to fetch.
     */
    where?: WebsitePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsitePages to fetch.
     */
    orderBy?: WebsitePageOrderByWithRelationInput | WebsitePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsitePages.
     */
    cursor?: WebsitePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsitePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsitePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsitePages.
     */
    distinct?: WebsitePageScalarFieldEnum | WebsitePageScalarFieldEnum[]
  }

  /**
   * WebsitePage findMany
   */
  export type WebsitePageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
    /**
     * Filter, which WebsitePages to fetch.
     */
    where?: WebsitePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsitePages to fetch.
     */
    orderBy?: WebsitePageOrderByWithRelationInput | WebsitePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebsitePages.
     */
    cursor?: WebsitePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsitePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsitePages.
     */
    skip?: number
    distinct?: WebsitePageScalarFieldEnum | WebsitePageScalarFieldEnum[]
  }

  /**
   * WebsitePage create
   */
  export type WebsitePageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
    /**
     * The data needed to create a WebsitePage.
     */
    data: XOR<WebsitePageCreateInput, WebsitePageUncheckedCreateInput>
  }

  /**
   * WebsitePage createMany
   */
  export type WebsitePageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebsitePages.
     */
    data: WebsitePageCreateManyInput | WebsitePageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebsitePage createManyAndReturn
   */
  export type WebsitePageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * The data used to create many WebsitePages.
     */
    data: WebsitePageCreateManyInput | WebsitePageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebsitePage update
   */
  export type WebsitePageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
    /**
     * The data needed to update a WebsitePage.
     */
    data: XOR<WebsitePageUpdateInput, WebsitePageUncheckedUpdateInput>
    /**
     * Choose, which WebsitePage to update.
     */
    where: WebsitePageWhereUniqueInput
  }

  /**
   * WebsitePage updateMany
   */
  export type WebsitePageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebsitePages.
     */
    data: XOR<WebsitePageUpdateManyMutationInput, WebsitePageUncheckedUpdateManyInput>
    /**
     * Filter which WebsitePages to update
     */
    where?: WebsitePageWhereInput
    /**
     * Limit how many WebsitePages to update.
     */
    limit?: number
  }

  /**
   * WebsitePage updateManyAndReturn
   */
  export type WebsitePageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * The data used to update WebsitePages.
     */
    data: XOR<WebsitePageUpdateManyMutationInput, WebsitePageUncheckedUpdateManyInput>
    /**
     * Filter which WebsitePages to update
     */
    where?: WebsitePageWhereInput
    /**
     * Limit how many WebsitePages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebsitePage upsert
   */
  export type WebsitePageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
    /**
     * The filter to search for the WebsitePage to update in case it exists.
     */
    where: WebsitePageWhereUniqueInput
    /**
     * In case the WebsitePage found by the `where` argument doesn't exist, create a new WebsitePage with this data.
     */
    create: XOR<WebsitePageCreateInput, WebsitePageUncheckedCreateInput>
    /**
     * In case the WebsitePage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebsitePageUpdateInput, WebsitePageUncheckedUpdateInput>
  }

  /**
   * WebsitePage delete
   */
  export type WebsitePageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
    /**
     * Filter which WebsitePage to delete.
     */
    where: WebsitePageWhereUniqueInput
  }

  /**
   * WebsitePage deleteMany
   */
  export type WebsitePageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsitePages to delete
     */
    where?: WebsitePageWhereInput
    /**
     * Limit how many WebsitePages to delete.
     */
    limit?: number
  }

  /**
   * WebsitePage without action
   */
  export type WebsitePageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsitePage
     */
    select?: WebsitePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsitePage
     */
    omit?: WebsitePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsitePageInclude<ExtArgs> | null
  }


  /**
   * Model WebsiteSettings
   */

  export type AggregateWebsiteSettings = {
    _count: WebsiteSettingsCountAggregateOutputType | null
    _min: WebsiteSettingsMinAggregateOutputType | null
    _max: WebsiteSettingsMaxAggregateOutputType | null
  }

  export type WebsiteSettingsMinAggregateOutputType = {
    id: string | null
    websiteId: string | null
    companyName: string | null
    logo: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    heroImage: string | null
    customCSS: string | null
    analyticsCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsiteSettingsMaxAggregateOutputType = {
    id: string | null
    websiteId: string | null
    companyName: string | null
    logo: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    heroImage: string | null
    customCSS: string | null
    analyticsCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsiteSettingsCountAggregateOutputType = {
    id: number
    websiteId: number
    companyName: number
    logo: number
    heroTitle: number
    heroSubtitle: number
    heroImage: number
    contactInfo: number
    socialMedia: number
    seoSettings: number
    colorScheme: number
    customCSS: number
    analyticsCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebsiteSettingsMinAggregateInputType = {
    id?: true
    websiteId?: true
    companyName?: true
    logo?: true
    heroTitle?: true
    heroSubtitle?: true
    heroImage?: true
    customCSS?: true
    analyticsCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsiteSettingsMaxAggregateInputType = {
    id?: true
    websiteId?: true
    companyName?: true
    logo?: true
    heroTitle?: true
    heroSubtitle?: true
    heroImage?: true
    customCSS?: true
    analyticsCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsiteSettingsCountAggregateInputType = {
    id?: true
    websiteId?: true
    companyName?: true
    logo?: true
    heroTitle?: true
    heroSubtitle?: true
    heroImage?: true
    contactInfo?: true
    socialMedia?: true
    seoSettings?: true
    colorScheme?: true
    customCSS?: true
    analyticsCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebsiteSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsiteSettings to aggregate.
     */
    where?: WebsiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSettings to fetch.
     */
    orderBy?: WebsiteSettingsOrderByWithRelationInput | WebsiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebsiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebsiteSettings
    **/
    _count?: true | WebsiteSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebsiteSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebsiteSettingsMaxAggregateInputType
  }

  export type GetWebsiteSettingsAggregateType<T extends WebsiteSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsiteSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsiteSettings[P]>
      : GetScalarType<T[P], AggregateWebsiteSettings[P]>
  }




  export type WebsiteSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsiteSettingsWhereInput
    orderBy?: WebsiteSettingsOrderByWithAggregationInput | WebsiteSettingsOrderByWithAggregationInput[]
    by: WebsiteSettingsScalarFieldEnum[] | WebsiteSettingsScalarFieldEnum
    having?: WebsiteSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebsiteSettingsCountAggregateInputType | true
    _min?: WebsiteSettingsMinAggregateInputType
    _max?: WebsiteSettingsMaxAggregateInputType
  }

  export type WebsiteSettingsGroupByOutputType = {
    id: string
    websiteId: string
    companyName: string
    logo: string | null
    heroTitle: string
    heroSubtitle: string
    heroImage: string | null
    contactInfo: JsonValue
    socialMedia: JsonValue
    seoSettings: JsonValue
    colorScheme: JsonValue
    customCSS: string | null
    analyticsCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: WebsiteSettingsCountAggregateOutputType | null
    _min: WebsiteSettingsMinAggregateOutputType | null
    _max: WebsiteSettingsMaxAggregateOutputType | null
  }

  type GetWebsiteSettingsGroupByPayload<T extends WebsiteSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebsiteSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebsiteSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebsiteSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], WebsiteSettingsGroupByOutputType[P]>
        }
      >
    >


  export type WebsiteSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteId?: boolean
    companyName?: boolean
    logo?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    heroImage?: boolean
    contactInfo?: boolean
    socialMedia?: boolean
    seoSettings?: boolean
    colorScheme?: boolean
    customCSS?: boolean
    analyticsCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websiteSettings"]>

  export type WebsiteSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteId?: boolean
    companyName?: boolean
    logo?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    heroImage?: boolean
    contactInfo?: boolean
    socialMedia?: boolean
    seoSettings?: boolean
    colorScheme?: boolean
    customCSS?: boolean
    analyticsCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websiteSettings"]>

  export type WebsiteSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteId?: boolean
    companyName?: boolean
    logo?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    heroImage?: boolean
    contactInfo?: boolean
    socialMedia?: boolean
    seoSettings?: boolean
    colorScheme?: boolean
    customCSS?: boolean
    analyticsCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websiteSettings"]>

  export type WebsiteSettingsSelectScalar = {
    id?: boolean
    websiteId?: boolean
    companyName?: boolean
    logo?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    heroImage?: boolean
    contactInfo?: boolean
    socialMedia?: boolean
    seoSettings?: boolean
    colorScheme?: boolean
    customCSS?: boolean
    analyticsCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebsiteSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "websiteId" | "companyName" | "logo" | "heroTitle" | "heroSubtitle" | "heroImage" | "contactInfo" | "socialMedia" | "seoSettings" | "colorScheme" | "customCSS" | "analyticsCode" | "createdAt" | "updatedAt", ExtArgs["result"]["websiteSettings"]>
  export type WebsiteSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type WebsiteSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type WebsiteSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }

  export type $WebsiteSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebsiteSettings"
    objects: {
      website: Prisma.$TenantWebsitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      websiteId: string
      companyName: string
      logo: string | null
      heroTitle: string
      heroSubtitle: string
      heroImage: string | null
      contactInfo: Prisma.JsonValue
      socialMedia: Prisma.JsonValue
      seoSettings: Prisma.JsonValue
      colorScheme: Prisma.JsonValue
      customCSS: string | null
      analyticsCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["websiteSettings"]>
    composites: {}
  }

  type WebsiteSettingsGetPayload<S extends boolean | null | undefined | WebsiteSettingsDefaultArgs> = $Result.GetResult<Prisma.$WebsiteSettingsPayload, S>

  type WebsiteSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebsiteSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebsiteSettingsCountAggregateInputType | true
    }

  export interface WebsiteSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebsiteSettings'], meta: { name: 'WebsiteSettings' } }
    /**
     * Find zero or one WebsiteSettings that matches the filter.
     * @param {WebsiteSettingsFindUniqueArgs} args - Arguments to find a WebsiteSettings
     * @example
     * // Get one WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebsiteSettingsFindUniqueArgs>(args: SelectSubset<T, WebsiteSettingsFindUniqueArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebsiteSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebsiteSettingsFindUniqueOrThrowArgs} args - Arguments to find a WebsiteSettings
     * @example
     * // Get one WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebsiteSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, WebsiteSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebsiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsFindFirstArgs} args - Arguments to find a WebsiteSettings
     * @example
     * // Get one WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebsiteSettingsFindFirstArgs>(args?: SelectSubset<T, WebsiteSettingsFindFirstArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebsiteSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsFindFirstOrThrowArgs} args - Arguments to find a WebsiteSettings
     * @example
     * // Get one WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebsiteSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, WebsiteSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebsiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findMany()
     * 
     * // Get first 10 WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const websiteSettingsWithIdOnly = await prisma.websiteSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebsiteSettingsFindManyArgs>(args?: SelectSubset<T, WebsiteSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebsiteSettings.
     * @param {WebsiteSettingsCreateArgs} args - Arguments to create a WebsiteSettings.
     * @example
     * // Create one WebsiteSettings
     * const WebsiteSettings = await prisma.websiteSettings.create({
     *   data: {
     *     // ... data to create a WebsiteSettings
     *   }
     * })
     * 
     */
    create<T extends WebsiteSettingsCreateArgs>(args: SelectSubset<T, WebsiteSettingsCreateArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebsiteSettings.
     * @param {WebsiteSettingsCreateManyArgs} args - Arguments to create many WebsiteSettings.
     * @example
     * // Create many WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebsiteSettingsCreateManyArgs>(args?: SelectSubset<T, WebsiteSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebsiteSettings and returns the data saved in the database.
     * @param {WebsiteSettingsCreateManyAndReturnArgs} args - Arguments to create many WebsiteSettings.
     * @example
     * // Create many WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebsiteSettings and only return the `id`
     * const websiteSettingsWithIdOnly = await prisma.websiteSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebsiteSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, WebsiteSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebsiteSettings.
     * @param {WebsiteSettingsDeleteArgs} args - Arguments to delete one WebsiteSettings.
     * @example
     * // Delete one WebsiteSettings
     * const WebsiteSettings = await prisma.websiteSettings.delete({
     *   where: {
     *     // ... filter to delete one WebsiteSettings
     *   }
     * })
     * 
     */
    delete<T extends WebsiteSettingsDeleteArgs>(args: SelectSubset<T, WebsiteSettingsDeleteArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebsiteSettings.
     * @param {WebsiteSettingsUpdateArgs} args - Arguments to update one WebsiteSettings.
     * @example
     * // Update one WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebsiteSettingsUpdateArgs>(args: SelectSubset<T, WebsiteSettingsUpdateArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebsiteSettings.
     * @param {WebsiteSettingsDeleteManyArgs} args - Arguments to filter WebsiteSettings to delete.
     * @example
     * // Delete a few WebsiteSettings
     * const { count } = await prisma.websiteSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebsiteSettingsDeleteManyArgs>(args?: SelectSubset<T, WebsiteSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebsiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebsiteSettingsUpdateManyArgs>(args: SelectSubset<T, WebsiteSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebsiteSettings and returns the data updated in the database.
     * @param {WebsiteSettingsUpdateManyAndReturnArgs} args - Arguments to update many WebsiteSettings.
     * @example
     * // Update many WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebsiteSettings and only return the `id`
     * const websiteSettingsWithIdOnly = await prisma.websiteSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebsiteSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, WebsiteSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebsiteSettings.
     * @param {WebsiteSettingsUpsertArgs} args - Arguments to update or create a WebsiteSettings.
     * @example
     * // Update or create a WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.upsert({
     *   create: {
     *     // ... data to create a WebsiteSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebsiteSettings we want to update
     *   }
     * })
     */
    upsert<T extends WebsiteSettingsUpsertArgs>(args: SelectSubset<T, WebsiteSettingsUpsertArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebsiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsCountArgs} args - Arguments to filter WebsiteSettings to count.
     * @example
     * // Count the number of WebsiteSettings
     * const count = await prisma.websiteSettings.count({
     *   where: {
     *     // ... the filter for the WebsiteSettings we want to count
     *   }
     * })
    **/
    count<T extends WebsiteSettingsCountArgs>(
      args?: Subset<T, WebsiteSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebsiteSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebsiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebsiteSettingsAggregateArgs>(args: Subset<T, WebsiteSettingsAggregateArgs>): Prisma.PrismaPromise<GetWebsiteSettingsAggregateType<T>>

    /**
     * Group by WebsiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebsiteSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebsiteSettingsGroupByArgs['orderBy'] }
        : { orderBy?: WebsiteSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebsiteSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsiteSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebsiteSettings model
   */
  readonly fields: WebsiteSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebsiteSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebsiteSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    website<T extends TenantWebsiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsiteDefaultArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebsiteSettings model
   */
  interface WebsiteSettingsFieldRefs {
    readonly id: FieldRef<"WebsiteSettings", 'String'>
    readonly websiteId: FieldRef<"WebsiteSettings", 'String'>
    readonly companyName: FieldRef<"WebsiteSettings", 'String'>
    readonly logo: FieldRef<"WebsiteSettings", 'String'>
    readonly heroTitle: FieldRef<"WebsiteSettings", 'String'>
    readonly heroSubtitle: FieldRef<"WebsiteSettings", 'String'>
    readonly heroImage: FieldRef<"WebsiteSettings", 'String'>
    readonly contactInfo: FieldRef<"WebsiteSettings", 'Json'>
    readonly socialMedia: FieldRef<"WebsiteSettings", 'Json'>
    readonly seoSettings: FieldRef<"WebsiteSettings", 'Json'>
    readonly colorScheme: FieldRef<"WebsiteSettings", 'Json'>
    readonly customCSS: FieldRef<"WebsiteSettings", 'String'>
    readonly analyticsCode: FieldRef<"WebsiteSettings", 'String'>
    readonly createdAt: FieldRef<"WebsiteSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"WebsiteSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebsiteSettings findUnique
   */
  export type WebsiteSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteSettings to fetch.
     */
    where: WebsiteSettingsWhereUniqueInput
  }

  /**
   * WebsiteSettings findUniqueOrThrow
   */
  export type WebsiteSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteSettings to fetch.
     */
    where: WebsiteSettingsWhereUniqueInput
  }

  /**
   * WebsiteSettings findFirst
   */
  export type WebsiteSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteSettings to fetch.
     */
    where?: WebsiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSettings to fetch.
     */
    orderBy?: WebsiteSettingsOrderByWithRelationInput | WebsiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsiteSettings.
     */
    cursor?: WebsiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsiteSettings.
     */
    distinct?: WebsiteSettingsScalarFieldEnum | WebsiteSettingsScalarFieldEnum[]
  }

  /**
   * WebsiteSettings findFirstOrThrow
   */
  export type WebsiteSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteSettings to fetch.
     */
    where?: WebsiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSettings to fetch.
     */
    orderBy?: WebsiteSettingsOrderByWithRelationInput | WebsiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsiteSettings.
     */
    cursor?: WebsiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsiteSettings.
     */
    distinct?: WebsiteSettingsScalarFieldEnum | WebsiteSettingsScalarFieldEnum[]
  }

  /**
   * WebsiteSettings findMany
   */
  export type WebsiteSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteSettings to fetch.
     */
    where?: WebsiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSettings to fetch.
     */
    orderBy?: WebsiteSettingsOrderByWithRelationInput | WebsiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebsiteSettings.
     */
    cursor?: WebsiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSettings.
     */
    skip?: number
    distinct?: WebsiteSettingsScalarFieldEnum | WebsiteSettingsScalarFieldEnum[]
  }

  /**
   * WebsiteSettings create
   */
  export type WebsiteSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a WebsiteSettings.
     */
    data: XOR<WebsiteSettingsCreateInput, WebsiteSettingsUncheckedCreateInput>
  }

  /**
   * WebsiteSettings createMany
   */
  export type WebsiteSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebsiteSettings.
     */
    data: WebsiteSettingsCreateManyInput | WebsiteSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebsiteSettings createManyAndReturn
   */
  export type WebsiteSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many WebsiteSettings.
     */
    data: WebsiteSettingsCreateManyInput | WebsiteSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebsiteSettings update
   */
  export type WebsiteSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a WebsiteSettings.
     */
    data: XOR<WebsiteSettingsUpdateInput, WebsiteSettingsUncheckedUpdateInput>
    /**
     * Choose, which WebsiteSettings to update.
     */
    where: WebsiteSettingsWhereUniqueInput
  }

  /**
   * WebsiteSettings updateMany
   */
  export type WebsiteSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebsiteSettings.
     */
    data: XOR<WebsiteSettingsUpdateManyMutationInput, WebsiteSettingsUncheckedUpdateManyInput>
    /**
     * Filter which WebsiteSettings to update
     */
    where?: WebsiteSettingsWhereInput
    /**
     * Limit how many WebsiteSettings to update.
     */
    limit?: number
  }

  /**
   * WebsiteSettings updateManyAndReturn
   */
  export type WebsiteSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * The data used to update WebsiteSettings.
     */
    data: XOR<WebsiteSettingsUpdateManyMutationInput, WebsiteSettingsUncheckedUpdateManyInput>
    /**
     * Filter which WebsiteSettings to update
     */
    where?: WebsiteSettingsWhereInput
    /**
     * Limit how many WebsiteSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebsiteSettings upsert
   */
  export type WebsiteSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the WebsiteSettings to update in case it exists.
     */
    where: WebsiteSettingsWhereUniqueInput
    /**
     * In case the WebsiteSettings found by the `where` argument doesn't exist, create a new WebsiteSettings with this data.
     */
    create: XOR<WebsiteSettingsCreateInput, WebsiteSettingsUncheckedCreateInput>
    /**
     * In case the WebsiteSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebsiteSettingsUpdateInput, WebsiteSettingsUncheckedUpdateInput>
  }

  /**
   * WebsiteSettings delete
   */
  export type WebsiteSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
    /**
     * Filter which WebsiteSettings to delete.
     */
    where: WebsiteSettingsWhereUniqueInput
  }

  /**
   * WebsiteSettings deleteMany
   */
  export type WebsiteSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsiteSettings to delete
     */
    where?: WebsiteSettingsWhereInput
    /**
     * Limit how many WebsiteSettings to delete.
     */
    limit?: number
  }

  /**
   * WebsiteSettings without action
   */
  export type WebsiteSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSettingsInclude<ExtArgs> | null
  }


  /**
   * Model WebsiteSection
   */

  export type AggregateWebsiteSection = {
    _count: WebsiteSectionCountAggregateOutputType | null
    _avg: WebsiteSectionAvgAggregateOutputType | null
    _sum: WebsiteSectionSumAggregateOutputType | null
    _min: WebsiteSectionMinAggregateOutputType | null
    _max: WebsiteSectionMaxAggregateOutputType | null
  }

  export type WebsiteSectionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type WebsiteSectionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type WebsiteSectionMinAggregateOutputType = {
    id: string | null
    websiteId: string | null
    sectionType: string | null
    title: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsiteSectionMaxAggregateOutputType = {
    id: string | null
    websiteId: string | null
    sectionType: string | null
    title: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsiteSectionCountAggregateOutputType = {
    id: number
    websiteId: number
    sectionType: number
    title: number
    content: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebsiteSectionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type WebsiteSectionSumAggregateInputType = {
    sortOrder?: true
  }

  export type WebsiteSectionMinAggregateInputType = {
    id?: true
    websiteId?: true
    sectionType?: true
    title?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsiteSectionMaxAggregateInputType = {
    id?: true
    websiteId?: true
    sectionType?: true
    title?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsiteSectionCountAggregateInputType = {
    id?: true
    websiteId?: true
    sectionType?: true
    title?: true
    content?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebsiteSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsiteSection to aggregate.
     */
    where?: WebsiteSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSections to fetch.
     */
    orderBy?: WebsiteSectionOrderByWithRelationInput | WebsiteSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebsiteSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebsiteSections
    **/
    _count?: true | WebsiteSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebsiteSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebsiteSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebsiteSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebsiteSectionMaxAggregateInputType
  }

  export type GetWebsiteSectionAggregateType<T extends WebsiteSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsiteSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsiteSection[P]>
      : GetScalarType<T[P], AggregateWebsiteSection[P]>
  }




  export type WebsiteSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsiteSectionWhereInput
    orderBy?: WebsiteSectionOrderByWithAggregationInput | WebsiteSectionOrderByWithAggregationInput[]
    by: WebsiteSectionScalarFieldEnum[] | WebsiteSectionScalarFieldEnum
    having?: WebsiteSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebsiteSectionCountAggregateInputType | true
    _avg?: WebsiteSectionAvgAggregateInputType
    _sum?: WebsiteSectionSumAggregateInputType
    _min?: WebsiteSectionMinAggregateInputType
    _max?: WebsiteSectionMaxAggregateInputType
  }

  export type WebsiteSectionGroupByOutputType = {
    id: string
    websiteId: string
    sectionType: string
    title: string | null
    content: JsonValue
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: WebsiteSectionCountAggregateOutputType | null
    _avg: WebsiteSectionAvgAggregateOutputType | null
    _sum: WebsiteSectionSumAggregateOutputType | null
    _min: WebsiteSectionMinAggregateOutputType | null
    _max: WebsiteSectionMaxAggregateOutputType | null
  }

  type GetWebsiteSectionGroupByPayload<T extends WebsiteSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebsiteSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebsiteSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebsiteSectionGroupByOutputType[P]>
            : GetScalarType<T[P], WebsiteSectionGroupByOutputType[P]>
        }
      >
    >


  export type WebsiteSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteId?: boolean
    sectionType?: boolean
    title?: boolean
    content?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websiteSection"]>

  export type WebsiteSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteId?: boolean
    sectionType?: boolean
    title?: boolean
    content?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websiteSection"]>

  export type WebsiteSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteId?: boolean
    sectionType?: boolean
    title?: boolean
    content?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websiteSection"]>

  export type WebsiteSectionSelectScalar = {
    id?: boolean
    websiteId?: boolean
    sectionType?: boolean
    title?: boolean
    content?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebsiteSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "websiteId" | "sectionType" | "title" | "content" | "isActive" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["websiteSection"]>
  export type WebsiteSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type WebsiteSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type WebsiteSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    website?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }

  export type $WebsiteSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebsiteSection"
    objects: {
      website: Prisma.$TenantWebsitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      websiteId: string
      sectionType: string
      title: string | null
      content: Prisma.JsonValue
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["websiteSection"]>
    composites: {}
  }

  type WebsiteSectionGetPayload<S extends boolean | null | undefined | WebsiteSectionDefaultArgs> = $Result.GetResult<Prisma.$WebsiteSectionPayload, S>

  type WebsiteSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebsiteSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebsiteSectionCountAggregateInputType | true
    }

  export interface WebsiteSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebsiteSection'], meta: { name: 'WebsiteSection' } }
    /**
     * Find zero or one WebsiteSection that matches the filter.
     * @param {WebsiteSectionFindUniqueArgs} args - Arguments to find a WebsiteSection
     * @example
     * // Get one WebsiteSection
     * const websiteSection = await prisma.websiteSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebsiteSectionFindUniqueArgs>(args: SelectSubset<T, WebsiteSectionFindUniqueArgs<ExtArgs>>): Prisma__WebsiteSectionClient<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebsiteSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebsiteSectionFindUniqueOrThrowArgs} args - Arguments to find a WebsiteSection
     * @example
     * // Get one WebsiteSection
     * const websiteSection = await prisma.websiteSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebsiteSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, WebsiteSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebsiteSectionClient<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebsiteSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSectionFindFirstArgs} args - Arguments to find a WebsiteSection
     * @example
     * // Get one WebsiteSection
     * const websiteSection = await prisma.websiteSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebsiteSectionFindFirstArgs>(args?: SelectSubset<T, WebsiteSectionFindFirstArgs<ExtArgs>>): Prisma__WebsiteSectionClient<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebsiteSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSectionFindFirstOrThrowArgs} args - Arguments to find a WebsiteSection
     * @example
     * // Get one WebsiteSection
     * const websiteSection = await prisma.websiteSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebsiteSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, WebsiteSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebsiteSectionClient<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebsiteSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebsiteSections
     * const websiteSections = await prisma.websiteSection.findMany()
     * 
     * // Get first 10 WebsiteSections
     * const websiteSections = await prisma.websiteSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const websiteSectionWithIdOnly = await prisma.websiteSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebsiteSectionFindManyArgs>(args?: SelectSubset<T, WebsiteSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebsiteSection.
     * @param {WebsiteSectionCreateArgs} args - Arguments to create a WebsiteSection.
     * @example
     * // Create one WebsiteSection
     * const WebsiteSection = await prisma.websiteSection.create({
     *   data: {
     *     // ... data to create a WebsiteSection
     *   }
     * })
     * 
     */
    create<T extends WebsiteSectionCreateArgs>(args: SelectSubset<T, WebsiteSectionCreateArgs<ExtArgs>>): Prisma__WebsiteSectionClient<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebsiteSections.
     * @param {WebsiteSectionCreateManyArgs} args - Arguments to create many WebsiteSections.
     * @example
     * // Create many WebsiteSections
     * const websiteSection = await prisma.websiteSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebsiteSectionCreateManyArgs>(args?: SelectSubset<T, WebsiteSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebsiteSections and returns the data saved in the database.
     * @param {WebsiteSectionCreateManyAndReturnArgs} args - Arguments to create many WebsiteSections.
     * @example
     * // Create many WebsiteSections
     * const websiteSection = await prisma.websiteSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebsiteSections and only return the `id`
     * const websiteSectionWithIdOnly = await prisma.websiteSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebsiteSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, WebsiteSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebsiteSection.
     * @param {WebsiteSectionDeleteArgs} args - Arguments to delete one WebsiteSection.
     * @example
     * // Delete one WebsiteSection
     * const WebsiteSection = await prisma.websiteSection.delete({
     *   where: {
     *     // ... filter to delete one WebsiteSection
     *   }
     * })
     * 
     */
    delete<T extends WebsiteSectionDeleteArgs>(args: SelectSubset<T, WebsiteSectionDeleteArgs<ExtArgs>>): Prisma__WebsiteSectionClient<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebsiteSection.
     * @param {WebsiteSectionUpdateArgs} args - Arguments to update one WebsiteSection.
     * @example
     * // Update one WebsiteSection
     * const websiteSection = await prisma.websiteSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebsiteSectionUpdateArgs>(args: SelectSubset<T, WebsiteSectionUpdateArgs<ExtArgs>>): Prisma__WebsiteSectionClient<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebsiteSections.
     * @param {WebsiteSectionDeleteManyArgs} args - Arguments to filter WebsiteSections to delete.
     * @example
     * // Delete a few WebsiteSections
     * const { count } = await prisma.websiteSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebsiteSectionDeleteManyArgs>(args?: SelectSubset<T, WebsiteSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebsiteSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebsiteSections
     * const websiteSection = await prisma.websiteSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebsiteSectionUpdateManyArgs>(args: SelectSubset<T, WebsiteSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebsiteSections and returns the data updated in the database.
     * @param {WebsiteSectionUpdateManyAndReturnArgs} args - Arguments to update many WebsiteSections.
     * @example
     * // Update many WebsiteSections
     * const websiteSection = await prisma.websiteSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebsiteSections and only return the `id`
     * const websiteSectionWithIdOnly = await prisma.websiteSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebsiteSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, WebsiteSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebsiteSection.
     * @param {WebsiteSectionUpsertArgs} args - Arguments to update or create a WebsiteSection.
     * @example
     * // Update or create a WebsiteSection
     * const websiteSection = await prisma.websiteSection.upsert({
     *   create: {
     *     // ... data to create a WebsiteSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebsiteSection we want to update
     *   }
     * })
     */
    upsert<T extends WebsiteSectionUpsertArgs>(args: SelectSubset<T, WebsiteSectionUpsertArgs<ExtArgs>>): Prisma__WebsiteSectionClient<$Result.GetResult<Prisma.$WebsiteSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebsiteSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSectionCountArgs} args - Arguments to filter WebsiteSections to count.
     * @example
     * // Count the number of WebsiteSections
     * const count = await prisma.websiteSection.count({
     *   where: {
     *     // ... the filter for the WebsiteSections we want to count
     *   }
     * })
    **/
    count<T extends WebsiteSectionCountArgs>(
      args?: Subset<T, WebsiteSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebsiteSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebsiteSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebsiteSectionAggregateArgs>(args: Subset<T, WebsiteSectionAggregateArgs>): Prisma.PrismaPromise<GetWebsiteSectionAggregateType<T>>

    /**
     * Group by WebsiteSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebsiteSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebsiteSectionGroupByArgs['orderBy'] }
        : { orderBy?: WebsiteSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebsiteSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsiteSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebsiteSection model
   */
  readonly fields: WebsiteSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebsiteSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebsiteSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    website<T extends TenantWebsiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsiteDefaultArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebsiteSection model
   */
  interface WebsiteSectionFieldRefs {
    readonly id: FieldRef<"WebsiteSection", 'String'>
    readonly websiteId: FieldRef<"WebsiteSection", 'String'>
    readonly sectionType: FieldRef<"WebsiteSection", 'String'>
    readonly title: FieldRef<"WebsiteSection", 'String'>
    readonly content: FieldRef<"WebsiteSection", 'Json'>
    readonly isActive: FieldRef<"WebsiteSection", 'Boolean'>
    readonly sortOrder: FieldRef<"WebsiteSection", 'Int'>
    readonly createdAt: FieldRef<"WebsiteSection", 'DateTime'>
    readonly updatedAt: FieldRef<"WebsiteSection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebsiteSection findUnique
   */
  export type WebsiteSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteSection to fetch.
     */
    where: WebsiteSectionWhereUniqueInput
  }

  /**
   * WebsiteSection findUniqueOrThrow
   */
  export type WebsiteSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteSection to fetch.
     */
    where: WebsiteSectionWhereUniqueInput
  }

  /**
   * WebsiteSection findFirst
   */
  export type WebsiteSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteSection to fetch.
     */
    where?: WebsiteSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSections to fetch.
     */
    orderBy?: WebsiteSectionOrderByWithRelationInput | WebsiteSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsiteSections.
     */
    cursor?: WebsiteSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsiteSections.
     */
    distinct?: WebsiteSectionScalarFieldEnum | WebsiteSectionScalarFieldEnum[]
  }

  /**
   * WebsiteSection findFirstOrThrow
   */
  export type WebsiteSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteSection to fetch.
     */
    where?: WebsiteSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSections to fetch.
     */
    orderBy?: WebsiteSectionOrderByWithRelationInput | WebsiteSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsiteSections.
     */
    cursor?: WebsiteSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsiteSections.
     */
    distinct?: WebsiteSectionScalarFieldEnum | WebsiteSectionScalarFieldEnum[]
  }

  /**
   * WebsiteSection findMany
   */
  export type WebsiteSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteSections to fetch.
     */
    where?: WebsiteSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSections to fetch.
     */
    orderBy?: WebsiteSectionOrderByWithRelationInput | WebsiteSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebsiteSections.
     */
    cursor?: WebsiteSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSections.
     */
    skip?: number
    distinct?: WebsiteSectionScalarFieldEnum | WebsiteSectionScalarFieldEnum[]
  }

  /**
   * WebsiteSection create
   */
  export type WebsiteSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a WebsiteSection.
     */
    data: XOR<WebsiteSectionCreateInput, WebsiteSectionUncheckedCreateInput>
  }

  /**
   * WebsiteSection createMany
   */
  export type WebsiteSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebsiteSections.
     */
    data: WebsiteSectionCreateManyInput | WebsiteSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebsiteSection createManyAndReturn
   */
  export type WebsiteSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * The data used to create many WebsiteSections.
     */
    data: WebsiteSectionCreateManyInput | WebsiteSectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebsiteSection update
   */
  export type WebsiteSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a WebsiteSection.
     */
    data: XOR<WebsiteSectionUpdateInput, WebsiteSectionUncheckedUpdateInput>
    /**
     * Choose, which WebsiteSection to update.
     */
    where: WebsiteSectionWhereUniqueInput
  }

  /**
   * WebsiteSection updateMany
   */
  export type WebsiteSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebsiteSections.
     */
    data: XOR<WebsiteSectionUpdateManyMutationInput, WebsiteSectionUncheckedUpdateManyInput>
    /**
     * Filter which WebsiteSections to update
     */
    where?: WebsiteSectionWhereInput
    /**
     * Limit how many WebsiteSections to update.
     */
    limit?: number
  }

  /**
   * WebsiteSection updateManyAndReturn
   */
  export type WebsiteSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * The data used to update WebsiteSections.
     */
    data: XOR<WebsiteSectionUpdateManyMutationInput, WebsiteSectionUncheckedUpdateManyInput>
    /**
     * Filter which WebsiteSections to update
     */
    where?: WebsiteSectionWhereInput
    /**
     * Limit how many WebsiteSections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebsiteSection upsert
   */
  export type WebsiteSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the WebsiteSection to update in case it exists.
     */
    where: WebsiteSectionWhereUniqueInput
    /**
     * In case the WebsiteSection found by the `where` argument doesn't exist, create a new WebsiteSection with this data.
     */
    create: XOR<WebsiteSectionCreateInput, WebsiteSectionUncheckedCreateInput>
    /**
     * In case the WebsiteSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebsiteSectionUpdateInput, WebsiteSectionUncheckedUpdateInput>
  }

  /**
   * WebsiteSection delete
   */
  export type WebsiteSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
    /**
     * Filter which WebsiteSection to delete.
     */
    where: WebsiteSectionWhereUniqueInput
  }

  /**
   * WebsiteSection deleteMany
   */
  export type WebsiteSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsiteSections to delete
     */
    where?: WebsiteSectionWhereInput
    /**
     * Limit how many WebsiteSections to delete.
     */
    limit?: number
  }

  /**
   * WebsiteSection without action
   */
  export type WebsiteSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSection
     */
    select?: WebsiteSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSection
     */
    omit?: WebsiteSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteSectionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    subdomain: 'subdomain',
    companyName: 'companyName',
    domain: 'domain',
    isActive: 'isActive',
    subscriptionPlan: 'subscriptionPlan',
    websiteModuleEnabled: 'websiteModuleEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paymentAccountHolder: 'paymentAccountHolder',
    paymentBank: 'paymentBank',
    paymentIban: 'paymentIban'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    priceMonthly: 'priceMonthly',
    priceYearly: 'priceYearly',
    features: 'features',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const TenantModuleScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    moduleId: 'moduleId',
    isEnabled: 'isEnabled',
    activatedAt: 'activatedAt',
    expiresAt: 'expiresAt',
    features: 'features',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantModuleScalarFieldEnum = (typeof TenantModuleScalarFieldEnum)[keyof typeof TenantModuleScalarFieldEnum]


  export const TenantUserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    role: 'role',
    permissions: 'permissions',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantUserScalarFieldEnum = (typeof TenantUserScalarFieldEnum)[keyof typeof TenantUserScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phoneNumber: 'phoneNumber',
    tenantId: 'tenantId',
    createdAt: 'createdAt'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    isActive: 'isActive',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserPermissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permission: 'permission',
    grantedBy: 'grantedBy',
    grantedAt: 'grantedAt',
    isActive: 'isActive'
  };

  export type UserPermissionScalarFieldEnum = (typeof UserPermissionScalarFieldEnum)[keyof typeof UserPermissionScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    description: 'description',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    tenantId: 'tenantId'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    date: 'date',
    time: 'time',
    from: 'from',
    to: 'to',
    flightCode: 'flightCode',
    passengerNames: 'passengerNames',
    luggageCount: 'luggageCount',
    price: 'price',
    currency: 'currency',
    phoneNumber: 'phoneNumber',
    voucherNumber: 'voucherNumber',
    driverFee: 'driverFee',
    driverId: 'driverId',
    paymentStatus: 'paymentStatus',
    createdAt: 'createdAt',
    returnTransferId: 'returnTransferId',
    isReturn: 'isReturn',
    distanceKm: 'distanceKm',
    userId: 'userId',
    tenantId: 'tenantId',
    companyCommissionStatus: 'companyCommissionStatus',
    notes: 'notes',
    email: 'email',
    type: 'type'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const HotelRequestScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    customerPhone: 'customerPhone',
    checkin: 'checkin',
    checkout: 'checkout',
    adults: 'adults',
    children: 'children',
    rooms: 'rooms',
    city: 'city',
    region: 'region',
    budget: 'budget',
    roomType: 'roomType',
    breakfast: 'breakfast',
    amenities: 'amenities',
    specialRequests: 'specialRequests',
    status: 'status',
    assignedTo: 'assignedTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelRequestScalarFieldEnum = (typeof HotelRequestScalarFieldEnum)[keyof typeof HotelRequestScalarFieldEnum]


  export const HotelBookingScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    requestId: 'requestId',
    reservationId: 'reservationId',
    hotelId: 'hotelId',
    hotelName: 'hotelName',
    hotelAddress: 'hotelAddress',
    roomType: 'roomType',
    checkin: 'checkin',
    checkout: 'checkout',
    adults: 'adults',
    children: 'children',
    rooms: 'rooms',
    totalPrice: 'totalPrice',
    currency: 'currency',
    bookingReference: 'bookingReference',
    status: 'status',
    customerInfo: 'customerInfo',
    specialRequests: 'specialRequests',
    cancellationPolicy: 'cancellationPolicy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    agentPrice: 'agentPrice',
    customerPrice: 'customerPrice',
    profitMargin: 'profitMargin',
    voucherNumber: 'voucherNumber'
  };

  export type HotelBookingScalarFieldEnum = (typeof HotelBookingScalarFieldEnum)[keyof typeof HotelBookingScalarFieldEnum]


  export const HotelPricePoolScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    hotelId: 'hotelId',
    hotelName: 'hotelName',
    hotelAddress: 'hotelAddress',
    hotelCity: 'hotelCity',
    hotelCountry: 'hotelCountry',
    hotelRating: 'hotelRating',
    hotelStars: 'hotelStars',
    hotelImage: 'hotelImage',
    hotelAmenities: 'hotelAmenities',
    roomType: 'roomType',
    roomName: 'roomName',
    roomDescription: 'roomDescription',
    roomAmenities: 'roomAmenities',
    maxOccupancy: 'maxOccupancy',
    bedType: 'bedType',
    roomSize: 'roomSize',
    roomView: 'roomView',
    basePrice: 'basePrice',
    agentPrice: 'agentPrice',
    customerPrice: 'customerPrice',
    profitMargin: 'profitMargin',
    profitPercentage: 'profitPercentage',
    currency: 'currency',
    validFrom: 'validFrom',
    validTo: 'validTo',
    cancellationPolicy: 'cancellationPolicy',
    breakfastIncluded: 'breakfastIncluded',
    freeCancellation: 'freeCancellation',
    source: 'source',
    lastUpdated: 'lastUpdated',
    updatedBy: 'updatedBy',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelPricePoolScalarFieldEnum = (typeof HotelPricePoolScalarFieldEnum)[keyof typeof HotelPricePoolScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    type: 'type',
    capacity: 'capacity',
    licensePlate: 'licensePlate',
    driverName: 'driverName',
    driverPhone: 'driverPhone',
    isAvailable: 'isAvailable',
    lastMaintenance: 'lastMaintenance',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const TourBookingScalarFieldEnum: {
    id: 'id',
    voucherNumber: 'voucherNumber',
    routeName: 'routeName',
    vehicleType: 'vehicleType',
    groupSize: 'groupSize',
    price: 'price',
    currency: 'currency',
    pickupLocation: 'pickupLocation',
    tourDate: 'tourDate',
    tourTime: 'tourTime',
    passengerNames: 'passengerNames',
    notes: 'notes',
    status: 'status',
    tenantId: 'tenantId',
    userId: 'userId',
    driverId: 'driverId',
    driverFee: 'driverFee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tourDuration: 'tourDuration'
  };

  export type TourBookingScalarFieldEnum = (typeof TourBookingScalarFieldEnum)[keyof typeof TourBookingScalarFieldEnum]


  export const TenantWebsiteScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    domain: 'domain',
    subdomain: 'subdomain',
    isActive: 'isActive',
    theme: 'theme',
    customCSS: 'customCSS',
    favicon: 'favicon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantWebsiteScalarFieldEnum = (typeof TenantWebsiteScalarFieldEnum)[keyof typeof TenantWebsiteScalarFieldEnum]


  export const WebsitePageScalarFieldEnum: {
    id: 'id',
    websiteId: 'websiteId',
    slug: 'slug',
    title: 'title',
    content: 'content',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    isPublished: 'isPublished',
    isHomepage: 'isHomepage',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebsitePageScalarFieldEnum = (typeof WebsitePageScalarFieldEnum)[keyof typeof WebsitePageScalarFieldEnum]


  export const WebsiteSettingsScalarFieldEnum: {
    id: 'id',
    websiteId: 'websiteId',
    companyName: 'companyName',
    logo: 'logo',
    heroTitle: 'heroTitle',
    heroSubtitle: 'heroSubtitle',
    heroImage: 'heroImage',
    contactInfo: 'contactInfo',
    socialMedia: 'socialMedia',
    seoSettings: 'seoSettings',
    colorScheme: 'colorScheme',
    customCSS: 'customCSS',
    analyticsCode: 'analyticsCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebsiteSettingsScalarFieldEnum = (typeof WebsiteSettingsScalarFieldEnum)[keyof typeof WebsiteSettingsScalarFieldEnum]


  export const WebsiteSectionScalarFieldEnum: {
    id: 'id',
    websiteId: 'websiteId',
    sectionType: 'sectionType',
    title: 'title',
    content: 'content',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebsiteSectionScalarFieldEnum = (typeof WebsiteSectionScalarFieldEnum)[keyof typeof WebsiteSectionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    subdomain?: StringFilter<"Tenant"> | string
    companyName?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    isActive?: BoolFilter<"Tenant"> | boolean
    subscriptionPlan?: StringFilter<"Tenant"> | string
    websiteModuleEnabled?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    paymentAccountHolder?: StringNullableFilter<"Tenant"> | string | null
    paymentBank?: StringNullableFilter<"Tenant"> | string | null
    paymentIban?: StringNullableFilter<"Tenant"> | string | null
    activities?: ActivityListRelationFilter
    reservations?: ReservationListRelationFilter
    drivers?: DriverListRelationFilter
    hotelBookings?: HotelBookingListRelationFilter
    hotelPricePool?: HotelPricePoolListRelationFilter
    hotelRequests?: HotelRequestListRelationFilter
    modules?: TenantModuleListRelationFilter
    users?: TenantUserListRelationFilter
    tourBookings?: TourBookingListRelationFilter
    vehicles?: VehicleListRelationFilter
    websites?: TenantWebsiteListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    subdomain?: SortOrder
    companyName?: SortOrder
    domain?: SortOrderInput | SortOrder
    isActive?: SortOrder
    subscriptionPlan?: SortOrder
    websiteModuleEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentAccountHolder?: SortOrderInput | SortOrder
    paymentBank?: SortOrderInput | SortOrder
    paymentIban?: SortOrderInput | SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    drivers?: DriverOrderByRelationAggregateInput
    hotelBookings?: HotelBookingOrderByRelationAggregateInput
    hotelPricePool?: HotelPricePoolOrderByRelationAggregateInput
    hotelRequests?: HotelRequestOrderByRelationAggregateInput
    modules?: TenantModuleOrderByRelationAggregateInput
    users?: TenantUserOrderByRelationAggregateInput
    tourBookings?: TourBookingOrderByRelationAggregateInput
    vehicles?: VehicleOrderByRelationAggregateInput
    websites?: TenantWebsiteOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    companyName?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    isActive?: BoolFilter<"Tenant"> | boolean
    subscriptionPlan?: StringFilter<"Tenant"> | string
    websiteModuleEnabled?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    paymentAccountHolder?: StringNullableFilter<"Tenant"> | string | null
    paymentBank?: StringNullableFilter<"Tenant"> | string | null
    paymentIban?: StringNullableFilter<"Tenant"> | string | null
    activities?: ActivityListRelationFilter
    reservations?: ReservationListRelationFilter
    drivers?: DriverListRelationFilter
    hotelBookings?: HotelBookingListRelationFilter
    hotelPricePool?: HotelPricePoolListRelationFilter
    hotelRequests?: HotelRequestListRelationFilter
    modules?: TenantModuleListRelationFilter
    users?: TenantUserListRelationFilter
    tourBookings?: TourBookingListRelationFilter
    vehicles?: VehicleListRelationFilter
    websites?: TenantWebsiteListRelationFilter
  }, "id" | "subdomain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    subdomain?: SortOrder
    companyName?: SortOrder
    domain?: SortOrderInput | SortOrder
    isActive?: SortOrder
    subscriptionPlan?: SortOrder
    websiteModuleEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentAccountHolder?: SortOrderInput | SortOrder
    paymentBank?: SortOrderInput | SortOrder
    paymentIban?: SortOrderInput | SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    subdomain?: StringWithAggregatesFilter<"Tenant"> | string
    companyName?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    isActive?: BoolWithAggregatesFilter<"Tenant"> | boolean
    subscriptionPlan?: StringWithAggregatesFilter<"Tenant"> | string
    websiteModuleEnabled?: BoolWithAggregatesFilter<"Tenant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    paymentAccountHolder?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    paymentBank?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    paymentIban?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    isActive?: BoolFilter<"Module"> | boolean
    priceMonthly?: FloatFilter<"Module"> | number
    priceYearly?: FloatFilter<"Module"> | number
    features?: StringFilter<"Module"> | string
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    tenantModules?: TenantModuleListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantModules?: TenantModuleOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    description?: StringNullableFilter<"Module"> | string | null
    isActive?: BoolFilter<"Module"> | boolean
    priceMonthly?: FloatFilter<"Module"> | number
    priceYearly?: FloatFilter<"Module"> | number
    features?: StringFilter<"Module"> | string
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    tenantModules?: TenantModuleListRelationFilter
  }, "id" | "name">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Module"> | string
    name?: StringWithAggregatesFilter<"Module"> | string
    description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    isActive?: BoolWithAggregatesFilter<"Module"> | boolean
    priceMonthly?: FloatWithAggregatesFilter<"Module"> | number
    priceYearly?: FloatWithAggregatesFilter<"Module"> | number
    features?: StringWithAggregatesFilter<"Module"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
  }

  export type TenantModuleWhereInput = {
    AND?: TenantModuleWhereInput | TenantModuleWhereInput[]
    OR?: TenantModuleWhereInput[]
    NOT?: TenantModuleWhereInput | TenantModuleWhereInput[]
    id?: StringFilter<"TenantModule"> | string
    tenantId?: StringFilter<"TenantModule"> | string
    moduleId?: StringFilter<"TenantModule"> | string
    isEnabled?: BoolFilter<"TenantModule"> | boolean
    activatedAt?: DateTimeNullableFilter<"TenantModule"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"TenantModule"> | Date | string | null
    features?: StringFilter<"TenantModule"> | string
    createdAt?: DateTimeFilter<"TenantModule"> | Date | string
    updatedAt?: DateTimeFilter<"TenantModule"> | Date | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantModuleOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    moduleId?: SortOrder
    isEnabled?: SortOrder
    activatedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    module?: ModuleOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_moduleId?: TenantModuleTenantIdModuleIdCompoundUniqueInput
    AND?: TenantModuleWhereInput | TenantModuleWhereInput[]
    OR?: TenantModuleWhereInput[]
    NOT?: TenantModuleWhereInput | TenantModuleWhereInput[]
    tenantId?: StringFilter<"TenantModule"> | string
    moduleId?: StringFilter<"TenantModule"> | string
    isEnabled?: BoolFilter<"TenantModule"> | boolean
    activatedAt?: DateTimeNullableFilter<"TenantModule"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"TenantModule"> | Date | string | null
    features?: StringFilter<"TenantModule"> | string
    createdAt?: DateTimeFilter<"TenantModule"> | Date | string
    updatedAt?: DateTimeFilter<"TenantModule"> | Date | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_moduleId">

  export type TenantModuleOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    moduleId?: SortOrder
    isEnabled?: SortOrder
    activatedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantModuleCountOrderByAggregateInput
    _max?: TenantModuleMaxOrderByAggregateInput
    _min?: TenantModuleMinOrderByAggregateInput
  }

  export type TenantModuleScalarWhereWithAggregatesInput = {
    AND?: TenantModuleScalarWhereWithAggregatesInput | TenantModuleScalarWhereWithAggregatesInput[]
    OR?: TenantModuleScalarWhereWithAggregatesInput[]
    NOT?: TenantModuleScalarWhereWithAggregatesInput | TenantModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantModule"> | string
    tenantId?: StringWithAggregatesFilter<"TenantModule"> | string
    moduleId?: StringWithAggregatesFilter<"TenantModule"> | string
    isEnabled?: BoolWithAggregatesFilter<"TenantModule"> | boolean
    activatedAt?: DateTimeNullableWithAggregatesFilter<"TenantModule"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"TenantModule"> | Date | string | null
    features?: StringWithAggregatesFilter<"TenantModule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TenantModule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantModule"> | Date | string
  }

  export type TenantUserWhereInput = {
    AND?: TenantUserWhereInput | TenantUserWhereInput[]
    OR?: TenantUserWhereInput[]
    NOT?: TenantUserWhereInput | TenantUserWhereInput[]
    id?: StringFilter<"TenantUser"> | string
    tenantId?: StringFilter<"TenantUser"> | string
    userId?: StringFilter<"TenantUser"> | string
    role?: StringFilter<"TenantUser"> | string
    permissions?: StringFilter<"TenantUser"> | string
    isActive?: BoolFilter<"TenantUser"> | boolean
    createdAt?: DateTimeFilter<"TenantUser"> | Date | string
    updatedAt?: DateTimeFilter<"TenantUser"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TenantUserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TenantUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_userId?: TenantUserTenantIdUserIdCompoundUniqueInput
    AND?: TenantUserWhereInput | TenantUserWhereInput[]
    OR?: TenantUserWhereInput[]
    NOT?: TenantUserWhereInput | TenantUserWhereInput[]
    tenantId?: StringFilter<"TenantUser"> | string
    userId?: StringFilter<"TenantUser"> | string
    role?: StringFilter<"TenantUser"> | string
    permissions?: StringFilter<"TenantUser"> | string
    isActive?: BoolFilter<"TenantUser"> | boolean
    createdAt?: DateTimeFilter<"TenantUser"> | Date | string
    updatedAt?: DateTimeFilter<"TenantUser"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "tenantId_userId">

  export type TenantUserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantUserCountOrderByAggregateInput
    _max?: TenantUserMaxOrderByAggregateInput
    _min?: TenantUserMinOrderByAggregateInput
  }

  export type TenantUserScalarWhereWithAggregatesInput = {
    AND?: TenantUserScalarWhereWithAggregatesInput | TenantUserScalarWhereWithAggregatesInput[]
    OR?: TenantUserScalarWhereWithAggregatesInput[]
    NOT?: TenantUserScalarWhereWithAggregatesInput | TenantUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantUser"> | string
    tenantId?: StringWithAggregatesFilter<"TenantUser"> | string
    userId?: StringWithAggregatesFilter<"TenantUser"> | string
    role?: StringWithAggregatesFilter<"TenantUser"> | string
    permissions?: StringWithAggregatesFilter<"TenantUser"> | string
    isActive?: BoolWithAggregatesFilter<"TenantUser"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TenantUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantUser"> | Date | string
  }

  export type DriverWhereInput = {
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    id?: StringFilter<"Driver"> | string
    name?: StringFilter<"Driver"> | string
    phoneNumber?: StringNullableFilter<"Driver"> | string | null
    tenantId?: StringNullableFilter<"Driver"> | string | null
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    reservations?: ReservationListRelationFilter
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    tourBookings?: TourBookingListRelationFilter
  }

  export type DriverOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reservations?: ReservationOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    tourBookings?: TourBookingOrderByRelationAggregateInput
  }

  export type DriverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    name?: StringFilter<"Driver"> | string
    phoneNumber?: StringNullableFilter<"Driver"> | string | null
    tenantId?: StringNullableFilter<"Driver"> | string | null
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    reservations?: ReservationListRelationFilter
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    tourBookings?: TourBookingListRelationFilter
  }, "id">

  export type DriverOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DriverCountOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    OR?: DriverScalarWhereWithAggregatesInput[]
    NOT?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Driver"> | string
    name?: StringWithAggregatesFilter<"Driver"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdBy?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    activities?: ActivityListRelationFilter
    reservations?: ReservationListRelationFilter
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    permissions?: UserPermissionListRelationFilter
    hotelRequests?: HotelRequestListRelationFilter
    tenantUsers?: TenantUserListRelationFilter
    tour_bookings?: TourBookingListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    createdUsers?: UserOrderByRelationAggregateInput
    permissions?: UserPermissionOrderByRelationAggregateInput
    hotelRequests?: HotelRequestOrderByRelationAggregateInput
    tenantUsers?: TenantUserOrderByRelationAggregateInput
    tour_bookings?: TourBookingOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdBy?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    activities?: ActivityListRelationFilter
    reservations?: ReservationListRelationFilter
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    permissions?: UserPermissionListRelationFilter
    hotelRequests?: HotelRequestListRelationFilter
    tenantUsers?: TenantUserListRelationFilter
    tour_bookings?: TourBookingListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserPermissionWhereInput = {
    AND?: UserPermissionWhereInput | UserPermissionWhereInput[]
    OR?: UserPermissionWhereInput[]
    NOT?: UserPermissionWhereInput | UserPermissionWhereInput[]
    id?: StringFilter<"UserPermission"> | string
    userId?: StringFilter<"UserPermission"> | string
    permission?: StringFilter<"UserPermission"> | string
    grantedBy?: StringNullableFilter<"UserPermission"> | string | null
    grantedAt?: DateTimeFilter<"UserPermission"> | Date | string
    isActive?: BoolFilter<"UserPermission"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPermissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    grantedAt?: SortOrder
    isActive?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserPermissionWhereInput | UserPermissionWhereInput[]
    OR?: UserPermissionWhereInput[]
    NOT?: UserPermissionWhereInput | UserPermissionWhereInput[]
    userId?: StringFilter<"UserPermission"> | string
    permission?: StringFilter<"UserPermission"> | string
    grantedBy?: StringNullableFilter<"UserPermission"> | string | null
    grantedAt?: DateTimeFilter<"UserPermission"> | Date | string
    isActive?: BoolFilter<"UserPermission"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    grantedAt?: SortOrder
    isActive?: SortOrder
    _count?: UserPermissionCountOrderByAggregateInput
    _max?: UserPermissionMaxOrderByAggregateInput
    _min?: UserPermissionMinOrderByAggregateInput
  }

  export type UserPermissionScalarWhereWithAggregatesInput = {
    AND?: UserPermissionScalarWhereWithAggregatesInput | UserPermissionScalarWhereWithAggregatesInput[]
    OR?: UserPermissionScalarWhereWithAggregatesInput[]
    NOT?: UserPermissionScalarWhereWithAggregatesInput | UserPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPermission"> | string
    userId?: StringWithAggregatesFilter<"UserPermission"> | string
    permission?: StringWithAggregatesFilter<"UserPermission"> | string
    grantedBy?: StringNullableWithAggregatesFilter<"UserPermission"> | string | null
    grantedAt?: DateTimeWithAggregatesFilter<"UserPermission"> | Date | string
    isActive?: BoolWithAggregatesFilter<"UserPermission"> | boolean
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    entityType?: StringFilter<"Activity"> | string
    entityId?: StringNullableFilter<"Activity"> | string | null
    description?: StringFilter<"Activity"> | string
    details?: JsonNullableFilter<"Activity">
    ipAddress?: StringNullableFilter<"Activity"> | string | null
    userAgent?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    tenantId?: StringNullableFilter<"Activity"> | string | null
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    description?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    userId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    entityType?: StringFilter<"Activity"> | string
    entityId?: StringNullableFilter<"Activity"> | string | null
    description?: StringFilter<"Activity"> | string
    details?: JsonNullableFilter<"Activity">
    ipAddress?: StringNullableFilter<"Activity"> | string | null
    userAgent?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    tenantId?: StringNullableFilter<"Activity"> | string | null
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    description?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    userId?: StringWithAggregatesFilter<"Activity"> | string
    action?: StringWithAggregatesFilter<"Activity"> | string
    entityType?: StringWithAggregatesFilter<"Activity"> | string
    entityId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    description?: StringWithAggregatesFilter<"Activity"> | string
    details?: JsonNullableWithAggregatesFilter<"Activity">
    ipAddress?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    tenantId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: StringFilter<"Reservation"> | string
    date?: StringFilter<"Reservation"> | string
    time?: StringFilter<"Reservation"> | string
    from?: StringFilter<"Reservation"> | string
    to?: StringFilter<"Reservation"> | string
    flightCode?: StringFilter<"Reservation"> | string
    passengerNames?: StringFilter<"Reservation"> | string
    luggageCount?: IntFilter<"Reservation"> | number
    price?: FloatFilter<"Reservation"> | number
    currency?: StringFilter<"Reservation"> | string
    phoneNumber?: StringNullableFilter<"Reservation"> | string | null
    voucherNumber?: StringFilter<"Reservation"> | string
    driverFee?: FloatNullableFilter<"Reservation"> | number | null
    driverId?: StringNullableFilter<"Reservation"> | string | null
    paymentStatus?: StringFilter<"Reservation"> | string
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    returnTransferId?: StringNullableFilter<"Reservation"> | string | null
    isReturn?: BoolFilter<"Reservation"> | boolean
    distanceKm?: FloatNullableFilter<"Reservation"> | number | null
    userId?: StringNullableFilter<"Reservation"> | string | null
    tenantId?: StringNullableFilter<"Reservation"> | string | null
    companyCommissionStatus?: StringFilter<"Reservation"> | string
    notes?: StringNullableFilter<"Reservation"> | string | null
    email?: StringNullableFilter<"Reservation"> | string | null
    type?: StringFilter<"Reservation"> | string
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    returnTransfer?: XOR<ReservationNullableScalarRelationFilter, ReservationWhereInput> | null
    originalTransfer?: XOR<ReservationNullableScalarRelationFilter, ReservationWhereInput> | null
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    hotelBookings?: HotelBookingListRelationFilter
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    from?: SortOrder
    to?: SortOrder
    flightCode?: SortOrder
    passengerNames?: SortOrder
    luggageCount?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    voucherNumber?: SortOrder
    driverFee?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    returnTransferId?: SortOrderInput | SortOrder
    isReturn?: SortOrder
    distanceKm?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    companyCommissionStatus?: SortOrder
    notes?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    type?: SortOrder
    driver?: DriverOrderByWithRelationInput
    returnTransfer?: ReservationOrderByWithRelationInput
    originalTransfer?: ReservationOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    hotelBookings?: HotelBookingOrderByRelationAggregateInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    voucherNumber?: string
    returnTransferId?: string
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    date?: StringFilter<"Reservation"> | string
    time?: StringFilter<"Reservation"> | string
    from?: StringFilter<"Reservation"> | string
    to?: StringFilter<"Reservation"> | string
    flightCode?: StringFilter<"Reservation"> | string
    passengerNames?: StringFilter<"Reservation"> | string
    luggageCount?: IntFilter<"Reservation"> | number
    price?: FloatFilter<"Reservation"> | number
    currency?: StringFilter<"Reservation"> | string
    phoneNumber?: StringNullableFilter<"Reservation"> | string | null
    driverFee?: FloatNullableFilter<"Reservation"> | number | null
    driverId?: StringNullableFilter<"Reservation"> | string | null
    paymentStatus?: StringFilter<"Reservation"> | string
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    isReturn?: BoolFilter<"Reservation"> | boolean
    distanceKm?: FloatNullableFilter<"Reservation"> | number | null
    userId?: StringNullableFilter<"Reservation"> | string | null
    tenantId?: StringNullableFilter<"Reservation"> | string | null
    companyCommissionStatus?: StringFilter<"Reservation"> | string
    notes?: StringNullableFilter<"Reservation"> | string | null
    email?: StringNullableFilter<"Reservation"> | string | null
    type?: StringFilter<"Reservation"> | string
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    returnTransfer?: XOR<ReservationNullableScalarRelationFilter, ReservationWhereInput> | null
    originalTransfer?: XOR<ReservationNullableScalarRelationFilter, ReservationWhereInput> | null
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    hotelBookings?: HotelBookingListRelationFilter
  }, "id" | "voucherNumber" | "returnTransferId">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    from?: SortOrder
    to?: SortOrder
    flightCode?: SortOrder
    passengerNames?: SortOrder
    luggageCount?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    voucherNumber?: SortOrder
    driverFee?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    returnTransferId?: SortOrderInput | SortOrder
    isReturn?: SortOrder
    distanceKm?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    companyCommissionStatus?: SortOrder
    notes?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _avg?: ReservationAvgOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
    _sum?: ReservationSumOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reservation"> | string
    date?: StringWithAggregatesFilter<"Reservation"> | string
    time?: StringWithAggregatesFilter<"Reservation"> | string
    from?: StringWithAggregatesFilter<"Reservation"> | string
    to?: StringWithAggregatesFilter<"Reservation"> | string
    flightCode?: StringWithAggregatesFilter<"Reservation"> | string
    passengerNames?: StringWithAggregatesFilter<"Reservation"> | string
    luggageCount?: IntWithAggregatesFilter<"Reservation"> | number
    price?: FloatWithAggregatesFilter<"Reservation"> | number
    currency?: StringWithAggregatesFilter<"Reservation"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    voucherNumber?: StringWithAggregatesFilter<"Reservation"> | string
    driverFee?: FloatNullableWithAggregatesFilter<"Reservation"> | number | null
    driverId?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    paymentStatus?: StringWithAggregatesFilter<"Reservation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    returnTransferId?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    isReturn?: BoolWithAggregatesFilter<"Reservation"> | boolean
    distanceKm?: FloatNullableWithAggregatesFilter<"Reservation"> | number | null
    userId?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    companyCommissionStatus?: StringWithAggregatesFilter<"Reservation"> | string
    notes?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    email?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    type?: StringWithAggregatesFilter<"Reservation"> | string
  }

  export type HotelRequestWhereInput = {
    AND?: HotelRequestWhereInput | HotelRequestWhereInput[]
    OR?: HotelRequestWhereInput[]
    NOT?: HotelRequestWhereInput | HotelRequestWhereInput[]
    id?: StringFilter<"HotelRequest"> | string
    tenantId?: StringNullableFilter<"HotelRequest"> | string | null
    customerName?: StringFilter<"HotelRequest"> | string
    customerEmail?: StringFilter<"HotelRequest"> | string
    customerPhone?: StringFilter<"HotelRequest"> | string
    checkin?: DateTimeFilter<"HotelRequest"> | Date | string
    checkout?: DateTimeFilter<"HotelRequest"> | Date | string
    adults?: IntFilter<"HotelRequest"> | number
    children?: IntFilter<"HotelRequest"> | number
    rooms?: IntFilter<"HotelRequest"> | number
    city?: StringFilter<"HotelRequest"> | string
    region?: StringNullableFilter<"HotelRequest"> | string | null
    budget?: FloatNullableFilter<"HotelRequest"> | number | null
    roomType?: StringNullableFilter<"HotelRequest"> | string | null
    breakfast?: BoolFilter<"HotelRequest"> | boolean
    amenities?: StringFilter<"HotelRequest"> | string
    specialRequests?: StringNullableFilter<"HotelRequest"> | string | null
    status?: StringFilter<"HotelRequest"> | string
    assignedTo?: StringNullableFilter<"HotelRequest"> | string | null
    createdAt?: DateTimeFilter<"HotelRequest"> | Date | string
    updatedAt?: DateTimeFilter<"HotelRequest"> | Date | string
    hotelBookings?: HotelBookingListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
  }

  export type HotelRequestOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    checkin?: SortOrder
    checkout?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    city?: SortOrder
    region?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    roomType?: SortOrderInput | SortOrder
    breakfast?: SortOrder
    amenities?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelBookings?: HotelBookingOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type HotelRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelRequestWhereInput | HotelRequestWhereInput[]
    OR?: HotelRequestWhereInput[]
    NOT?: HotelRequestWhereInput | HotelRequestWhereInput[]
    tenantId?: StringNullableFilter<"HotelRequest"> | string | null
    customerName?: StringFilter<"HotelRequest"> | string
    customerEmail?: StringFilter<"HotelRequest"> | string
    customerPhone?: StringFilter<"HotelRequest"> | string
    checkin?: DateTimeFilter<"HotelRequest"> | Date | string
    checkout?: DateTimeFilter<"HotelRequest"> | Date | string
    adults?: IntFilter<"HotelRequest"> | number
    children?: IntFilter<"HotelRequest"> | number
    rooms?: IntFilter<"HotelRequest"> | number
    city?: StringFilter<"HotelRequest"> | string
    region?: StringNullableFilter<"HotelRequest"> | string | null
    budget?: FloatNullableFilter<"HotelRequest"> | number | null
    roomType?: StringNullableFilter<"HotelRequest"> | string | null
    breakfast?: BoolFilter<"HotelRequest"> | boolean
    amenities?: StringFilter<"HotelRequest"> | string
    specialRequests?: StringNullableFilter<"HotelRequest"> | string | null
    status?: StringFilter<"HotelRequest"> | string
    assignedTo?: StringNullableFilter<"HotelRequest"> | string | null
    createdAt?: DateTimeFilter<"HotelRequest"> | Date | string
    updatedAt?: DateTimeFilter<"HotelRequest"> | Date | string
    hotelBookings?: HotelBookingListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
  }, "id">

  export type HotelRequestOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    checkin?: SortOrder
    checkout?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    city?: SortOrder
    region?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    roomType?: SortOrderInput | SortOrder
    breakfast?: SortOrder
    amenities?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelRequestCountOrderByAggregateInput
    _avg?: HotelRequestAvgOrderByAggregateInput
    _max?: HotelRequestMaxOrderByAggregateInput
    _min?: HotelRequestMinOrderByAggregateInput
    _sum?: HotelRequestSumOrderByAggregateInput
  }

  export type HotelRequestScalarWhereWithAggregatesInput = {
    AND?: HotelRequestScalarWhereWithAggregatesInput | HotelRequestScalarWhereWithAggregatesInput[]
    OR?: HotelRequestScalarWhereWithAggregatesInput[]
    NOT?: HotelRequestScalarWhereWithAggregatesInput | HotelRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelRequest"> | string
    tenantId?: StringNullableWithAggregatesFilter<"HotelRequest"> | string | null
    customerName?: StringWithAggregatesFilter<"HotelRequest"> | string
    customerEmail?: StringWithAggregatesFilter<"HotelRequest"> | string
    customerPhone?: StringWithAggregatesFilter<"HotelRequest"> | string
    checkin?: DateTimeWithAggregatesFilter<"HotelRequest"> | Date | string
    checkout?: DateTimeWithAggregatesFilter<"HotelRequest"> | Date | string
    adults?: IntWithAggregatesFilter<"HotelRequest"> | number
    children?: IntWithAggregatesFilter<"HotelRequest"> | number
    rooms?: IntWithAggregatesFilter<"HotelRequest"> | number
    city?: StringWithAggregatesFilter<"HotelRequest"> | string
    region?: StringNullableWithAggregatesFilter<"HotelRequest"> | string | null
    budget?: FloatNullableWithAggregatesFilter<"HotelRequest"> | number | null
    roomType?: StringNullableWithAggregatesFilter<"HotelRequest"> | string | null
    breakfast?: BoolWithAggregatesFilter<"HotelRequest"> | boolean
    amenities?: StringWithAggregatesFilter<"HotelRequest"> | string
    specialRequests?: StringNullableWithAggregatesFilter<"HotelRequest"> | string | null
    status?: StringWithAggregatesFilter<"HotelRequest"> | string
    assignedTo?: StringNullableWithAggregatesFilter<"HotelRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelRequest"> | Date | string
  }

  export type HotelBookingWhereInput = {
    AND?: HotelBookingWhereInput | HotelBookingWhereInput[]
    OR?: HotelBookingWhereInput[]
    NOT?: HotelBookingWhereInput | HotelBookingWhereInput[]
    id?: StringFilter<"HotelBooking"> | string
    tenantId?: StringNullableFilter<"HotelBooking"> | string | null
    requestId?: StringNullableFilter<"HotelBooking"> | string | null
    reservationId?: StringNullableFilter<"HotelBooking"> | string | null
    hotelId?: StringFilter<"HotelBooking"> | string
    hotelName?: StringFilter<"HotelBooking"> | string
    hotelAddress?: StringFilter<"HotelBooking"> | string
    roomType?: StringFilter<"HotelBooking"> | string
    checkin?: DateTimeFilter<"HotelBooking"> | Date | string
    checkout?: DateTimeFilter<"HotelBooking"> | Date | string
    adults?: IntFilter<"HotelBooking"> | number
    children?: IntFilter<"HotelBooking"> | number
    rooms?: IntFilter<"HotelBooking"> | number
    totalPrice?: FloatFilter<"HotelBooking"> | number
    currency?: StringFilter<"HotelBooking"> | string
    bookingReference?: StringFilter<"HotelBooking"> | string
    status?: StringFilter<"HotelBooking"> | string
    customerInfo?: JsonFilter<"HotelBooking">
    specialRequests?: StringNullableFilter<"HotelBooking"> | string | null
    cancellationPolicy?: StringNullableFilter<"HotelBooking"> | string | null
    createdAt?: DateTimeFilter<"HotelBooking"> | Date | string
    updatedAt?: DateTimeFilter<"HotelBooking"> | Date | string
    agentPrice?: FloatFilter<"HotelBooking"> | number
    customerPrice?: FloatFilter<"HotelBooking"> | number
    profitMargin?: FloatFilter<"HotelBooking"> | number
    voucherNumber?: StringFilter<"HotelBooking"> | string
    request?: XOR<HotelRequestNullableScalarRelationFilter, HotelRequestWhereInput> | null
    reservation?: XOR<ReservationNullableScalarRelationFilter, ReservationWhereInput> | null
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
  }

  export type HotelBookingOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    reservationId?: SortOrderInput | SortOrder
    hotelId?: SortOrder
    hotelName?: SortOrder
    hotelAddress?: SortOrder
    roomType?: SortOrder
    checkin?: SortOrder
    checkout?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    bookingReference?: SortOrder
    status?: SortOrder
    customerInfo?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    voucherNumber?: SortOrder
    request?: HotelRequestOrderByWithRelationInput
    reservation?: ReservationOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type HotelBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingReference?: string
    voucherNumber?: string
    AND?: HotelBookingWhereInput | HotelBookingWhereInput[]
    OR?: HotelBookingWhereInput[]
    NOT?: HotelBookingWhereInput | HotelBookingWhereInput[]
    tenantId?: StringNullableFilter<"HotelBooking"> | string | null
    requestId?: StringNullableFilter<"HotelBooking"> | string | null
    reservationId?: StringNullableFilter<"HotelBooking"> | string | null
    hotelId?: StringFilter<"HotelBooking"> | string
    hotelName?: StringFilter<"HotelBooking"> | string
    hotelAddress?: StringFilter<"HotelBooking"> | string
    roomType?: StringFilter<"HotelBooking"> | string
    checkin?: DateTimeFilter<"HotelBooking"> | Date | string
    checkout?: DateTimeFilter<"HotelBooking"> | Date | string
    adults?: IntFilter<"HotelBooking"> | number
    children?: IntFilter<"HotelBooking"> | number
    rooms?: IntFilter<"HotelBooking"> | number
    totalPrice?: FloatFilter<"HotelBooking"> | number
    currency?: StringFilter<"HotelBooking"> | string
    status?: StringFilter<"HotelBooking"> | string
    customerInfo?: JsonFilter<"HotelBooking">
    specialRequests?: StringNullableFilter<"HotelBooking"> | string | null
    cancellationPolicy?: StringNullableFilter<"HotelBooking"> | string | null
    createdAt?: DateTimeFilter<"HotelBooking"> | Date | string
    updatedAt?: DateTimeFilter<"HotelBooking"> | Date | string
    agentPrice?: FloatFilter<"HotelBooking"> | number
    customerPrice?: FloatFilter<"HotelBooking"> | number
    profitMargin?: FloatFilter<"HotelBooking"> | number
    request?: XOR<HotelRequestNullableScalarRelationFilter, HotelRequestWhereInput> | null
    reservation?: XOR<ReservationNullableScalarRelationFilter, ReservationWhereInput> | null
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
  }, "id" | "bookingReference" | "voucherNumber">

  export type HotelBookingOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    reservationId?: SortOrderInput | SortOrder
    hotelId?: SortOrder
    hotelName?: SortOrder
    hotelAddress?: SortOrder
    roomType?: SortOrder
    checkin?: SortOrder
    checkout?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    bookingReference?: SortOrder
    status?: SortOrder
    customerInfo?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    voucherNumber?: SortOrder
    _count?: HotelBookingCountOrderByAggregateInput
    _avg?: HotelBookingAvgOrderByAggregateInput
    _max?: HotelBookingMaxOrderByAggregateInput
    _min?: HotelBookingMinOrderByAggregateInput
    _sum?: HotelBookingSumOrderByAggregateInput
  }

  export type HotelBookingScalarWhereWithAggregatesInput = {
    AND?: HotelBookingScalarWhereWithAggregatesInput | HotelBookingScalarWhereWithAggregatesInput[]
    OR?: HotelBookingScalarWhereWithAggregatesInput[]
    NOT?: HotelBookingScalarWhereWithAggregatesInput | HotelBookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelBooking"> | string
    tenantId?: StringNullableWithAggregatesFilter<"HotelBooking"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"HotelBooking"> | string | null
    reservationId?: StringNullableWithAggregatesFilter<"HotelBooking"> | string | null
    hotelId?: StringWithAggregatesFilter<"HotelBooking"> | string
    hotelName?: StringWithAggregatesFilter<"HotelBooking"> | string
    hotelAddress?: StringWithAggregatesFilter<"HotelBooking"> | string
    roomType?: StringWithAggregatesFilter<"HotelBooking"> | string
    checkin?: DateTimeWithAggregatesFilter<"HotelBooking"> | Date | string
    checkout?: DateTimeWithAggregatesFilter<"HotelBooking"> | Date | string
    adults?: IntWithAggregatesFilter<"HotelBooking"> | number
    children?: IntWithAggregatesFilter<"HotelBooking"> | number
    rooms?: IntWithAggregatesFilter<"HotelBooking"> | number
    totalPrice?: FloatWithAggregatesFilter<"HotelBooking"> | number
    currency?: StringWithAggregatesFilter<"HotelBooking"> | string
    bookingReference?: StringWithAggregatesFilter<"HotelBooking"> | string
    status?: StringWithAggregatesFilter<"HotelBooking"> | string
    customerInfo?: JsonWithAggregatesFilter<"HotelBooking">
    specialRequests?: StringNullableWithAggregatesFilter<"HotelBooking"> | string | null
    cancellationPolicy?: StringNullableWithAggregatesFilter<"HotelBooking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelBooking"> | Date | string
    agentPrice?: FloatWithAggregatesFilter<"HotelBooking"> | number
    customerPrice?: FloatWithAggregatesFilter<"HotelBooking"> | number
    profitMargin?: FloatWithAggregatesFilter<"HotelBooking"> | number
    voucherNumber?: StringWithAggregatesFilter<"HotelBooking"> | string
  }

  export type HotelPricePoolWhereInput = {
    AND?: HotelPricePoolWhereInput | HotelPricePoolWhereInput[]
    OR?: HotelPricePoolWhereInput[]
    NOT?: HotelPricePoolWhereInput | HotelPricePoolWhereInput[]
    id?: StringFilter<"HotelPricePool"> | string
    tenantId?: StringFilter<"HotelPricePool"> | string
    hotelId?: StringFilter<"HotelPricePool"> | string
    hotelName?: StringFilter<"HotelPricePool"> | string
    hotelAddress?: StringFilter<"HotelPricePool"> | string
    hotelCity?: StringFilter<"HotelPricePool"> | string
    hotelCountry?: StringFilter<"HotelPricePool"> | string
    hotelRating?: FloatFilter<"HotelPricePool"> | number
    hotelStars?: IntFilter<"HotelPricePool"> | number
    hotelImage?: StringNullableFilter<"HotelPricePool"> | string | null
    hotelAmenities?: StringFilter<"HotelPricePool"> | string
    roomType?: StringFilter<"HotelPricePool"> | string
    roomName?: StringFilter<"HotelPricePool"> | string
    roomDescription?: StringNullableFilter<"HotelPricePool"> | string | null
    roomAmenities?: StringFilter<"HotelPricePool"> | string
    maxOccupancy?: IntFilter<"HotelPricePool"> | number
    bedType?: StringFilter<"HotelPricePool"> | string
    roomSize?: StringNullableFilter<"HotelPricePool"> | string | null
    roomView?: StringNullableFilter<"HotelPricePool"> | string | null
    basePrice?: FloatFilter<"HotelPricePool"> | number
    agentPrice?: FloatFilter<"HotelPricePool"> | number
    customerPrice?: FloatFilter<"HotelPricePool"> | number
    profitMargin?: FloatFilter<"HotelPricePool"> | number
    profitPercentage?: FloatFilter<"HotelPricePool"> | number
    currency?: StringFilter<"HotelPricePool"> | string
    validFrom?: DateTimeFilter<"HotelPricePool"> | Date | string
    validTo?: DateTimeFilter<"HotelPricePool"> | Date | string
    cancellationPolicy?: StringNullableFilter<"HotelPricePool"> | string | null
    breakfastIncluded?: BoolFilter<"HotelPricePool"> | boolean
    freeCancellation?: BoolFilter<"HotelPricePool"> | boolean
    source?: StringFilter<"HotelPricePool"> | string
    lastUpdated?: DateTimeFilter<"HotelPricePool"> | Date | string
    updatedBy?: StringFilter<"HotelPricePool"> | string
    isActive?: BoolFilter<"HotelPricePool"> | boolean
    createdAt?: DateTimeFilter<"HotelPricePool"> | Date | string
    updatedAt?: DateTimeFilter<"HotelPricePool"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type HotelPricePoolOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    hotelId?: SortOrder
    hotelName?: SortOrder
    hotelAddress?: SortOrder
    hotelCity?: SortOrder
    hotelCountry?: SortOrder
    hotelRating?: SortOrder
    hotelStars?: SortOrder
    hotelImage?: SortOrderInput | SortOrder
    hotelAmenities?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    roomDescription?: SortOrderInput | SortOrder
    roomAmenities?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrderInput | SortOrder
    roomView?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    profitPercentage?: SortOrder
    currency?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    breakfastIncluded?: SortOrder
    freeCancellation?: SortOrder
    source?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type HotelPricePoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelPricePoolWhereInput | HotelPricePoolWhereInput[]
    OR?: HotelPricePoolWhereInput[]
    NOT?: HotelPricePoolWhereInput | HotelPricePoolWhereInput[]
    tenantId?: StringFilter<"HotelPricePool"> | string
    hotelId?: StringFilter<"HotelPricePool"> | string
    hotelName?: StringFilter<"HotelPricePool"> | string
    hotelAddress?: StringFilter<"HotelPricePool"> | string
    hotelCity?: StringFilter<"HotelPricePool"> | string
    hotelCountry?: StringFilter<"HotelPricePool"> | string
    hotelRating?: FloatFilter<"HotelPricePool"> | number
    hotelStars?: IntFilter<"HotelPricePool"> | number
    hotelImage?: StringNullableFilter<"HotelPricePool"> | string | null
    hotelAmenities?: StringFilter<"HotelPricePool"> | string
    roomType?: StringFilter<"HotelPricePool"> | string
    roomName?: StringFilter<"HotelPricePool"> | string
    roomDescription?: StringNullableFilter<"HotelPricePool"> | string | null
    roomAmenities?: StringFilter<"HotelPricePool"> | string
    maxOccupancy?: IntFilter<"HotelPricePool"> | number
    bedType?: StringFilter<"HotelPricePool"> | string
    roomSize?: StringNullableFilter<"HotelPricePool"> | string | null
    roomView?: StringNullableFilter<"HotelPricePool"> | string | null
    basePrice?: FloatFilter<"HotelPricePool"> | number
    agentPrice?: FloatFilter<"HotelPricePool"> | number
    customerPrice?: FloatFilter<"HotelPricePool"> | number
    profitMargin?: FloatFilter<"HotelPricePool"> | number
    profitPercentage?: FloatFilter<"HotelPricePool"> | number
    currency?: StringFilter<"HotelPricePool"> | string
    validFrom?: DateTimeFilter<"HotelPricePool"> | Date | string
    validTo?: DateTimeFilter<"HotelPricePool"> | Date | string
    cancellationPolicy?: StringNullableFilter<"HotelPricePool"> | string | null
    breakfastIncluded?: BoolFilter<"HotelPricePool"> | boolean
    freeCancellation?: BoolFilter<"HotelPricePool"> | boolean
    source?: StringFilter<"HotelPricePool"> | string
    lastUpdated?: DateTimeFilter<"HotelPricePool"> | Date | string
    updatedBy?: StringFilter<"HotelPricePool"> | string
    isActive?: BoolFilter<"HotelPricePool"> | boolean
    createdAt?: DateTimeFilter<"HotelPricePool"> | Date | string
    updatedAt?: DateTimeFilter<"HotelPricePool"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type HotelPricePoolOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    hotelId?: SortOrder
    hotelName?: SortOrder
    hotelAddress?: SortOrder
    hotelCity?: SortOrder
    hotelCountry?: SortOrder
    hotelRating?: SortOrder
    hotelStars?: SortOrder
    hotelImage?: SortOrderInput | SortOrder
    hotelAmenities?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    roomDescription?: SortOrderInput | SortOrder
    roomAmenities?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrderInput | SortOrder
    roomView?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    profitPercentage?: SortOrder
    currency?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    breakfastIncluded?: SortOrder
    freeCancellation?: SortOrder
    source?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelPricePoolCountOrderByAggregateInput
    _avg?: HotelPricePoolAvgOrderByAggregateInput
    _max?: HotelPricePoolMaxOrderByAggregateInput
    _min?: HotelPricePoolMinOrderByAggregateInput
    _sum?: HotelPricePoolSumOrderByAggregateInput
  }

  export type HotelPricePoolScalarWhereWithAggregatesInput = {
    AND?: HotelPricePoolScalarWhereWithAggregatesInput | HotelPricePoolScalarWhereWithAggregatesInput[]
    OR?: HotelPricePoolScalarWhereWithAggregatesInput[]
    NOT?: HotelPricePoolScalarWhereWithAggregatesInput | HotelPricePoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelPricePool"> | string
    tenantId?: StringWithAggregatesFilter<"HotelPricePool"> | string
    hotelId?: StringWithAggregatesFilter<"HotelPricePool"> | string
    hotelName?: StringWithAggregatesFilter<"HotelPricePool"> | string
    hotelAddress?: StringWithAggregatesFilter<"HotelPricePool"> | string
    hotelCity?: StringWithAggregatesFilter<"HotelPricePool"> | string
    hotelCountry?: StringWithAggregatesFilter<"HotelPricePool"> | string
    hotelRating?: FloatWithAggregatesFilter<"HotelPricePool"> | number
    hotelStars?: IntWithAggregatesFilter<"HotelPricePool"> | number
    hotelImage?: StringNullableWithAggregatesFilter<"HotelPricePool"> | string | null
    hotelAmenities?: StringWithAggregatesFilter<"HotelPricePool"> | string
    roomType?: StringWithAggregatesFilter<"HotelPricePool"> | string
    roomName?: StringWithAggregatesFilter<"HotelPricePool"> | string
    roomDescription?: StringNullableWithAggregatesFilter<"HotelPricePool"> | string | null
    roomAmenities?: StringWithAggregatesFilter<"HotelPricePool"> | string
    maxOccupancy?: IntWithAggregatesFilter<"HotelPricePool"> | number
    bedType?: StringWithAggregatesFilter<"HotelPricePool"> | string
    roomSize?: StringNullableWithAggregatesFilter<"HotelPricePool"> | string | null
    roomView?: StringNullableWithAggregatesFilter<"HotelPricePool"> | string | null
    basePrice?: FloatWithAggregatesFilter<"HotelPricePool"> | number
    agentPrice?: FloatWithAggregatesFilter<"HotelPricePool"> | number
    customerPrice?: FloatWithAggregatesFilter<"HotelPricePool"> | number
    profitMargin?: FloatWithAggregatesFilter<"HotelPricePool"> | number
    profitPercentage?: FloatWithAggregatesFilter<"HotelPricePool"> | number
    currency?: StringWithAggregatesFilter<"HotelPricePool"> | string
    validFrom?: DateTimeWithAggregatesFilter<"HotelPricePool"> | Date | string
    validTo?: DateTimeWithAggregatesFilter<"HotelPricePool"> | Date | string
    cancellationPolicy?: StringNullableWithAggregatesFilter<"HotelPricePool"> | string | null
    breakfastIncluded?: BoolWithAggregatesFilter<"HotelPricePool"> | boolean
    freeCancellation?: BoolWithAggregatesFilter<"HotelPricePool"> | boolean
    source?: StringWithAggregatesFilter<"HotelPricePool"> | string
    lastUpdated?: DateTimeWithAggregatesFilter<"HotelPricePool"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"HotelPricePool"> | string
    isActive?: BoolWithAggregatesFilter<"HotelPricePool"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"HotelPricePool"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelPricePool"> | Date | string
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    type?: StringFilter<"Vehicle"> | string
    capacity?: IntFilter<"Vehicle"> | number
    licensePlate?: StringFilter<"Vehicle"> | string
    driverName?: StringNullableFilter<"Vehicle"> | string | null
    driverPhone?: StringNullableFilter<"Vehicle"> | string | null
    isAvailable?: BoolFilter<"Vehicle"> | boolean
    lastMaintenance?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    tenantId?: StringFilter<"Vehicle"> | string
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    licensePlate?: SortOrder
    driverName?: SortOrderInput | SortOrder
    driverPhone?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    lastMaintenance?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    type?: StringFilter<"Vehicle"> | string
    capacity?: IntFilter<"Vehicle"> | number
    licensePlate?: StringFilter<"Vehicle"> | string
    driverName?: StringNullableFilter<"Vehicle"> | string | null
    driverPhone?: StringNullableFilter<"Vehicle"> | string | null
    isAvailable?: BoolFilter<"Vehicle"> | boolean
    lastMaintenance?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    tenantId?: StringFilter<"Vehicle"> | string
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    licensePlate?: SortOrder
    driverName?: SortOrderInput | SortOrder
    driverPhone?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    lastMaintenance?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vehicle"> | string
    type?: StringWithAggregatesFilter<"Vehicle"> | string
    capacity?: IntWithAggregatesFilter<"Vehicle"> | number
    licensePlate?: StringWithAggregatesFilter<"Vehicle"> | string
    driverName?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    driverPhone?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    isAvailable?: BoolWithAggregatesFilter<"Vehicle"> | boolean
    lastMaintenance?: DateTimeNullableWithAggregatesFilter<"Vehicle"> | Date | string | null
    tenantId?: StringWithAggregatesFilter<"Vehicle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
  }

  export type TourBookingWhereInput = {
    AND?: TourBookingWhereInput | TourBookingWhereInput[]
    OR?: TourBookingWhereInput[]
    NOT?: TourBookingWhereInput | TourBookingWhereInput[]
    id?: StringFilter<"TourBooking"> | string
    voucherNumber?: StringFilter<"TourBooking"> | string
    routeName?: StringFilter<"TourBooking"> | string
    vehicleType?: StringFilter<"TourBooking"> | string
    groupSize?: IntFilter<"TourBooking"> | number
    price?: FloatFilter<"TourBooking"> | number
    currency?: StringFilter<"TourBooking"> | string
    pickupLocation?: StringFilter<"TourBooking"> | string
    tourDate?: DateTimeFilter<"TourBooking"> | Date | string
    tourTime?: StringNullableFilter<"TourBooking"> | string | null
    passengerNames?: StringFilter<"TourBooking"> | string
    notes?: StringNullableFilter<"TourBooking"> | string | null
    status?: StringFilter<"TourBooking"> | string
    tenantId?: StringFilter<"TourBooking"> | string
    userId?: StringNullableFilter<"TourBooking"> | string | null
    driverId?: StringNullableFilter<"TourBooking"> | string | null
    driverFee?: FloatNullableFilter<"TourBooking"> | number | null
    createdAt?: DateTimeFilter<"TourBooking"> | Date | string
    updatedAt?: DateTimeFilter<"TourBooking"> | Date | string
    tourDuration?: IntFilter<"TourBooking"> | number
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TourBookingOrderByWithRelationInput = {
    id?: SortOrder
    voucherNumber?: SortOrder
    routeName?: SortOrder
    vehicleType?: SortOrder
    groupSize?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    pickupLocation?: SortOrder
    tourDate?: SortOrder
    tourTime?: SortOrderInput | SortOrder
    passengerNames?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    driverFee?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourDuration?: SortOrder
    driver?: DriverOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type TourBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    voucherNumber?: string
    AND?: TourBookingWhereInput | TourBookingWhereInput[]
    OR?: TourBookingWhereInput[]
    NOT?: TourBookingWhereInput | TourBookingWhereInput[]
    routeName?: StringFilter<"TourBooking"> | string
    vehicleType?: StringFilter<"TourBooking"> | string
    groupSize?: IntFilter<"TourBooking"> | number
    price?: FloatFilter<"TourBooking"> | number
    currency?: StringFilter<"TourBooking"> | string
    pickupLocation?: StringFilter<"TourBooking"> | string
    tourDate?: DateTimeFilter<"TourBooking"> | Date | string
    tourTime?: StringNullableFilter<"TourBooking"> | string | null
    passengerNames?: StringFilter<"TourBooking"> | string
    notes?: StringNullableFilter<"TourBooking"> | string | null
    status?: StringFilter<"TourBooking"> | string
    tenantId?: StringFilter<"TourBooking"> | string
    userId?: StringNullableFilter<"TourBooking"> | string | null
    driverId?: StringNullableFilter<"TourBooking"> | string | null
    driverFee?: FloatNullableFilter<"TourBooking"> | number | null
    createdAt?: DateTimeFilter<"TourBooking"> | Date | string
    updatedAt?: DateTimeFilter<"TourBooking"> | Date | string
    tourDuration?: IntFilter<"TourBooking"> | number
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "voucherNumber">

  export type TourBookingOrderByWithAggregationInput = {
    id?: SortOrder
    voucherNumber?: SortOrder
    routeName?: SortOrder
    vehicleType?: SortOrder
    groupSize?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    pickupLocation?: SortOrder
    tourDate?: SortOrder
    tourTime?: SortOrderInput | SortOrder
    passengerNames?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    driverFee?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourDuration?: SortOrder
    _count?: TourBookingCountOrderByAggregateInput
    _avg?: TourBookingAvgOrderByAggregateInput
    _max?: TourBookingMaxOrderByAggregateInput
    _min?: TourBookingMinOrderByAggregateInput
    _sum?: TourBookingSumOrderByAggregateInput
  }

  export type TourBookingScalarWhereWithAggregatesInput = {
    AND?: TourBookingScalarWhereWithAggregatesInput | TourBookingScalarWhereWithAggregatesInput[]
    OR?: TourBookingScalarWhereWithAggregatesInput[]
    NOT?: TourBookingScalarWhereWithAggregatesInput | TourBookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TourBooking"> | string
    voucherNumber?: StringWithAggregatesFilter<"TourBooking"> | string
    routeName?: StringWithAggregatesFilter<"TourBooking"> | string
    vehicleType?: StringWithAggregatesFilter<"TourBooking"> | string
    groupSize?: IntWithAggregatesFilter<"TourBooking"> | number
    price?: FloatWithAggregatesFilter<"TourBooking"> | number
    currency?: StringWithAggregatesFilter<"TourBooking"> | string
    pickupLocation?: StringWithAggregatesFilter<"TourBooking"> | string
    tourDate?: DateTimeWithAggregatesFilter<"TourBooking"> | Date | string
    tourTime?: StringNullableWithAggregatesFilter<"TourBooking"> | string | null
    passengerNames?: StringWithAggregatesFilter<"TourBooking"> | string
    notes?: StringNullableWithAggregatesFilter<"TourBooking"> | string | null
    status?: StringWithAggregatesFilter<"TourBooking"> | string
    tenantId?: StringWithAggregatesFilter<"TourBooking"> | string
    userId?: StringNullableWithAggregatesFilter<"TourBooking"> | string | null
    driverId?: StringNullableWithAggregatesFilter<"TourBooking"> | string | null
    driverFee?: FloatNullableWithAggregatesFilter<"TourBooking"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TourBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TourBooking"> | Date | string
    tourDuration?: IntWithAggregatesFilter<"TourBooking"> | number
  }

  export type TenantWebsiteWhereInput = {
    AND?: TenantWebsiteWhereInput | TenantWebsiteWhereInput[]
    OR?: TenantWebsiteWhereInput[]
    NOT?: TenantWebsiteWhereInput | TenantWebsiteWhereInput[]
    id?: StringFilter<"TenantWebsite"> | string
    tenantId?: StringFilter<"TenantWebsite"> | string
    domain?: StringNullableFilter<"TenantWebsite"> | string | null
    subdomain?: StringNullableFilter<"TenantWebsite"> | string | null
    isActive?: BoolFilter<"TenantWebsite"> | boolean
    theme?: StringFilter<"TenantWebsite"> | string
    customCSS?: StringNullableFilter<"TenantWebsite"> | string | null
    favicon?: StringNullableFilter<"TenantWebsite"> | string | null
    createdAt?: DateTimeFilter<"TenantWebsite"> | Date | string
    updatedAt?: DateTimeFilter<"TenantWebsite"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    pages?: WebsitePageListRelationFilter
    settings?: XOR<WebsiteSettingsNullableScalarRelationFilter, WebsiteSettingsWhereInput> | null
    sections?: WebsiteSectionListRelationFilter
  }

  export type TenantWebsiteOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    domain?: SortOrderInput | SortOrder
    subdomain?: SortOrderInput | SortOrder
    isActive?: SortOrder
    theme?: SortOrder
    customCSS?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    pages?: WebsitePageOrderByRelationAggregateInput
    settings?: WebsiteSettingsOrderByWithRelationInput
    sections?: WebsiteSectionOrderByRelationAggregateInput
  }

  export type TenantWebsiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    subdomain?: string
    AND?: TenantWebsiteWhereInput | TenantWebsiteWhereInput[]
    OR?: TenantWebsiteWhereInput[]
    NOT?: TenantWebsiteWhereInput | TenantWebsiteWhereInput[]
    tenantId?: StringFilter<"TenantWebsite"> | string
    isActive?: BoolFilter<"TenantWebsite"> | boolean
    theme?: StringFilter<"TenantWebsite"> | string
    customCSS?: StringNullableFilter<"TenantWebsite"> | string | null
    favicon?: StringNullableFilter<"TenantWebsite"> | string | null
    createdAt?: DateTimeFilter<"TenantWebsite"> | Date | string
    updatedAt?: DateTimeFilter<"TenantWebsite"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    pages?: WebsitePageListRelationFilter
    settings?: XOR<WebsiteSettingsNullableScalarRelationFilter, WebsiteSettingsWhereInput> | null
    sections?: WebsiteSectionListRelationFilter
  }, "id" | "domain" | "subdomain">

  export type TenantWebsiteOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    domain?: SortOrderInput | SortOrder
    subdomain?: SortOrderInput | SortOrder
    isActive?: SortOrder
    theme?: SortOrder
    customCSS?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantWebsiteCountOrderByAggregateInput
    _max?: TenantWebsiteMaxOrderByAggregateInput
    _min?: TenantWebsiteMinOrderByAggregateInput
  }

  export type TenantWebsiteScalarWhereWithAggregatesInput = {
    AND?: TenantWebsiteScalarWhereWithAggregatesInput | TenantWebsiteScalarWhereWithAggregatesInput[]
    OR?: TenantWebsiteScalarWhereWithAggregatesInput[]
    NOT?: TenantWebsiteScalarWhereWithAggregatesInput | TenantWebsiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantWebsite"> | string
    tenantId?: StringWithAggregatesFilter<"TenantWebsite"> | string
    domain?: StringNullableWithAggregatesFilter<"TenantWebsite"> | string | null
    subdomain?: StringNullableWithAggregatesFilter<"TenantWebsite"> | string | null
    isActive?: BoolWithAggregatesFilter<"TenantWebsite"> | boolean
    theme?: StringWithAggregatesFilter<"TenantWebsite"> | string
    customCSS?: StringNullableWithAggregatesFilter<"TenantWebsite"> | string | null
    favicon?: StringNullableWithAggregatesFilter<"TenantWebsite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantWebsite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantWebsite"> | Date | string
  }

  export type WebsitePageWhereInput = {
    AND?: WebsitePageWhereInput | WebsitePageWhereInput[]
    OR?: WebsitePageWhereInput[]
    NOT?: WebsitePageWhereInput | WebsitePageWhereInput[]
    id?: StringFilter<"WebsitePage"> | string
    websiteId?: StringFilter<"WebsitePage"> | string
    slug?: StringFilter<"WebsitePage"> | string
    title?: StringFilter<"WebsitePage"> | string
    content?: JsonFilter<"WebsitePage">
    metaTitle?: StringNullableFilter<"WebsitePage"> | string | null
    metaDescription?: StringNullableFilter<"WebsitePage"> | string | null
    isPublished?: BoolFilter<"WebsitePage"> | boolean
    isHomepage?: BoolFilter<"WebsitePage"> | boolean
    sortOrder?: IntFilter<"WebsitePage"> | number
    createdAt?: DateTimeFilter<"WebsitePage"> | Date | string
    updatedAt?: DateTimeFilter<"WebsitePage"> | Date | string
    website?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }

  export type WebsitePageOrderByWithRelationInput = {
    id?: SortOrder
    websiteId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    isHomepage?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    website?: TenantWebsiteOrderByWithRelationInput
  }

  export type WebsitePageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    websiteId_slug?: WebsitePageWebsiteIdSlugCompoundUniqueInput
    AND?: WebsitePageWhereInput | WebsitePageWhereInput[]
    OR?: WebsitePageWhereInput[]
    NOT?: WebsitePageWhereInput | WebsitePageWhereInput[]
    websiteId?: StringFilter<"WebsitePage"> | string
    slug?: StringFilter<"WebsitePage"> | string
    title?: StringFilter<"WebsitePage"> | string
    content?: JsonFilter<"WebsitePage">
    metaTitle?: StringNullableFilter<"WebsitePage"> | string | null
    metaDescription?: StringNullableFilter<"WebsitePage"> | string | null
    isPublished?: BoolFilter<"WebsitePage"> | boolean
    isHomepage?: BoolFilter<"WebsitePage"> | boolean
    sortOrder?: IntFilter<"WebsitePage"> | number
    createdAt?: DateTimeFilter<"WebsitePage"> | Date | string
    updatedAt?: DateTimeFilter<"WebsitePage"> | Date | string
    website?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }, "id" | "websiteId_slug">

  export type WebsitePageOrderByWithAggregationInput = {
    id?: SortOrder
    websiteId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    isHomepage?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebsitePageCountOrderByAggregateInput
    _avg?: WebsitePageAvgOrderByAggregateInput
    _max?: WebsitePageMaxOrderByAggregateInput
    _min?: WebsitePageMinOrderByAggregateInput
    _sum?: WebsitePageSumOrderByAggregateInput
  }

  export type WebsitePageScalarWhereWithAggregatesInput = {
    AND?: WebsitePageScalarWhereWithAggregatesInput | WebsitePageScalarWhereWithAggregatesInput[]
    OR?: WebsitePageScalarWhereWithAggregatesInput[]
    NOT?: WebsitePageScalarWhereWithAggregatesInput | WebsitePageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebsitePage"> | string
    websiteId?: StringWithAggregatesFilter<"WebsitePage"> | string
    slug?: StringWithAggregatesFilter<"WebsitePage"> | string
    title?: StringWithAggregatesFilter<"WebsitePage"> | string
    content?: JsonWithAggregatesFilter<"WebsitePage">
    metaTitle?: StringNullableWithAggregatesFilter<"WebsitePage"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"WebsitePage"> | string | null
    isPublished?: BoolWithAggregatesFilter<"WebsitePage"> | boolean
    isHomepage?: BoolWithAggregatesFilter<"WebsitePage"> | boolean
    sortOrder?: IntWithAggregatesFilter<"WebsitePage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WebsitePage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebsitePage"> | Date | string
  }

  export type WebsiteSettingsWhereInput = {
    AND?: WebsiteSettingsWhereInput | WebsiteSettingsWhereInput[]
    OR?: WebsiteSettingsWhereInput[]
    NOT?: WebsiteSettingsWhereInput | WebsiteSettingsWhereInput[]
    id?: StringFilter<"WebsiteSettings"> | string
    websiteId?: StringFilter<"WebsiteSettings"> | string
    companyName?: StringFilter<"WebsiteSettings"> | string
    logo?: StringNullableFilter<"WebsiteSettings"> | string | null
    heroTitle?: StringFilter<"WebsiteSettings"> | string
    heroSubtitle?: StringFilter<"WebsiteSettings"> | string
    heroImage?: StringNullableFilter<"WebsiteSettings"> | string | null
    contactInfo?: JsonFilter<"WebsiteSettings">
    socialMedia?: JsonFilter<"WebsiteSettings">
    seoSettings?: JsonFilter<"WebsiteSettings">
    colorScheme?: JsonFilter<"WebsiteSettings">
    customCSS?: StringNullableFilter<"WebsiteSettings"> | string | null
    analyticsCode?: StringNullableFilter<"WebsiteSettings"> | string | null
    createdAt?: DateTimeFilter<"WebsiteSettings"> | Date | string
    updatedAt?: DateTimeFilter<"WebsiteSettings"> | Date | string
    website?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }

  export type WebsiteSettingsOrderByWithRelationInput = {
    id?: SortOrder
    websiteId?: SortOrder
    companyName?: SortOrder
    logo?: SortOrderInput | SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroImage?: SortOrderInput | SortOrder
    contactInfo?: SortOrder
    socialMedia?: SortOrder
    seoSettings?: SortOrder
    colorScheme?: SortOrder
    customCSS?: SortOrderInput | SortOrder
    analyticsCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    website?: TenantWebsiteOrderByWithRelationInput
  }

  export type WebsiteSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    websiteId?: string
    AND?: WebsiteSettingsWhereInput | WebsiteSettingsWhereInput[]
    OR?: WebsiteSettingsWhereInput[]
    NOT?: WebsiteSettingsWhereInput | WebsiteSettingsWhereInput[]
    companyName?: StringFilter<"WebsiteSettings"> | string
    logo?: StringNullableFilter<"WebsiteSettings"> | string | null
    heroTitle?: StringFilter<"WebsiteSettings"> | string
    heroSubtitle?: StringFilter<"WebsiteSettings"> | string
    heroImage?: StringNullableFilter<"WebsiteSettings"> | string | null
    contactInfo?: JsonFilter<"WebsiteSettings">
    socialMedia?: JsonFilter<"WebsiteSettings">
    seoSettings?: JsonFilter<"WebsiteSettings">
    colorScheme?: JsonFilter<"WebsiteSettings">
    customCSS?: StringNullableFilter<"WebsiteSettings"> | string | null
    analyticsCode?: StringNullableFilter<"WebsiteSettings"> | string | null
    createdAt?: DateTimeFilter<"WebsiteSettings"> | Date | string
    updatedAt?: DateTimeFilter<"WebsiteSettings"> | Date | string
    website?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }, "id" | "websiteId">

  export type WebsiteSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    websiteId?: SortOrder
    companyName?: SortOrder
    logo?: SortOrderInput | SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroImage?: SortOrderInput | SortOrder
    contactInfo?: SortOrder
    socialMedia?: SortOrder
    seoSettings?: SortOrder
    colorScheme?: SortOrder
    customCSS?: SortOrderInput | SortOrder
    analyticsCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebsiteSettingsCountOrderByAggregateInput
    _max?: WebsiteSettingsMaxOrderByAggregateInput
    _min?: WebsiteSettingsMinOrderByAggregateInput
  }

  export type WebsiteSettingsScalarWhereWithAggregatesInput = {
    AND?: WebsiteSettingsScalarWhereWithAggregatesInput | WebsiteSettingsScalarWhereWithAggregatesInput[]
    OR?: WebsiteSettingsScalarWhereWithAggregatesInput[]
    NOT?: WebsiteSettingsScalarWhereWithAggregatesInput | WebsiteSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebsiteSettings"> | string
    websiteId?: StringWithAggregatesFilter<"WebsiteSettings"> | string
    companyName?: StringWithAggregatesFilter<"WebsiteSettings"> | string
    logo?: StringNullableWithAggregatesFilter<"WebsiteSettings"> | string | null
    heroTitle?: StringWithAggregatesFilter<"WebsiteSettings"> | string
    heroSubtitle?: StringWithAggregatesFilter<"WebsiteSettings"> | string
    heroImage?: StringNullableWithAggregatesFilter<"WebsiteSettings"> | string | null
    contactInfo?: JsonWithAggregatesFilter<"WebsiteSettings">
    socialMedia?: JsonWithAggregatesFilter<"WebsiteSettings">
    seoSettings?: JsonWithAggregatesFilter<"WebsiteSettings">
    colorScheme?: JsonWithAggregatesFilter<"WebsiteSettings">
    customCSS?: StringNullableWithAggregatesFilter<"WebsiteSettings"> | string | null
    analyticsCode?: StringNullableWithAggregatesFilter<"WebsiteSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebsiteSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebsiteSettings"> | Date | string
  }

  export type WebsiteSectionWhereInput = {
    AND?: WebsiteSectionWhereInput | WebsiteSectionWhereInput[]
    OR?: WebsiteSectionWhereInput[]
    NOT?: WebsiteSectionWhereInput | WebsiteSectionWhereInput[]
    id?: StringFilter<"WebsiteSection"> | string
    websiteId?: StringFilter<"WebsiteSection"> | string
    sectionType?: StringFilter<"WebsiteSection"> | string
    title?: StringNullableFilter<"WebsiteSection"> | string | null
    content?: JsonFilter<"WebsiteSection">
    isActive?: BoolFilter<"WebsiteSection"> | boolean
    sortOrder?: IntFilter<"WebsiteSection"> | number
    createdAt?: DateTimeFilter<"WebsiteSection"> | Date | string
    updatedAt?: DateTimeFilter<"WebsiteSection"> | Date | string
    website?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }

  export type WebsiteSectionOrderByWithRelationInput = {
    id?: SortOrder
    websiteId?: SortOrder
    sectionType?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    website?: TenantWebsiteOrderByWithRelationInput
  }

  export type WebsiteSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    websiteId_sectionType?: WebsiteSectionWebsiteIdSectionTypeCompoundUniqueInput
    AND?: WebsiteSectionWhereInput | WebsiteSectionWhereInput[]
    OR?: WebsiteSectionWhereInput[]
    NOT?: WebsiteSectionWhereInput | WebsiteSectionWhereInput[]
    websiteId?: StringFilter<"WebsiteSection"> | string
    sectionType?: StringFilter<"WebsiteSection"> | string
    title?: StringNullableFilter<"WebsiteSection"> | string | null
    content?: JsonFilter<"WebsiteSection">
    isActive?: BoolFilter<"WebsiteSection"> | boolean
    sortOrder?: IntFilter<"WebsiteSection"> | number
    createdAt?: DateTimeFilter<"WebsiteSection"> | Date | string
    updatedAt?: DateTimeFilter<"WebsiteSection"> | Date | string
    website?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }, "id" | "websiteId_sectionType">

  export type WebsiteSectionOrderByWithAggregationInput = {
    id?: SortOrder
    websiteId?: SortOrder
    sectionType?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebsiteSectionCountOrderByAggregateInput
    _avg?: WebsiteSectionAvgOrderByAggregateInput
    _max?: WebsiteSectionMaxOrderByAggregateInput
    _min?: WebsiteSectionMinOrderByAggregateInput
    _sum?: WebsiteSectionSumOrderByAggregateInput
  }

  export type WebsiteSectionScalarWhereWithAggregatesInput = {
    AND?: WebsiteSectionScalarWhereWithAggregatesInput | WebsiteSectionScalarWhereWithAggregatesInput[]
    OR?: WebsiteSectionScalarWhereWithAggregatesInput[]
    NOT?: WebsiteSectionScalarWhereWithAggregatesInput | WebsiteSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebsiteSection"> | string
    websiteId?: StringWithAggregatesFilter<"WebsiteSection"> | string
    sectionType?: StringWithAggregatesFilter<"WebsiteSection"> | string
    title?: StringNullableWithAggregatesFilter<"WebsiteSection"> | string | null
    content?: JsonWithAggregatesFilter<"WebsiteSection">
    isActive?: BoolWithAggregatesFilter<"WebsiteSection"> | boolean
    sortOrder?: IntWithAggregatesFilter<"WebsiteSection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WebsiteSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebsiteSection"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    priceMonthly?: number
    priceYearly?: number
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantModules?: TenantModuleCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    priceMonthly?: number
    priceYearly?: number
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantModules?: TenantModuleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantModules?: TenantModuleUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantModules?: TenantModuleUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    priceMonthly?: number
    priceYearly?: number
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantModuleCreateInput = {
    id?: string
    isEnabled?: boolean
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutTenantModulesInput
    tenant: TenantCreateNestedOneWithoutModulesInput
  }

  export type TenantModuleUncheckedCreateInput = {
    id?: string
    tenantId: string
    moduleId: string
    isEnabled?: boolean
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutTenantModulesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutModulesNestedInput
  }

  export type TenantModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantModuleCreateManyInput = {
    id?: string
    tenantId: string
    moduleId: string
    isEnabled?: boolean
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUserCreateInput = {
    id?: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutTenantUsersInput
  }

  export type TenantUserUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutTenantUsersNestedInput
  }

  export type TenantUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUserCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    createdAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutDriverInput
    tenant?: TenantCreateNestedOneWithoutDriversInput
    tourBookings?: TourBookingCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    tenantId?: string | null
    createdAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutDriverInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutDriverNestedInput
    tenant?: TenantUpdateOneWithoutDriversNestedInput
    tourBookings?: TourBookingUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutDriverNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverCreateManyInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    tenantId?: string | null
    createdAt?: Date | string
  }

  export type DriverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    reservations?: ReservationCreateNestedManyWithoutUserInput
    creator?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserUncheckedCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    creator?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUncheckedUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPermissionCreateInput = {
    id?: string
    permission: string
    grantedBy?: string | null
    grantedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutPermissionsInput
  }

  export type UserPermissionUncheckedCreateInput = {
    id?: string
    userId: string
    permission: string
    grantedBy?: string | null
    grantedAt?: Date | string
    isActive?: boolean
  }

  export type UserPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type UserPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPermissionCreateManyInput = {
    id?: string
    userId: string
    permission: string
    grantedBy?: string | null
    grantedAt?: Date | string
    isActive?: boolean
  }

  export type UserPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutActivitiesInput
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    tenantId?: string | null
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutActivitiesNestedInput
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    tenantId?: string | null
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationCreateInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    paymentStatus?: string
    createdAt?: Date | string
    isReturn?: boolean
    distanceKm?: number | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    driver?: DriverCreateNestedOneWithoutReservationsInput
    returnTransfer?: ReservationCreateNestedOneWithoutOriginalTransferInput
    originalTransfer?: ReservationCreateNestedOneWithoutReturnTransferInput
    tenant?: TenantCreateNestedOneWithoutReservationsInput
    user?: UserCreateNestedOneWithoutReservationsInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    driverId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    returnTransferId?: string | null
    isReturn?: boolean
    distanceKm?: number | null
    userId?: string | null
    tenantId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    originalTransfer?: ReservationUncheckedCreateNestedOneWithoutReturnTransferInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    driver?: DriverUpdateOneWithoutReservationsNestedInput
    returnTransfer?: ReservationUpdateOneWithoutOriginalTransferNestedInput
    originalTransfer?: ReservationUpdateOneWithoutReturnTransferNestedInput
    tenant?: TenantUpdateOneWithoutReservationsNestedInput
    user?: UserUpdateOneWithoutReservationsNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    originalTransfer?: ReservationUncheckedUpdateOneWithoutReturnTransferNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationCreateManyInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    driverId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    returnTransferId?: string | null
    isReturn?: boolean
    distanceKm?: number | null
    userId?: string | null
    tenantId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
  }

  export type ReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type HotelRequestCreateInput = {
    id?: string
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelBookings?: HotelBookingCreateNestedManyWithoutRequestInput
    user?: UserCreateNestedOneWithoutHotelRequestsInput
    tenant?: TenantCreateNestedOneWithoutHotelRequestsInput
  }

  export type HotelRequestUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    assignedTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutRequestInput
  }

  export type HotelRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelBookings?: HotelBookingUpdateManyWithoutRequestNestedInput
    user?: UserUpdateOneWithoutHotelRequestsNestedInput
    tenant?: TenantUpdateOneWithoutHotelRequestsNestedInput
  }

  export type HotelRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type HotelRequestCreateManyInput = {
    id?: string
    tenantId?: string | null
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    assignedTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingCreateInput = {
    id?: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
    request?: HotelRequestCreateNestedOneWithoutHotelBookingsInput
    reservation?: ReservationCreateNestedOneWithoutHotelBookingsInput
    tenant?: TenantCreateNestedOneWithoutHotelBookingsInput
  }

  export type HotelBookingUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    requestId?: string | null
    reservationId?: string | null
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
  }

  export type HotelBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    request?: HotelRequestUpdateOneWithoutHotelBookingsNestedInput
    reservation?: ReservationUpdateOneWithoutHotelBookingsNestedInput
    tenant?: TenantUpdateOneWithoutHotelBookingsNestedInput
  }

  export type HotelBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
  }

  export type HotelBookingCreateManyInput = {
    id?: string
    tenantId?: string | null
    requestId?: string | null
    reservationId?: string | null
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
  }

  export type HotelBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
  }

  export type HotelBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
  }

  export type HotelPricePoolCreateInput = {
    id?: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    hotelCity: string
    hotelCountry: string
    hotelRating: number
    hotelStars: number
    hotelImage?: string | null
    hotelAmenities?: string
    roomType: string
    roomName: string
    roomDescription?: string | null
    roomAmenities?: string
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    roomView?: string | null
    basePrice: number
    agentPrice: number
    customerPrice: number
    profitMargin: number
    profitPercentage: number
    currency?: string
    validFrom: Date | string
    validTo: Date | string
    cancellationPolicy?: string | null
    breakfastIncluded?: boolean
    freeCancellation?: boolean
    source?: string
    lastUpdated?: Date | string
    updatedBy: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutHotelPricePoolInput
  }

  export type HotelPricePoolUncheckedCreateInput = {
    id?: string
    tenantId: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    hotelCity: string
    hotelCountry: string
    hotelRating: number
    hotelStars: number
    hotelImage?: string | null
    hotelAmenities?: string
    roomType: string
    roomName: string
    roomDescription?: string | null
    roomAmenities?: string
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    roomView?: string | null
    basePrice: number
    agentPrice: number
    customerPrice: number
    profitMargin: number
    profitPercentage: number
    currency?: string
    validFrom: Date | string
    validTo: Date | string
    cancellationPolicy?: string | null
    breakfastIncluded?: boolean
    freeCancellation?: boolean
    source?: string
    lastUpdated?: Date | string
    updatedBy: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelPricePoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    hotelCity?: StringFieldUpdateOperationsInput | string
    hotelCountry?: StringFieldUpdateOperationsInput | string
    hotelRating?: FloatFieldUpdateOperationsInput | number
    hotelStars?: IntFieldUpdateOperationsInput | number
    hotelImage?: NullableStringFieldUpdateOperationsInput | string | null
    hotelAmenities?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    roomDescription?: NullableStringFieldUpdateOperationsInput | string | null
    roomAmenities?: StringFieldUpdateOperationsInput | string
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    roomView?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    breakfastIncluded?: BoolFieldUpdateOperationsInput | boolean
    freeCancellation?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutHotelPricePoolNestedInput
  }

  export type HotelPricePoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    hotelCity?: StringFieldUpdateOperationsInput | string
    hotelCountry?: StringFieldUpdateOperationsInput | string
    hotelRating?: FloatFieldUpdateOperationsInput | number
    hotelStars?: IntFieldUpdateOperationsInput | number
    hotelImage?: NullableStringFieldUpdateOperationsInput | string | null
    hotelAmenities?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    roomDescription?: NullableStringFieldUpdateOperationsInput | string | null
    roomAmenities?: StringFieldUpdateOperationsInput | string
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    roomView?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    breakfastIncluded?: BoolFieldUpdateOperationsInput | boolean
    freeCancellation?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelPricePoolCreateManyInput = {
    id?: string
    tenantId: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    hotelCity: string
    hotelCountry: string
    hotelRating: number
    hotelStars: number
    hotelImage?: string | null
    hotelAmenities?: string
    roomType: string
    roomName: string
    roomDescription?: string | null
    roomAmenities?: string
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    roomView?: string | null
    basePrice: number
    agentPrice: number
    customerPrice: number
    profitMargin: number
    profitPercentage: number
    currency?: string
    validFrom: Date | string
    validTo: Date | string
    cancellationPolicy?: string | null
    breakfastIncluded?: boolean
    freeCancellation?: boolean
    source?: string
    lastUpdated?: Date | string
    updatedBy: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelPricePoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    hotelCity?: StringFieldUpdateOperationsInput | string
    hotelCountry?: StringFieldUpdateOperationsInput | string
    hotelRating?: FloatFieldUpdateOperationsInput | number
    hotelStars?: IntFieldUpdateOperationsInput | number
    hotelImage?: NullableStringFieldUpdateOperationsInput | string | null
    hotelAmenities?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    roomDescription?: NullableStringFieldUpdateOperationsInput | string | null
    roomAmenities?: StringFieldUpdateOperationsInput | string
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    roomView?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    breakfastIncluded?: BoolFieldUpdateOperationsInput | boolean
    freeCancellation?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelPricePoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    hotelCity?: StringFieldUpdateOperationsInput | string
    hotelCountry?: StringFieldUpdateOperationsInput | string
    hotelRating?: FloatFieldUpdateOperationsInput | number
    hotelStars?: IntFieldUpdateOperationsInput | number
    hotelImage?: NullableStringFieldUpdateOperationsInput | string | null
    hotelAmenities?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    roomDescription?: NullableStringFieldUpdateOperationsInput | string | null
    roomAmenities?: StringFieldUpdateOperationsInput | string
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    roomView?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    breakfastIncluded?: BoolFieldUpdateOperationsInput | boolean
    freeCancellation?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateInput = {
    id?: string
    type: string
    capacity: number
    licensePlate: string
    driverName?: string | null
    driverPhone?: string | null
    isAvailable?: boolean
    lastMaintenance?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVehiclesInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: string
    type: string
    capacity: number
    licensePlate: string
    driverName?: string | null
    driverPhone?: string | null
    isAvailable?: boolean
    lastMaintenance?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVehiclesNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateManyInput = {
    id?: string
    type: string
    capacity: number
    licensePlate: string
    driverName?: string | null
    driverPhone?: string | null
    isAvailable?: boolean
    lastMaintenance?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourBookingCreateInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
    driver?: DriverCreateNestedOneWithoutTourBookingsInput
    tenant: TenantCreateNestedOneWithoutTourBookingsInput
    User?: UserCreateNestedOneWithoutTour_bookingsInput
  }

  export type TourBookingUncheckedCreateInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    tenantId: string
    userId?: string | null
    driverId?: string | null
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
  }

  export type TourBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
    driver?: DriverUpdateOneWithoutTourBookingsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTourBookingsNestedInput
    User?: UserUpdateOneWithoutTour_bookingsNestedInput
  }

  export type TourBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
  }

  export type TourBookingCreateManyInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    tenantId: string
    userId?: string | null
    driverId?: string | null
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
  }

  export type TourBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
  }

  export type TourBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
  }

  export type TenantWebsiteCreateInput = {
    id?: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWebsitesInput
    pages?: WebsitePageCreateNestedManyWithoutWebsiteInput
    settings?: WebsiteSettingsCreateNestedOneWithoutWebsiteInput
    sections?: WebsiteSectionCreateNestedManyWithoutWebsiteInput
  }

  export type TenantWebsiteUncheckedCreateInput = {
    id?: string
    tenantId: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: WebsitePageUncheckedCreateNestedManyWithoutWebsiteInput
    settings?: WebsiteSettingsUncheckedCreateNestedOneWithoutWebsiteInput
    sections?: WebsiteSectionUncheckedCreateNestedManyWithoutWebsiteInput
  }

  export type TenantWebsiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWebsitesNestedInput
    pages?: WebsitePageUpdateManyWithoutWebsiteNestedInput
    settings?: WebsiteSettingsUpdateOneWithoutWebsiteNestedInput
    sections?: WebsiteSectionUpdateManyWithoutWebsiteNestedInput
  }

  export type TenantWebsiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: WebsitePageUncheckedUpdateManyWithoutWebsiteNestedInput
    settings?: WebsiteSettingsUncheckedUpdateOneWithoutWebsiteNestedInput
    sections?: WebsiteSectionUncheckedUpdateManyWithoutWebsiteNestedInput
  }

  export type TenantWebsiteCreateManyInput = {
    id?: string
    tenantId: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantWebsiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantWebsiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsitePageCreateInput = {
    id?: string
    slug: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    isHomepage?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    website: TenantWebsiteCreateNestedOneWithoutPagesInput
  }

  export type WebsitePageUncheckedCreateInput = {
    id?: string
    websiteId: string
    slug: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    isHomepage?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsitePageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isHomepage?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: TenantWebsiteUpdateOneRequiredWithoutPagesNestedInput
  }

  export type WebsitePageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isHomepage?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsitePageCreateManyInput = {
    id?: string
    websiteId: string
    slug: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    isHomepage?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsitePageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isHomepage?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsitePageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isHomepage?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSettingsCreateInput = {
    id?: string
    companyName: string
    logo?: string | null
    heroTitle: string
    heroSubtitle: string
    heroImage?: string | null
    contactInfo: JsonNullValueInput | InputJsonValue
    socialMedia: JsonNullValueInput | InputJsonValue
    seoSettings: JsonNullValueInput | InputJsonValue
    colorScheme: JsonNullValueInput | InputJsonValue
    customCSS?: string | null
    analyticsCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    website: TenantWebsiteCreateNestedOneWithoutSettingsInput
  }

  export type WebsiteSettingsUncheckedCreateInput = {
    id?: string
    websiteId: string
    companyName: string
    logo?: string | null
    heroTitle: string
    heroSubtitle: string
    heroImage?: string | null
    contactInfo: JsonNullValueInput | InputJsonValue
    socialMedia: JsonNullValueInput | InputJsonValue
    seoSettings: JsonNullValueInput | InputJsonValue
    colorScheme: JsonNullValueInput | InputJsonValue
    customCSS?: string | null
    analyticsCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: JsonNullValueInput | InputJsonValue
    socialMedia?: JsonNullValueInput | InputJsonValue
    seoSettings?: JsonNullValueInput | InputJsonValue
    colorScheme?: JsonNullValueInput | InputJsonValue
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: TenantWebsiteUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type WebsiteSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: JsonNullValueInput | InputJsonValue
    socialMedia?: JsonNullValueInput | InputJsonValue
    seoSettings?: JsonNullValueInput | InputJsonValue
    colorScheme?: JsonNullValueInput | InputJsonValue
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSettingsCreateManyInput = {
    id?: string
    websiteId: string
    companyName: string
    logo?: string | null
    heroTitle: string
    heroSubtitle: string
    heroImage?: string | null
    contactInfo: JsonNullValueInput | InputJsonValue
    socialMedia: JsonNullValueInput | InputJsonValue
    seoSettings: JsonNullValueInput | InputJsonValue
    colorScheme: JsonNullValueInput | InputJsonValue
    customCSS?: string | null
    analyticsCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: JsonNullValueInput | InputJsonValue
    socialMedia?: JsonNullValueInput | InputJsonValue
    seoSettings?: JsonNullValueInput | InputJsonValue
    colorScheme?: JsonNullValueInput | InputJsonValue
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: JsonNullValueInput | InputJsonValue
    socialMedia?: JsonNullValueInput | InputJsonValue
    seoSettings?: JsonNullValueInput | InputJsonValue
    colorScheme?: JsonNullValueInput | InputJsonValue
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSectionCreateInput = {
    id?: string
    sectionType: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    website: TenantWebsiteCreateNestedOneWithoutSectionsInput
  }

  export type WebsiteSectionUncheckedCreateInput = {
    id?: string
    websiteId: string
    sectionType: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: TenantWebsiteUpdateOneRequiredWithoutSectionsNestedInput
  }

  export type WebsiteSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteId?: StringFieldUpdateOperationsInput | string
    sectionType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSectionCreateManyInput = {
    id?: string
    websiteId: string
    sectionType: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteId?: StringFieldUpdateOperationsInput | string
    sectionType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type DriverListRelationFilter = {
    every?: DriverWhereInput
    some?: DriverWhereInput
    none?: DriverWhereInput
  }

  export type HotelBookingListRelationFilter = {
    every?: HotelBookingWhereInput
    some?: HotelBookingWhereInput
    none?: HotelBookingWhereInput
  }

  export type HotelPricePoolListRelationFilter = {
    every?: HotelPricePoolWhereInput
    some?: HotelPricePoolWhereInput
    none?: HotelPricePoolWhereInput
  }

  export type HotelRequestListRelationFilter = {
    every?: HotelRequestWhereInput
    some?: HotelRequestWhereInput
    none?: HotelRequestWhereInput
  }

  export type TenantModuleListRelationFilter = {
    every?: TenantModuleWhereInput
    some?: TenantModuleWhereInput
    none?: TenantModuleWhereInput
  }

  export type TenantUserListRelationFilter = {
    every?: TenantUserWhereInput
    some?: TenantUserWhereInput
    none?: TenantUserWhereInput
  }

  export type TourBookingListRelationFilter = {
    every?: TourBookingWhereInput
    some?: TourBookingWhereInput
    none?: TourBookingWhereInput
  }

  export type VehicleListRelationFilter = {
    every?: VehicleWhereInput
    some?: VehicleWhereInput
    none?: VehicleWhereInput
  }

  export type TenantWebsiteListRelationFilter = {
    every?: TenantWebsiteWhereInput
    some?: TenantWebsiteWhereInput
    none?: TenantWebsiteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelPricePoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantWebsiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    subdomain?: SortOrder
    companyName?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    subscriptionPlan?: SortOrder
    websiteModuleEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentAccountHolder?: SortOrder
    paymentBank?: SortOrder
    paymentIban?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    subdomain?: SortOrder
    companyName?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    subscriptionPlan?: SortOrder
    websiteModuleEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentAccountHolder?: SortOrder
    paymentBank?: SortOrder
    paymentIban?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    subdomain?: SortOrder
    companyName?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    subscriptionPlan?: SortOrder
    websiteModuleEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentAccountHolder?: SortOrder
    paymentBank?: SortOrder
    paymentIban?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ModuleScalarRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type TenantModuleTenantIdModuleIdCompoundUniqueInput = {
    tenantId: string
    moduleId: string
  }

  export type TenantModuleCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    moduleId?: SortOrder
    isEnabled?: SortOrder
    activatedAt?: SortOrder
    expiresAt?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    moduleId?: SortOrder
    isEnabled?: SortOrder
    activatedAt?: SortOrder
    expiresAt?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantModuleMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    moduleId?: SortOrder
    isEnabled?: SortOrder
    activatedAt?: SortOrder
    expiresAt?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TenantUserTenantIdUserIdCompoundUniqueInput = {
    tenantId: string
    userId: string
  }

  export type TenantUserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantUserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantUserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantNullableScalarRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type DriverCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserPermissionListRelationFilter = {
    every?: UserPermissionWhereInput
    some?: UserPermissionWhereInput
    none?: UserPermissionWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type UserPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    isActive?: SortOrder
  }

  export type UserPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    isActive?: SortOrder
  }

  export type UserPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    isActive?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    tenantId?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    tenantId?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    tenantId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DriverNullableScalarRelationFilter = {
    is?: DriverWhereInput | null
    isNot?: DriverWhereInput | null
  }

  export type ReservationNullableScalarRelationFilter = {
    is?: ReservationWhereInput | null
    isNot?: ReservationWhereInput | null
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    from?: SortOrder
    to?: SortOrder
    flightCode?: SortOrder
    passengerNames?: SortOrder
    luggageCount?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    phoneNumber?: SortOrder
    voucherNumber?: SortOrder
    driverFee?: SortOrder
    driverId?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    returnTransferId?: SortOrder
    isReturn?: SortOrder
    distanceKm?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    companyCommissionStatus?: SortOrder
    notes?: SortOrder
    email?: SortOrder
    type?: SortOrder
  }

  export type ReservationAvgOrderByAggregateInput = {
    luggageCount?: SortOrder
    price?: SortOrder
    driverFee?: SortOrder
    distanceKm?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    from?: SortOrder
    to?: SortOrder
    flightCode?: SortOrder
    passengerNames?: SortOrder
    luggageCount?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    phoneNumber?: SortOrder
    voucherNumber?: SortOrder
    driverFee?: SortOrder
    driverId?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    returnTransferId?: SortOrder
    isReturn?: SortOrder
    distanceKm?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    companyCommissionStatus?: SortOrder
    notes?: SortOrder
    email?: SortOrder
    type?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    from?: SortOrder
    to?: SortOrder
    flightCode?: SortOrder
    passengerNames?: SortOrder
    luggageCount?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    phoneNumber?: SortOrder
    voucherNumber?: SortOrder
    driverFee?: SortOrder
    driverId?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    returnTransferId?: SortOrder
    isReturn?: SortOrder
    distanceKm?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    companyCommissionStatus?: SortOrder
    notes?: SortOrder
    email?: SortOrder
    type?: SortOrder
  }

  export type ReservationSumOrderByAggregateInput = {
    luggageCount?: SortOrder
    price?: SortOrder
    driverFee?: SortOrder
    distanceKm?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type HotelRequestCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    checkin?: SortOrder
    checkout?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    city?: SortOrder
    region?: SortOrder
    budget?: SortOrder
    roomType?: SortOrder
    breakfast?: SortOrder
    amenities?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelRequestAvgOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    budget?: SortOrder
  }

  export type HotelRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    checkin?: SortOrder
    checkout?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    city?: SortOrder
    region?: SortOrder
    budget?: SortOrder
    roomType?: SortOrder
    breakfast?: SortOrder
    amenities?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelRequestMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    checkin?: SortOrder
    checkout?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    city?: SortOrder
    region?: SortOrder
    budget?: SortOrder
    roomType?: SortOrder
    breakfast?: SortOrder
    amenities?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelRequestSumOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    budget?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type HotelRequestNullableScalarRelationFilter = {
    is?: HotelRequestWhereInput | null
    isNot?: HotelRequestWhereInput | null
  }

  export type HotelBookingCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    requestId?: SortOrder
    reservationId?: SortOrder
    hotelId?: SortOrder
    hotelName?: SortOrder
    hotelAddress?: SortOrder
    roomType?: SortOrder
    checkin?: SortOrder
    checkout?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    bookingReference?: SortOrder
    status?: SortOrder
    customerInfo?: SortOrder
    specialRequests?: SortOrder
    cancellationPolicy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    voucherNumber?: SortOrder
  }

  export type HotelBookingAvgOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    totalPrice?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
  }

  export type HotelBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    requestId?: SortOrder
    reservationId?: SortOrder
    hotelId?: SortOrder
    hotelName?: SortOrder
    hotelAddress?: SortOrder
    roomType?: SortOrder
    checkin?: SortOrder
    checkout?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    bookingReference?: SortOrder
    status?: SortOrder
    specialRequests?: SortOrder
    cancellationPolicy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    voucherNumber?: SortOrder
  }

  export type HotelBookingMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    requestId?: SortOrder
    reservationId?: SortOrder
    hotelId?: SortOrder
    hotelName?: SortOrder
    hotelAddress?: SortOrder
    roomType?: SortOrder
    checkin?: SortOrder
    checkout?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    bookingReference?: SortOrder
    status?: SortOrder
    specialRequests?: SortOrder
    cancellationPolicy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    voucherNumber?: SortOrder
  }

  export type HotelBookingSumOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
    rooms?: SortOrder
    totalPrice?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type HotelPricePoolCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    hotelId?: SortOrder
    hotelName?: SortOrder
    hotelAddress?: SortOrder
    hotelCity?: SortOrder
    hotelCountry?: SortOrder
    hotelRating?: SortOrder
    hotelStars?: SortOrder
    hotelImage?: SortOrder
    hotelAmenities?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    roomDescription?: SortOrder
    roomAmenities?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrder
    roomView?: SortOrder
    basePrice?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    profitPercentage?: SortOrder
    currency?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    cancellationPolicy?: SortOrder
    breakfastIncluded?: SortOrder
    freeCancellation?: SortOrder
    source?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelPricePoolAvgOrderByAggregateInput = {
    hotelRating?: SortOrder
    hotelStars?: SortOrder
    maxOccupancy?: SortOrder
    basePrice?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    profitPercentage?: SortOrder
  }

  export type HotelPricePoolMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    hotelId?: SortOrder
    hotelName?: SortOrder
    hotelAddress?: SortOrder
    hotelCity?: SortOrder
    hotelCountry?: SortOrder
    hotelRating?: SortOrder
    hotelStars?: SortOrder
    hotelImage?: SortOrder
    hotelAmenities?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    roomDescription?: SortOrder
    roomAmenities?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrder
    roomView?: SortOrder
    basePrice?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    profitPercentage?: SortOrder
    currency?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    cancellationPolicy?: SortOrder
    breakfastIncluded?: SortOrder
    freeCancellation?: SortOrder
    source?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelPricePoolMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    hotelId?: SortOrder
    hotelName?: SortOrder
    hotelAddress?: SortOrder
    hotelCity?: SortOrder
    hotelCountry?: SortOrder
    hotelRating?: SortOrder
    hotelStars?: SortOrder
    hotelImage?: SortOrder
    hotelAmenities?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    roomDescription?: SortOrder
    roomAmenities?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrder
    roomView?: SortOrder
    basePrice?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    profitPercentage?: SortOrder
    currency?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    cancellationPolicy?: SortOrder
    breakfastIncluded?: SortOrder
    freeCancellation?: SortOrder
    source?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelPricePoolSumOrderByAggregateInput = {
    hotelRating?: SortOrder
    hotelStars?: SortOrder
    maxOccupancy?: SortOrder
    basePrice?: SortOrder
    agentPrice?: SortOrder
    customerPrice?: SortOrder
    profitMargin?: SortOrder
    profitPercentage?: SortOrder
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    licensePlate?: SortOrder
    driverName?: SortOrder
    driverPhone?: SortOrder
    isAvailable?: SortOrder
    lastMaintenance?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    licensePlate?: SortOrder
    driverName?: SortOrder
    driverPhone?: SortOrder
    isAvailable?: SortOrder
    lastMaintenance?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    licensePlate?: SortOrder
    driverName?: SortOrder
    driverPhone?: SortOrder
    isAvailable?: SortOrder
    lastMaintenance?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type TourBookingCountOrderByAggregateInput = {
    id?: SortOrder
    voucherNumber?: SortOrder
    routeName?: SortOrder
    vehicleType?: SortOrder
    groupSize?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    pickupLocation?: SortOrder
    tourDate?: SortOrder
    tourTime?: SortOrder
    passengerNames?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    driverId?: SortOrder
    driverFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourDuration?: SortOrder
  }

  export type TourBookingAvgOrderByAggregateInput = {
    groupSize?: SortOrder
    price?: SortOrder
    driverFee?: SortOrder
    tourDuration?: SortOrder
  }

  export type TourBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    voucherNumber?: SortOrder
    routeName?: SortOrder
    vehicleType?: SortOrder
    groupSize?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    pickupLocation?: SortOrder
    tourDate?: SortOrder
    tourTime?: SortOrder
    passengerNames?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    driverId?: SortOrder
    driverFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourDuration?: SortOrder
  }

  export type TourBookingMinOrderByAggregateInput = {
    id?: SortOrder
    voucherNumber?: SortOrder
    routeName?: SortOrder
    vehicleType?: SortOrder
    groupSize?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    pickupLocation?: SortOrder
    tourDate?: SortOrder
    tourTime?: SortOrder
    passengerNames?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    driverId?: SortOrder
    driverFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourDuration?: SortOrder
  }

  export type TourBookingSumOrderByAggregateInput = {
    groupSize?: SortOrder
    price?: SortOrder
    driverFee?: SortOrder
    tourDuration?: SortOrder
  }

  export type WebsitePageListRelationFilter = {
    every?: WebsitePageWhereInput
    some?: WebsitePageWhereInput
    none?: WebsitePageWhereInput
  }

  export type WebsiteSettingsNullableScalarRelationFilter = {
    is?: WebsiteSettingsWhereInput | null
    isNot?: WebsiteSettingsWhereInput | null
  }

  export type WebsiteSectionListRelationFilter = {
    every?: WebsiteSectionWhereInput
    some?: WebsiteSectionWhereInput
    none?: WebsiteSectionWhereInput
  }

  export type WebsitePageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebsiteSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantWebsiteCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    domain?: SortOrder
    subdomain?: SortOrder
    isActive?: SortOrder
    theme?: SortOrder
    customCSS?: SortOrder
    favicon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantWebsiteMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    domain?: SortOrder
    subdomain?: SortOrder
    isActive?: SortOrder
    theme?: SortOrder
    customCSS?: SortOrder
    favicon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantWebsiteMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    domain?: SortOrder
    subdomain?: SortOrder
    isActive?: SortOrder
    theme?: SortOrder
    customCSS?: SortOrder
    favicon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantWebsiteScalarRelationFilter = {
    is?: TenantWebsiteWhereInput
    isNot?: TenantWebsiteWhereInput
  }

  export type WebsitePageWebsiteIdSlugCompoundUniqueInput = {
    websiteId: string
    slug: string
  }

  export type WebsitePageCountOrderByAggregateInput = {
    id?: SortOrder
    websiteId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    isPublished?: SortOrder
    isHomepage?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsitePageAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type WebsitePageMaxOrderByAggregateInput = {
    id?: SortOrder
    websiteId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    isPublished?: SortOrder
    isHomepage?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsitePageMinOrderByAggregateInput = {
    id?: SortOrder
    websiteId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    isPublished?: SortOrder
    isHomepage?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsitePageSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type WebsiteSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    websiteId?: SortOrder
    companyName?: SortOrder
    logo?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroImage?: SortOrder
    contactInfo?: SortOrder
    socialMedia?: SortOrder
    seoSettings?: SortOrder
    colorScheme?: SortOrder
    customCSS?: SortOrder
    analyticsCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    websiteId?: SortOrder
    companyName?: SortOrder
    logo?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroImage?: SortOrder
    customCSS?: SortOrder
    analyticsCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    websiteId?: SortOrder
    companyName?: SortOrder
    logo?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroImage?: SortOrder
    customCSS?: SortOrder
    analyticsCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteSectionWebsiteIdSectionTypeCompoundUniqueInput = {
    websiteId: string
    sectionType: string
  }

  export type WebsiteSectionCountOrderByAggregateInput = {
    id?: SortOrder
    websiteId?: SortOrder
    sectionType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteSectionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type WebsiteSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    websiteId?: SortOrder
    sectionType?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteSectionMinOrderByAggregateInput = {
    id?: SortOrder
    websiteId?: SortOrder
    sectionType?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteSectionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ActivityCreateNestedManyWithoutTenantInput = {
    create?: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput> | ActivityCreateWithoutTenantInput[] | ActivityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenantInput | ActivityCreateOrConnectWithoutTenantInput[]
    createMany?: ActivityCreateManyTenantInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutTenantInput = {
    create?: XOR<ReservationCreateWithoutTenantInput, ReservationUncheckedCreateWithoutTenantInput> | ReservationCreateWithoutTenantInput[] | ReservationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutTenantInput | ReservationCreateOrConnectWithoutTenantInput[]
    createMany?: ReservationCreateManyTenantInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type DriverCreateNestedManyWithoutTenantInput = {
    create?: XOR<DriverCreateWithoutTenantInput, DriverUncheckedCreateWithoutTenantInput> | DriverCreateWithoutTenantInput[] | DriverUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutTenantInput | DriverCreateOrConnectWithoutTenantInput[]
    createMany?: DriverCreateManyTenantInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type HotelBookingCreateNestedManyWithoutTenantInput = {
    create?: XOR<HotelBookingCreateWithoutTenantInput, HotelBookingUncheckedCreateWithoutTenantInput> | HotelBookingCreateWithoutTenantInput[] | HotelBookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutTenantInput | HotelBookingCreateOrConnectWithoutTenantInput[]
    createMany?: HotelBookingCreateManyTenantInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelPricePoolCreateNestedManyWithoutTenantInput = {
    create?: XOR<HotelPricePoolCreateWithoutTenantInput, HotelPricePoolUncheckedCreateWithoutTenantInput> | HotelPricePoolCreateWithoutTenantInput[] | HotelPricePoolUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelPricePoolCreateOrConnectWithoutTenantInput | HotelPricePoolCreateOrConnectWithoutTenantInput[]
    createMany?: HotelPricePoolCreateManyTenantInputEnvelope
    connect?: HotelPricePoolWhereUniqueInput | HotelPricePoolWhereUniqueInput[]
  }

  export type HotelRequestCreateNestedManyWithoutTenantInput = {
    create?: XOR<HotelRequestCreateWithoutTenantInput, HotelRequestUncheckedCreateWithoutTenantInput> | HotelRequestCreateWithoutTenantInput[] | HotelRequestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelRequestCreateOrConnectWithoutTenantInput | HotelRequestCreateOrConnectWithoutTenantInput[]
    createMany?: HotelRequestCreateManyTenantInputEnvelope
    connect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
  }

  export type TenantModuleCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantModuleCreateWithoutTenantInput, TenantModuleUncheckedCreateWithoutTenantInput> | TenantModuleCreateWithoutTenantInput[] | TenantModuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantModuleCreateOrConnectWithoutTenantInput | TenantModuleCreateOrConnectWithoutTenantInput[]
    createMany?: TenantModuleCreateManyTenantInputEnvelope
    connect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
  }

  export type TenantUserCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantUserCreateWithoutTenantInput, TenantUserUncheckedCreateWithoutTenantInput> | TenantUserCreateWithoutTenantInput[] | TenantUserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantUserCreateOrConnectWithoutTenantInput | TenantUserCreateOrConnectWithoutTenantInput[]
    createMany?: TenantUserCreateManyTenantInputEnvelope
    connect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
  }

  export type TourBookingCreateNestedManyWithoutTenantInput = {
    create?: XOR<TourBookingCreateWithoutTenantInput, TourBookingUncheckedCreateWithoutTenantInput> | TourBookingCreateWithoutTenantInput[] | TourBookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutTenantInput | TourBookingCreateOrConnectWithoutTenantInput[]
    createMany?: TourBookingCreateManyTenantInputEnvelope
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
  }

  export type VehicleCreateNestedManyWithoutTenantInput = {
    create?: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput> | VehicleCreateWithoutTenantInput[] | VehicleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutTenantInput | VehicleCreateOrConnectWithoutTenantInput[]
    createMany?: VehicleCreateManyTenantInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type TenantWebsiteCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantWebsiteCreateWithoutTenantInput, TenantWebsiteUncheckedCreateWithoutTenantInput> | TenantWebsiteCreateWithoutTenantInput[] | TenantWebsiteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutTenantInput | TenantWebsiteCreateOrConnectWithoutTenantInput[]
    createMany?: TenantWebsiteCreateManyTenantInputEnvelope
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput> | ActivityCreateWithoutTenantInput[] | ActivityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenantInput | ActivityCreateOrConnectWithoutTenantInput[]
    createMany?: ActivityCreateManyTenantInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ReservationCreateWithoutTenantInput, ReservationUncheckedCreateWithoutTenantInput> | ReservationCreateWithoutTenantInput[] | ReservationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutTenantInput | ReservationCreateOrConnectWithoutTenantInput[]
    createMany?: ReservationCreateManyTenantInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type DriverUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DriverCreateWithoutTenantInput, DriverUncheckedCreateWithoutTenantInput> | DriverCreateWithoutTenantInput[] | DriverUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutTenantInput | DriverCreateOrConnectWithoutTenantInput[]
    createMany?: DriverCreateManyTenantInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type HotelBookingUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<HotelBookingCreateWithoutTenantInput, HotelBookingUncheckedCreateWithoutTenantInput> | HotelBookingCreateWithoutTenantInput[] | HotelBookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutTenantInput | HotelBookingCreateOrConnectWithoutTenantInput[]
    createMany?: HotelBookingCreateManyTenantInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<HotelPricePoolCreateWithoutTenantInput, HotelPricePoolUncheckedCreateWithoutTenantInput> | HotelPricePoolCreateWithoutTenantInput[] | HotelPricePoolUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelPricePoolCreateOrConnectWithoutTenantInput | HotelPricePoolCreateOrConnectWithoutTenantInput[]
    createMany?: HotelPricePoolCreateManyTenantInputEnvelope
    connect?: HotelPricePoolWhereUniqueInput | HotelPricePoolWhereUniqueInput[]
  }

  export type HotelRequestUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<HotelRequestCreateWithoutTenantInput, HotelRequestUncheckedCreateWithoutTenantInput> | HotelRequestCreateWithoutTenantInput[] | HotelRequestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelRequestCreateOrConnectWithoutTenantInput | HotelRequestCreateOrConnectWithoutTenantInput[]
    createMany?: HotelRequestCreateManyTenantInputEnvelope
    connect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
  }

  export type TenantModuleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantModuleCreateWithoutTenantInput, TenantModuleUncheckedCreateWithoutTenantInput> | TenantModuleCreateWithoutTenantInput[] | TenantModuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantModuleCreateOrConnectWithoutTenantInput | TenantModuleCreateOrConnectWithoutTenantInput[]
    createMany?: TenantModuleCreateManyTenantInputEnvelope
    connect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
  }

  export type TenantUserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantUserCreateWithoutTenantInput, TenantUserUncheckedCreateWithoutTenantInput> | TenantUserCreateWithoutTenantInput[] | TenantUserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantUserCreateOrConnectWithoutTenantInput | TenantUserCreateOrConnectWithoutTenantInput[]
    createMany?: TenantUserCreateManyTenantInputEnvelope
    connect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
  }

  export type TourBookingUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TourBookingCreateWithoutTenantInput, TourBookingUncheckedCreateWithoutTenantInput> | TourBookingCreateWithoutTenantInput[] | TourBookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutTenantInput | TourBookingCreateOrConnectWithoutTenantInput[]
    createMany?: TourBookingCreateManyTenantInputEnvelope
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput> | VehicleCreateWithoutTenantInput[] | VehicleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutTenantInput | VehicleCreateOrConnectWithoutTenantInput[]
    createMany?: VehicleCreateManyTenantInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantWebsiteCreateWithoutTenantInput, TenantWebsiteUncheckedCreateWithoutTenantInput> | TenantWebsiteCreateWithoutTenantInput[] | TenantWebsiteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutTenantInput | TenantWebsiteCreateOrConnectWithoutTenantInput[]
    createMany?: TenantWebsiteCreateManyTenantInputEnvelope
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ActivityUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput> | ActivityCreateWithoutTenantInput[] | ActivityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenantInput | ActivityCreateOrConnectWithoutTenantInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTenantInput | ActivityUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ActivityCreateManyTenantInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTenantInput | ActivityUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTenantInput | ActivityUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ReservationCreateWithoutTenantInput, ReservationUncheckedCreateWithoutTenantInput> | ReservationCreateWithoutTenantInput[] | ReservationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutTenantInput | ReservationCreateOrConnectWithoutTenantInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutTenantInput | ReservationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ReservationCreateManyTenantInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutTenantInput | ReservationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutTenantInput | ReservationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type DriverUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DriverCreateWithoutTenantInput, DriverUncheckedCreateWithoutTenantInput> | DriverCreateWithoutTenantInput[] | DriverUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutTenantInput | DriverCreateOrConnectWithoutTenantInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutTenantInput | DriverUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DriverCreateManyTenantInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutTenantInput | DriverUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutTenantInput | DriverUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type HotelBookingUpdateManyWithoutTenantNestedInput = {
    create?: XOR<HotelBookingCreateWithoutTenantInput, HotelBookingUncheckedCreateWithoutTenantInput> | HotelBookingCreateWithoutTenantInput[] | HotelBookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutTenantInput | HotelBookingCreateOrConnectWithoutTenantInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutTenantInput | HotelBookingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: HotelBookingCreateManyTenantInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutTenantInput | HotelBookingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutTenantInput | HotelBookingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelPricePoolUpdateManyWithoutTenantNestedInput = {
    create?: XOR<HotelPricePoolCreateWithoutTenantInput, HotelPricePoolUncheckedCreateWithoutTenantInput> | HotelPricePoolCreateWithoutTenantInput[] | HotelPricePoolUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelPricePoolCreateOrConnectWithoutTenantInput | HotelPricePoolCreateOrConnectWithoutTenantInput[]
    upsert?: HotelPricePoolUpsertWithWhereUniqueWithoutTenantInput | HotelPricePoolUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: HotelPricePoolCreateManyTenantInputEnvelope
    set?: HotelPricePoolWhereUniqueInput | HotelPricePoolWhereUniqueInput[]
    disconnect?: HotelPricePoolWhereUniqueInput | HotelPricePoolWhereUniqueInput[]
    delete?: HotelPricePoolWhereUniqueInput | HotelPricePoolWhereUniqueInput[]
    connect?: HotelPricePoolWhereUniqueInput | HotelPricePoolWhereUniqueInput[]
    update?: HotelPricePoolUpdateWithWhereUniqueWithoutTenantInput | HotelPricePoolUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: HotelPricePoolUpdateManyWithWhereWithoutTenantInput | HotelPricePoolUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: HotelPricePoolScalarWhereInput | HotelPricePoolScalarWhereInput[]
  }

  export type HotelRequestUpdateManyWithoutTenantNestedInput = {
    create?: XOR<HotelRequestCreateWithoutTenantInput, HotelRequestUncheckedCreateWithoutTenantInput> | HotelRequestCreateWithoutTenantInput[] | HotelRequestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelRequestCreateOrConnectWithoutTenantInput | HotelRequestCreateOrConnectWithoutTenantInput[]
    upsert?: HotelRequestUpsertWithWhereUniqueWithoutTenantInput | HotelRequestUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: HotelRequestCreateManyTenantInputEnvelope
    set?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    disconnect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    delete?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    connect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    update?: HotelRequestUpdateWithWhereUniqueWithoutTenantInput | HotelRequestUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: HotelRequestUpdateManyWithWhereWithoutTenantInput | HotelRequestUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: HotelRequestScalarWhereInput | HotelRequestScalarWhereInput[]
  }

  export type TenantModuleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantModuleCreateWithoutTenantInput, TenantModuleUncheckedCreateWithoutTenantInput> | TenantModuleCreateWithoutTenantInput[] | TenantModuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantModuleCreateOrConnectWithoutTenantInput | TenantModuleCreateOrConnectWithoutTenantInput[]
    upsert?: TenantModuleUpsertWithWhereUniqueWithoutTenantInput | TenantModuleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantModuleCreateManyTenantInputEnvelope
    set?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    disconnect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    delete?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    connect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    update?: TenantModuleUpdateWithWhereUniqueWithoutTenantInput | TenantModuleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantModuleUpdateManyWithWhereWithoutTenantInput | TenantModuleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantModuleScalarWhereInput | TenantModuleScalarWhereInput[]
  }

  export type TenantUserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantUserCreateWithoutTenantInput, TenantUserUncheckedCreateWithoutTenantInput> | TenantUserCreateWithoutTenantInput[] | TenantUserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantUserCreateOrConnectWithoutTenantInput | TenantUserCreateOrConnectWithoutTenantInput[]
    upsert?: TenantUserUpsertWithWhereUniqueWithoutTenantInput | TenantUserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantUserCreateManyTenantInputEnvelope
    set?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    disconnect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    delete?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    connect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    update?: TenantUserUpdateWithWhereUniqueWithoutTenantInput | TenantUserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantUserUpdateManyWithWhereWithoutTenantInput | TenantUserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantUserScalarWhereInput | TenantUserScalarWhereInput[]
  }

  export type TourBookingUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TourBookingCreateWithoutTenantInput, TourBookingUncheckedCreateWithoutTenantInput> | TourBookingCreateWithoutTenantInput[] | TourBookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutTenantInput | TourBookingCreateOrConnectWithoutTenantInput[]
    upsert?: TourBookingUpsertWithWhereUniqueWithoutTenantInput | TourBookingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TourBookingCreateManyTenantInputEnvelope
    set?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    disconnect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    delete?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    update?: TourBookingUpdateWithWhereUniqueWithoutTenantInput | TourBookingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TourBookingUpdateManyWithWhereWithoutTenantInput | TourBookingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TourBookingScalarWhereInput | TourBookingScalarWhereInput[]
  }

  export type VehicleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput> | VehicleCreateWithoutTenantInput[] | VehicleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutTenantInput | VehicleCreateOrConnectWithoutTenantInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutTenantInput | VehicleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VehicleCreateManyTenantInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutTenantInput | VehicleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutTenantInput | VehicleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type TenantWebsiteUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutTenantInput, TenantWebsiteUncheckedCreateWithoutTenantInput> | TenantWebsiteCreateWithoutTenantInput[] | TenantWebsiteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutTenantInput | TenantWebsiteCreateOrConnectWithoutTenantInput[]
    upsert?: TenantWebsiteUpsertWithWhereUniqueWithoutTenantInput | TenantWebsiteUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantWebsiteCreateManyTenantInputEnvelope
    set?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    disconnect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    delete?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    update?: TenantWebsiteUpdateWithWhereUniqueWithoutTenantInput | TenantWebsiteUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantWebsiteUpdateManyWithWhereWithoutTenantInput | TenantWebsiteUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantWebsiteScalarWhereInput | TenantWebsiteScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput> | ActivityCreateWithoutTenantInput[] | ActivityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenantInput | ActivityCreateOrConnectWithoutTenantInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTenantInput | ActivityUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ActivityCreateManyTenantInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTenantInput | ActivityUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTenantInput | ActivityUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ReservationCreateWithoutTenantInput, ReservationUncheckedCreateWithoutTenantInput> | ReservationCreateWithoutTenantInput[] | ReservationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutTenantInput | ReservationCreateOrConnectWithoutTenantInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutTenantInput | ReservationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ReservationCreateManyTenantInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutTenantInput | ReservationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutTenantInput | ReservationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type DriverUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DriverCreateWithoutTenantInput, DriverUncheckedCreateWithoutTenantInput> | DriverCreateWithoutTenantInput[] | DriverUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutTenantInput | DriverCreateOrConnectWithoutTenantInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutTenantInput | DriverUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DriverCreateManyTenantInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutTenantInput | DriverUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutTenantInput | DriverUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type HotelBookingUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<HotelBookingCreateWithoutTenantInput, HotelBookingUncheckedCreateWithoutTenantInput> | HotelBookingCreateWithoutTenantInput[] | HotelBookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutTenantInput | HotelBookingCreateOrConnectWithoutTenantInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutTenantInput | HotelBookingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: HotelBookingCreateManyTenantInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutTenantInput | HotelBookingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutTenantInput | HotelBookingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<HotelPricePoolCreateWithoutTenantInput, HotelPricePoolUncheckedCreateWithoutTenantInput> | HotelPricePoolCreateWithoutTenantInput[] | HotelPricePoolUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelPricePoolCreateOrConnectWithoutTenantInput | HotelPricePoolCreateOrConnectWithoutTenantInput[]
    upsert?: HotelPricePoolUpsertWithWhereUniqueWithoutTenantInput | HotelPricePoolUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: HotelPricePoolCreateManyTenantInputEnvelope
    set?: HotelPricePoolWhereUniqueInput | HotelPricePoolWhereUniqueInput[]
    disconnect?: HotelPricePoolWhereUniqueInput | HotelPricePoolWhereUniqueInput[]
    delete?: HotelPricePoolWhereUniqueInput | HotelPricePoolWhereUniqueInput[]
    connect?: HotelPricePoolWhereUniqueInput | HotelPricePoolWhereUniqueInput[]
    update?: HotelPricePoolUpdateWithWhereUniqueWithoutTenantInput | HotelPricePoolUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: HotelPricePoolUpdateManyWithWhereWithoutTenantInput | HotelPricePoolUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: HotelPricePoolScalarWhereInput | HotelPricePoolScalarWhereInput[]
  }

  export type HotelRequestUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<HotelRequestCreateWithoutTenantInput, HotelRequestUncheckedCreateWithoutTenantInput> | HotelRequestCreateWithoutTenantInput[] | HotelRequestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HotelRequestCreateOrConnectWithoutTenantInput | HotelRequestCreateOrConnectWithoutTenantInput[]
    upsert?: HotelRequestUpsertWithWhereUniqueWithoutTenantInput | HotelRequestUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: HotelRequestCreateManyTenantInputEnvelope
    set?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    disconnect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    delete?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    connect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    update?: HotelRequestUpdateWithWhereUniqueWithoutTenantInput | HotelRequestUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: HotelRequestUpdateManyWithWhereWithoutTenantInput | HotelRequestUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: HotelRequestScalarWhereInput | HotelRequestScalarWhereInput[]
  }

  export type TenantModuleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantModuleCreateWithoutTenantInput, TenantModuleUncheckedCreateWithoutTenantInput> | TenantModuleCreateWithoutTenantInput[] | TenantModuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantModuleCreateOrConnectWithoutTenantInput | TenantModuleCreateOrConnectWithoutTenantInput[]
    upsert?: TenantModuleUpsertWithWhereUniqueWithoutTenantInput | TenantModuleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantModuleCreateManyTenantInputEnvelope
    set?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    disconnect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    delete?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    connect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    update?: TenantModuleUpdateWithWhereUniqueWithoutTenantInput | TenantModuleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantModuleUpdateManyWithWhereWithoutTenantInput | TenantModuleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantModuleScalarWhereInput | TenantModuleScalarWhereInput[]
  }

  export type TenantUserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantUserCreateWithoutTenantInput, TenantUserUncheckedCreateWithoutTenantInput> | TenantUserCreateWithoutTenantInput[] | TenantUserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantUserCreateOrConnectWithoutTenantInput | TenantUserCreateOrConnectWithoutTenantInput[]
    upsert?: TenantUserUpsertWithWhereUniqueWithoutTenantInput | TenantUserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantUserCreateManyTenantInputEnvelope
    set?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    disconnect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    delete?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    connect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    update?: TenantUserUpdateWithWhereUniqueWithoutTenantInput | TenantUserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantUserUpdateManyWithWhereWithoutTenantInput | TenantUserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantUserScalarWhereInput | TenantUserScalarWhereInput[]
  }

  export type TourBookingUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TourBookingCreateWithoutTenantInput, TourBookingUncheckedCreateWithoutTenantInput> | TourBookingCreateWithoutTenantInput[] | TourBookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutTenantInput | TourBookingCreateOrConnectWithoutTenantInput[]
    upsert?: TourBookingUpsertWithWhereUniqueWithoutTenantInput | TourBookingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TourBookingCreateManyTenantInputEnvelope
    set?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    disconnect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    delete?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    update?: TourBookingUpdateWithWhereUniqueWithoutTenantInput | TourBookingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TourBookingUpdateManyWithWhereWithoutTenantInput | TourBookingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TourBookingScalarWhereInput | TourBookingScalarWhereInput[]
  }

  export type VehicleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput> | VehicleCreateWithoutTenantInput[] | VehicleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutTenantInput | VehicleCreateOrConnectWithoutTenantInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutTenantInput | VehicleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VehicleCreateManyTenantInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutTenantInput | VehicleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutTenantInput | VehicleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutTenantInput, TenantWebsiteUncheckedCreateWithoutTenantInput> | TenantWebsiteCreateWithoutTenantInput[] | TenantWebsiteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutTenantInput | TenantWebsiteCreateOrConnectWithoutTenantInput[]
    upsert?: TenantWebsiteUpsertWithWhereUniqueWithoutTenantInput | TenantWebsiteUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantWebsiteCreateManyTenantInputEnvelope
    set?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    disconnect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    delete?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    update?: TenantWebsiteUpdateWithWhereUniqueWithoutTenantInput | TenantWebsiteUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantWebsiteUpdateManyWithWhereWithoutTenantInput | TenantWebsiteUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantWebsiteScalarWhereInput | TenantWebsiteScalarWhereInput[]
  }

  export type TenantModuleCreateNestedManyWithoutModuleInput = {
    create?: XOR<TenantModuleCreateWithoutModuleInput, TenantModuleUncheckedCreateWithoutModuleInput> | TenantModuleCreateWithoutModuleInput[] | TenantModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TenantModuleCreateOrConnectWithoutModuleInput | TenantModuleCreateOrConnectWithoutModuleInput[]
    createMany?: TenantModuleCreateManyModuleInputEnvelope
    connect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
  }

  export type TenantModuleUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<TenantModuleCreateWithoutModuleInput, TenantModuleUncheckedCreateWithoutModuleInput> | TenantModuleCreateWithoutModuleInput[] | TenantModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TenantModuleCreateOrConnectWithoutModuleInput | TenantModuleCreateOrConnectWithoutModuleInput[]
    createMany?: TenantModuleCreateManyModuleInputEnvelope
    connect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantModuleUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TenantModuleCreateWithoutModuleInput, TenantModuleUncheckedCreateWithoutModuleInput> | TenantModuleCreateWithoutModuleInput[] | TenantModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TenantModuleCreateOrConnectWithoutModuleInput | TenantModuleCreateOrConnectWithoutModuleInput[]
    upsert?: TenantModuleUpsertWithWhereUniqueWithoutModuleInput | TenantModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TenantModuleCreateManyModuleInputEnvelope
    set?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    disconnect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    delete?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    connect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    update?: TenantModuleUpdateWithWhereUniqueWithoutModuleInput | TenantModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TenantModuleUpdateManyWithWhereWithoutModuleInput | TenantModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TenantModuleScalarWhereInput | TenantModuleScalarWhereInput[]
  }

  export type TenantModuleUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TenantModuleCreateWithoutModuleInput, TenantModuleUncheckedCreateWithoutModuleInput> | TenantModuleCreateWithoutModuleInput[] | TenantModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TenantModuleCreateOrConnectWithoutModuleInput | TenantModuleCreateOrConnectWithoutModuleInput[]
    upsert?: TenantModuleUpsertWithWhereUniqueWithoutModuleInput | TenantModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TenantModuleCreateManyModuleInputEnvelope
    set?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    disconnect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    delete?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    connect?: TenantModuleWhereUniqueInput | TenantModuleWhereUniqueInput[]
    update?: TenantModuleUpdateWithWhereUniqueWithoutModuleInput | TenantModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TenantModuleUpdateManyWithWhereWithoutModuleInput | TenantModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TenantModuleScalarWhereInput | TenantModuleScalarWhereInput[]
  }

  export type ModuleCreateNestedOneWithoutTenantModulesInput = {
    create?: XOR<ModuleCreateWithoutTenantModulesInput, ModuleUncheckedCreateWithoutTenantModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTenantModulesInput
    connect?: ModuleWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutModulesInput = {
    create?: XOR<TenantCreateWithoutModulesInput, TenantUncheckedCreateWithoutModulesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutModulesInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ModuleUpdateOneRequiredWithoutTenantModulesNestedInput = {
    create?: XOR<ModuleCreateWithoutTenantModulesInput, ModuleUncheckedCreateWithoutTenantModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTenantModulesInput
    upsert?: ModuleUpsertWithoutTenantModulesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutTenantModulesInput, ModuleUpdateWithoutTenantModulesInput>, ModuleUncheckedUpdateWithoutTenantModulesInput>
  }

  export type TenantUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<TenantCreateWithoutModulesInput, TenantUncheckedCreateWithoutModulesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutModulesInput
    upsert?: TenantUpsertWithoutModulesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutModulesInput, TenantUpdateWithoutModulesInput>, TenantUncheckedUpdateWithoutModulesInput>
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTenantUsersInput = {
    create?: XOR<UserCreateWithoutTenantUsersInput, UserUncheckedCreateWithoutTenantUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantUsersInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutTenantUsersNestedInput = {
    create?: XOR<UserCreateWithoutTenantUsersInput, UserUncheckedCreateWithoutTenantUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantUsersInput
    upsert?: UserUpsertWithoutTenantUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTenantUsersInput, UserUpdateWithoutTenantUsersInput>, UserUncheckedUpdateWithoutTenantUsersInput>
  }

  export type ReservationCreateNestedManyWithoutDriverInput = {
    create?: XOR<ReservationCreateWithoutDriverInput, ReservationUncheckedCreateWithoutDriverInput> | ReservationCreateWithoutDriverInput[] | ReservationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutDriverInput | ReservationCreateOrConnectWithoutDriverInput[]
    createMany?: ReservationCreateManyDriverInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutDriversInput = {
    create?: XOR<TenantCreateWithoutDriversInput, TenantUncheckedCreateWithoutDriversInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDriversInput
    connect?: TenantWhereUniqueInput
  }

  export type TourBookingCreateNestedManyWithoutDriverInput = {
    create?: XOR<TourBookingCreateWithoutDriverInput, TourBookingUncheckedCreateWithoutDriverInput> | TourBookingCreateWithoutDriverInput[] | TourBookingUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutDriverInput | TourBookingCreateOrConnectWithoutDriverInput[]
    createMany?: TourBookingCreateManyDriverInputEnvelope
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<ReservationCreateWithoutDriverInput, ReservationUncheckedCreateWithoutDriverInput> | ReservationCreateWithoutDriverInput[] | ReservationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutDriverInput | ReservationCreateOrConnectWithoutDriverInput[]
    createMany?: ReservationCreateManyDriverInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type TourBookingUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<TourBookingCreateWithoutDriverInput, TourBookingUncheckedCreateWithoutDriverInput> | TourBookingCreateWithoutDriverInput[] | TourBookingUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutDriverInput | TourBookingCreateOrConnectWithoutDriverInput[]
    createMany?: TourBookingCreateManyDriverInputEnvelope
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
  }

  export type ReservationUpdateManyWithoutDriverNestedInput = {
    create?: XOR<ReservationCreateWithoutDriverInput, ReservationUncheckedCreateWithoutDriverInput> | ReservationCreateWithoutDriverInput[] | ReservationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutDriverInput | ReservationCreateOrConnectWithoutDriverInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutDriverInput | ReservationUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: ReservationCreateManyDriverInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutDriverInput | ReservationUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutDriverInput | ReservationUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type TenantUpdateOneWithoutDriversNestedInput = {
    create?: XOR<TenantCreateWithoutDriversInput, TenantUncheckedCreateWithoutDriversInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDriversInput
    upsert?: TenantUpsertWithoutDriversInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDriversInput, TenantUpdateWithoutDriversInput>, TenantUncheckedUpdateWithoutDriversInput>
  }

  export type TourBookingUpdateManyWithoutDriverNestedInput = {
    create?: XOR<TourBookingCreateWithoutDriverInput, TourBookingUncheckedCreateWithoutDriverInput> | TourBookingCreateWithoutDriverInput[] | TourBookingUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutDriverInput | TourBookingCreateOrConnectWithoutDriverInput[]
    upsert?: TourBookingUpsertWithWhereUniqueWithoutDriverInput | TourBookingUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: TourBookingCreateManyDriverInputEnvelope
    set?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    disconnect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    delete?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    update?: TourBookingUpdateWithWhereUniqueWithoutDriverInput | TourBookingUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: TourBookingUpdateManyWithWhereWithoutDriverInput | TourBookingUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: TourBookingScalarWhereInput | TourBookingScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<ReservationCreateWithoutDriverInput, ReservationUncheckedCreateWithoutDriverInput> | ReservationCreateWithoutDriverInput[] | ReservationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutDriverInput | ReservationCreateOrConnectWithoutDriverInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutDriverInput | ReservationUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: ReservationCreateManyDriverInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutDriverInput | ReservationUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutDriverInput | ReservationUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type TourBookingUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<TourBookingCreateWithoutDriverInput, TourBookingUncheckedCreateWithoutDriverInput> | TourBookingCreateWithoutDriverInput[] | TourBookingUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutDriverInput | TourBookingCreateOrConnectWithoutDriverInput[]
    upsert?: TourBookingUpsertWithWhereUniqueWithoutDriverInput | TourBookingUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: TourBookingCreateManyDriverInputEnvelope
    set?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    disconnect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    delete?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    update?: TourBookingUpdateWithWhereUniqueWithoutDriverInput | TourBookingUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: TourBookingUpdateManyWithWhereWithoutDriverInput | TourBookingUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: TourBookingScalarWhereInput | TourBookingScalarWhereInput[]
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutUserInput = {
    create?: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput> | ReservationCreateWithoutUserInput[] | ReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUserInput | ReservationCreateOrConnectWithoutUserInput[]
    createMany?: ReservationCreateManyUserInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatorInput = {
    create?: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput> | UserCreateWithoutCreatorInput[] | UserUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatorInput | UserCreateOrConnectWithoutCreatorInput[]
    createMany?: UserCreateManyCreatorInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserPermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
  }

  export type HotelRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<HotelRequestCreateWithoutUserInput, HotelRequestUncheckedCreateWithoutUserInput> | HotelRequestCreateWithoutUserInput[] | HotelRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HotelRequestCreateOrConnectWithoutUserInput | HotelRequestCreateOrConnectWithoutUserInput[]
    createMany?: HotelRequestCreateManyUserInputEnvelope
    connect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
  }

  export type TenantUserCreateNestedManyWithoutUserInput = {
    create?: XOR<TenantUserCreateWithoutUserInput, TenantUserUncheckedCreateWithoutUserInput> | TenantUserCreateWithoutUserInput[] | TenantUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantUserCreateOrConnectWithoutUserInput | TenantUserCreateOrConnectWithoutUserInput[]
    createMany?: TenantUserCreateManyUserInputEnvelope
    connect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
  }

  export type TourBookingCreateNestedManyWithoutUserInput = {
    create?: XOR<TourBookingCreateWithoutUserInput, TourBookingUncheckedCreateWithoutUserInput> | TourBookingCreateWithoutUserInput[] | TourBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutUserInput | TourBookingCreateOrConnectWithoutUserInput[]
    createMany?: TourBookingCreateManyUserInputEnvelope
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput> | ReservationCreateWithoutUserInput[] | ReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUserInput | ReservationCreateOrConnectWithoutUserInput[]
    createMany?: ReservationCreateManyUserInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput> | UserCreateWithoutCreatorInput[] | UserUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatorInput | UserCreateOrConnectWithoutCreatorInput[]
    createMany?: UserCreateManyCreatorInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserPermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
  }

  export type HotelRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HotelRequestCreateWithoutUserInput, HotelRequestUncheckedCreateWithoutUserInput> | HotelRequestCreateWithoutUserInput[] | HotelRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HotelRequestCreateOrConnectWithoutUserInput | HotelRequestCreateOrConnectWithoutUserInput[]
    createMany?: HotelRequestCreateManyUserInputEnvelope
    connect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
  }

  export type TenantUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TenantUserCreateWithoutUserInput, TenantUserUncheckedCreateWithoutUserInput> | TenantUserCreateWithoutUserInput[] | TenantUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantUserCreateOrConnectWithoutUserInput | TenantUserCreateOrConnectWithoutUserInput[]
    createMany?: TenantUserCreateManyUserInputEnvelope
    connect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
  }

  export type TourBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TourBookingCreateWithoutUserInput, TourBookingUncheckedCreateWithoutUserInput> | TourBookingCreateWithoutUserInput[] | TourBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutUserInput | TourBookingCreateOrConnectWithoutUserInput[]
    createMany?: TourBookingCreateManyUserInputEnvelope
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput> | ReservationCreateWithoutUserInput[] | ReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUserInput | ReservationCreateOrConnectWithoutUserInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutUserInput | ReservationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReservationCreateManyUserInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutUserInput | ReservationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutUserInput | ReservationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    upsert?: UserUpsertWithoutCreatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput> | UserCreateWithoutCreatorInput[] | UserUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatorInput | UserCreateOrConnectWithoutCreatorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatorInput | UserUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: UserCreateManyCreatorInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatorInput | UserUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatorInput | UserUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserPermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    upsert?: UserPermissionUpsertWithWhereUniqueWithoutUserInput | UserPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    set?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    disconnect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    delete?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    update?: UserPermissionUpdateWithWhereUniqueWithoutUserInput | UserPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPermissionUpdateManyWithWhereWithoutUserInput | UserPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
  }

  export type HotelRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<HotelRequestCreateWithoutUserInput, HotelRequestUncheckedCreateWithoutUserInput> | HotelRequestCreateWithoutUserInput[] | HotelRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HotelRequestCreateOrConnectWithoutUserInput | HotelRequestCreateOrConnectWithoutUserInput[]
    upsert?: HotelRequestUpsertWithWhereUniqueWithoutUserInput | HotelRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HotelRequestCreateManyUserInputEnvelope
    set?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    disconnect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    delete?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    connect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    update?: HotelRequestUpdateWithWhereUniqueWithoutUserInput | HotelRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HotelRequestUpdateManyWithWhereWithoutUserInput | HotelRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HotelRequestScalarWhereInput | HotelRequestScalarWhereInput[]
  }

  export type TenantUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<TenantUserCreateWithoutUserInput, TenantUserUncheckedCreateWithoutUserInput> | TenantUserCreateWithoutUserInput[] | TenantUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantUserCreateOrConnectWithoutUserInput | TenantUserCreateOrConnectWithoutUserInput[]
    upsert?: TenantUserUpsertWithWhereUniqueWithoutUserInput | TenantUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TenantUserCreateManyUserInputEnvelope
    set?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    disconnect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    delete?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    connect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    update?: TenantUserUpdateWithWhereUniqueWithoutUserInput | TenantUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TenantUserUpdateManyWithWhereWithoutUserInput | TenantUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TenantUserScalarWhereInput | TenantUserScalarWhereInput[]
  }

  export type TourBookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<TourBookingCreateWithoutUserInput, TourBookingUncheckedCreateWithoutUserInput> | TourBookingCreateWithoutUserInput[] | TourBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutUserInput | TourBookingCreateOrConnectWithoutUserInput[]
    upsert?: TourBookingUpsertWithWhereUniqueWithoutUserInput | TourBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TourBookingCreateManyUserInputEnvelope
    set?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    disconnect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    delete?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    update?: TourBookingUpdateWithWhereUniqueWithoutUserInput | TourBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TourBookingUpdateManyWithWhereWithoutUserInput | TourBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TourBookingScalarWhereInput | TourBookingScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput> | ReservationCreateWithoutUserInput[] | ReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUserInput | ReservationCreateOrConnectWithoutUserInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutUserInput | ReservationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReservationCreateManyUserInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutUserInput | ReservationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutUserInput | ReservationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput> | UserCreateWithoutCreatorInput[] | UserUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatorInput | UserCreateOrConnectWithoutCreatorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatorInput | UserUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: UserCreateManyCreatorInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatorInput | UserUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatorInput | UserUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserPermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    upsert?: UserPermissionUpsertWithWhereUniqueWithoutUserInput | UserPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    set?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    disconnect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    delete?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    update?: UserPermissionUpdateWithWhereUniqueWithoutUserInput | UserPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPermissionUpdateManyWithWhereWithoutUserInput | UserPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
  }

  export type HotelRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HotelRequestCreateWithoutUserInput, HotelRequestUncheckedCreateWithoutUserInput> | HotelRequestCreateWithoutUserInput[] | HotelRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HotelRequestCreateOrConnectWithoutUserInput | HotelRequestCreateOrConnectWithoutUserInput[]
    upsert?: HotelRequestUpsertWithWhereUniqueWithoutUserInput | HotelRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HotelRequestCreateManyUserInputEnvelope
    set?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    disconnect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    delete?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    connect?: HotelRequestWhereUniqueInput | HotelRequestWhereUniqueInput[]
    update?: HotelRequestUpdateWithWhereUniqueWithoutUserInput | HotelRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HotelRequestUpdateManyWithWhereWithoutUserInput | HotelRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HotelRequestScalarWhereInput | HotelRequestScalarWhereInput[]
  }

  export type TenantUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TenantUserCreateWithoutUserInput, TenantUserUncheckedCreateWithoutUserInput> | TenantUserCreateWithoutUserInput[] | TenantUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantUserCreateOrConnectWithoutUserInput | TenantUserCreateOrConnectWithoutUserInput[]
    upsert?: TenantUserUpsertWithWhereUniqueWithoutUserInput | TenantUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TenantUserCreateManyUserInputEnvelope
    set?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    disconnect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    delete?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    connect?: TenantUserWhereUniqueInput | TenantUserWhereUniqueInput[]
    update?: TenantUserUpdateWithWhereUniqueWithoutUserInput | TenantUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TenantUserUpdateManyWithWhereWithoutUserInput | TenantUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TenantUserScalarWhereInput | TenantUserScalarWhereInput[]
  }

  export type TourBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TourBookingCreateWithoutUserInput, TourBookingUncheckedCreateWithoutUserInput> | TourBookingCreateWithoutUserInput[] | TourBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TourBookingCreateOrConnectWithoutUserInput | TourBookingCreateOrConnectWithoutUserInput[]
    upsert?: TourBookingUpsertWithWhereUniqueWithoutUserInput | TourBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TourBookingCreateManyUserInputEnvelope
    set?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    disconnect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    delete?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    connect?: TourBookingWhereUniqueInput | TourBookingWhereUniqueInput[]
    update?: TourBookingUpdateWithWhereUniqueWithoutUserInput | TourBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TourBookingUpdateManyWithWhereWithoutUserInput | TourBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TourBookingScalarWhereInput | TourBookingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    upsert?: UserUpsertWithoutPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPermissionsInput, UserUpdateWithoutPermissionsInput>, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type TenantCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<TenantCreateWithoutActivitiesInput, TenantUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutActivitiesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<TenantCreateWithoutActivitiesInput, TenantUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutActivitiesInput
    upsert?: TenantUpsertWithoutActivitiesInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutActivitiesInput, TenantUpdateWithoutActivitiesInput>, TenantUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type DriverCreateNestedOneWithoutReservationsInput = {
    create?: XOR<DriverCreateWithoutReservationsInput, DriverUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutReservationsInput
    connect?: DriverWhereUniqueInput
  }

  export type ReservationCreateNestedOneWithoutOriginalTransferInput = {
    create?: XOR<ReservationCreateWithoutOriginalTransferInput, ReservationUncheckedCreateWithoutOriginalTransferInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutOriginalTransferInput
    connect?: ReservationWhereUniqueInput
  }

  export type ReservationCreateNestedOneWithoutReturnTransferInput = {
    create?: XOR<ReservationCreateWithoutReturnTransferInput, ReservationUncheckedCreateWithoutReturnTransferInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutReturnTransferInput
    connect?: ReservationWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutReservationsInput = {
    create?: XOR<TenantCreateWithoutReservationsInput, TenantUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutReservationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReservationsInput = {
    create?: XOR<UserCreateWithoutReservationsInput, UserUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReservationsInput
    connect?: UserWhereUniqueInput
  }

  export type HotelBookingCreateNestedManyWithoutReservationInput = {
    create?: XOR<HotelBookingCreateWithoutReservationInput, HotelBookingUncheckedCreateWithoutReservationInput> | HotelBookingCreateWithoutReservationInput[] | HotelBookingUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutReservationInput | HotelBookingCreateOrConnectWithoutReservationInput[]
    createMany?: HotelBookingCreateManyReservationInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedOneWithoutReturnTransferInput = {
    create?: XOR<ReservationCreateWithoutReturnTransferInput, ReservationUncheckedCreateWithoutReturnTransferInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutReturnTransferInput
    connect?: ReservationWhereUniqueInput
  }

  export type HotelBookingUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<HotelBookingCreateWithoutReservationInput, HotelBookingUncheckedCreateWithoutReservationInput> | HotelBookingCreateWithoutReservationInput[] | HotelBookingUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutReservationInput | HotelBookingCreateOrConnectWithoutReservationInput[]
    createMany?: HotelBookingCreateManyReservationInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DriverUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<DriverCreateWithoutReservationsInput, DriverUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutReservationsInput
    upsert?: DriverUpsertWithoutReservationsInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutReservationsInput, DriverUpdateWithoutReservationsInput>, DriverUncheckedUpdateWithoutReservationsInput>
  }

  export type ReservationUpdateOneWithoutOriginalTransferNestedInput = {
    create?: XOR<ReservationCreateWithoutOriginalTransferInput, ReservationUncheckedCreateWithoutOriginalTransferInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutOriginalTransferInput
    upsert?: ReservationUpsertWithoutOriginalTransferInput
    disconnect?: ReservationWhereInput | boolean
    delete?: ReservationWhereInput | boolean
    connect?: ReservationWhereUniqueInput
    update?: XOR<XOR<ReservationUpdateToOneWithWhereWithoutOriginalTransferInput, ReservationUpdateWithoutOriginalTransferInput>, ReservationUncheckedUpdateWithoutOriginalTransferInput>
  }

  export type ReservationUpdateOneWithoutReturnTransferNestedInput = {
    create?: XOR<ReservationCreateWithoutReturnTransferInput, ReservationUncheckedCreateWithoutReturnTransferInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutReturnTransferInput
    upsert?: ReservationUpsertWithoutReturnTransferInput
    disconnect?: ReservationWhereInput | boolean
    delete?: ReservationWhereInput | boolean
    connect?: ReservationWhereUniqueInput
    update?: XOR<XOR<ReservationUpdateToOneWithWhereWithoutReturnTransferInput, ReservationUpdateWithoutReturnTransferInput>, ReservationUncheckedUpdateWithoutReturnTransferInput>
  }

  export type TenantUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<TenantCreateWithoutReservationsInput, TenantUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutReservationsInput
    upsert?: TenantUpsertWithoutReservationsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutReservationsInput, TenantUpdateWithoutReservationsInput>, TenantUncheckedUpdateWithoutReservationsInput>
  }

  export type UserUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<UserCreateWithoutReservationsInput, UserUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReservationsInput
    upsert?: UserUpsertWithoutReservationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReservationsInput, UserUpdateWithoutReservationsInput>, UserUncheckedUpdateWithoutReservationsInput>
  }

  export type HotelBookingUpdateManyWithoutReservationNestedInput = {
    create?: XOR<HotelBookingCreateWithoutReservationInput, HotelBookingUncheckedCreateWithoutReservationInput> | HotelBookingCreateWithoutReservationInput[] | HotelBookingUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutReservationInput | HotelBookingCreateOrConnectWithoutReservationInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutReservationInput | HotelBookingUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: HotelBookingCreateManyReservationInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutReservationInput | HotelBookingUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutReservationInput | HotelBookingUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateOneWithoutReturnTransferNestedInput = {
    create?: XOR<ReservationCreateWithoutReturnTransferInput, ReservationUncheckedCreateWithoutReturnTransferInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutReturnTransferInput
    upsert?: ReservationUpsertWithoutReturnTransferInput
    disconnect?: ReservationWhereInput | boolean
    delete?: ReservationWhereInput | boolean
    connect?: ReservationWhereUniqueInput
    update?: XOR<XOR<ReservationUpdateToOneWithWhereWithoutReturnTransferInput, ReservationUpdateWithoutReturnTransferInput>, ReservationUncheckedUpdateWithoutReturnTransferInput>
  }

  export type HotelBookingUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<HotelBookingCreateWithoutReservationInput, HotelBookingUncheckedCreateWithoutReservationInput> | HotelBookingCreateWithoutReservationInput[] | HotelBookingUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutReservationInput | HotelBookingCreateOrConnectWithoutReservationInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutReservationInput | HotelBookingUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: HotelBookingCreateManyReservationInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutReservationInput | HotelBookingUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutReservationInput | HotelBookingUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelBookingCreateNestedManyWithoutRequestInput = {
    create?: XOR<HotelBookingCreateWithoutRequestInput, HotelBookingUncheckedCreateWithoutRequestInput> | HotelBookingCreateWithoutRequestInput[] | HotelBookingUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRequestInput | HotelBookingCreateOrConnectWithoutRequestInput[]
    createMany?: HotelBookingCreateManyRequestInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutHotelRequestsInput = {
    create?: XOR<UserCreateWithoutHotelRequestsInput, UserUncheckedCreateWithoutHotelRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHotelRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutHotelRequestsInput = {
    create?: XOR<TenantCreateWithoutHotelRequestsInput, TenantUncheckedCreateWithoutHotelRequestsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutHotelRequestsInput
    connect?: TenantWhereUniqueInput
  }

  export type HotelBookingUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<HotelBookingCreateWithoutRequestInput, HotelBookingUncheckedCreateWithoutRequestInput> | HotelBookingCreateWithoutRequestInput[] | HotelBookingUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRequestInput | HotelBookingCreateOrConnectWithoutRequestInput[]
    createMany?: HotelBookingCreateManyRequestInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelBookingUpdateManyWithoutRequestNestedInput = {
    create?: XOR<HotelBookingCreateWithoutRequestInput, HotelBookingUncheckedCreateWithoutRequestInput> | HotelBookingCreateWithoutRequestInput[] | HotelBookingUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRequestInput | HotelBookingCreateOrConnectWithoutRequestInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutRequestInput | HotelBookingUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: HotelBookingCreateManyRequestInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutRequestInput | HotelBookingUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutRequestInput | HotelBookingUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type UserUpdateOneWithoutHotelRequestsNestedInput = {
    create?: XOR<UserCreateWithoutHotelRequestsInput, UserUncheckedCreateWithoutHotelRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHotelRequestsInput
    upsert?: UserUpsertWithoutHotelRequestsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHotelRequestsInput, UserUpdateWithoutHotelRequestsInput>, UserUncheckedUpdateWithoutHotelRequestsInput>
  }

  export type TenantUpdateOneWithoutHotelRequestsNestedInput = {
    create?: XOR<TenantCreateWithoutHotelRequestsInput, TenantUncheckedCreateWithoutHotelRequestsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutHotelRequestsInput
    upsert?: TenantUpsertWithoutHotelRequestsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutHotelRequestsInput, TenantUpdateWithoutHotelRequestsInput>, TenantUncheckedUpdateWithoutHotelRequestsInput>
  }

  export type HotelBookingUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<HotelBookingCreateWithoutRequestInput, HotelBookingUncheckedCreateWithoutRequestInput> | HotelBookingCreateWithoutRequestInput[] | HotelBookingUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRequestInput | HotelBookingCreateOrConnectWithoutRequestInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutRequestInput | HotelBookingUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: HotelBookingCreateManyRequestInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutRequestInput | HotelBookingUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutRequestInput | HotelBookingUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelRequestCreateNestedOneWithoutHotelBookingsInput = {
    create?: XOR<HotelRequestCreateWithoutHotelBookingsInput, HotelRequestUncheckedCreateWithoutHotelBookingsInput>
    connectOrCreate?: HotelRequestCreateOrConnectWithoutHotelBookingsInput
    connect?: HotelRequestWhereUniqueInput
  }

  export type ReservationCreateNestedOneWithoutHotelBookingsInput = {
    create?: XOR<ReservationCreateWithoutHotelBookingsInput, ReservationUncheckedCreateWithoutHotelBookingsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutHotelBookingsInput
    connect?: ReservationWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutHotelBookingsInput = {
    create?: XOR<TenantCreateWithoutHotelBookingsInput, TenantUncheckedCreateWithoutHotelBookingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutHotelBookingsInput
    connect?: TenantWhereUniqueInput
  }

  export type HotelRequestUpdateOneWithoutHotelBookingsNestedInput = {
    create?: XOR<HotelRequestCreateWithoutHotelBookingsInput, HotelRequestUncheckedCreateWithoutHotelBookingsInput>
    connectOrCreate?: HotelRequestCreateOrConnectWithoutHotelBookingsInput
    upsert?: HotelRequestUpsertWithoutHotelBookingsInput
    disconnect?: HotelRequestWhereInput | boolean
    delete?: HotelRequestWhereInput | boolean
    connect?: HotelRequestWhereUniqueInput
    update?: XOR<XOR<HotelRequestUpdateToOneWithWhereWithoutHotelBookingsInput, HotelRequestUpdateWithoutHotelBookingsInput>, HotelRequestUncheckedUpdateWithoutHotelBookingsInput>
  }

  export type ReservationUpdateOneWithoutHotelBookingsNestedInput = {
    create?: XOR<ReservationCreateWithoutHotelBookingsInput, ReservationUncheckedCreateWithoutHotelBookingsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutHotelBookingsInput
    upsert?: ReservationUpsertWithoutHotelBookingsInput
    disconnect?: ReservationWhereInput | boolean
    delete?: ReservationWhereInput | boolean
    connect?: ReservationWhereUniqueInput
    update?: XOR<XOR<ReservationUpdateToOneWithWhereWithoutHotelBookingsInput, ReservationUpdateWithoutHotelBookingsInput>, ReservationUncheckedUpdateWithoutHotelBookingsInput>
  }

  export type TenantUpdateOneWithoutHotelBookingsNestedInput = {
    create?: XOR<TenantCreateWithoutHotelBookingsInput, TenantUncheckedCreateWithoutHotelBookingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutHotelBookingsInput
    upsert?: TenantUpsertWithoutHotelBookingsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutHotelBookingsInput, TenantUpdateWithoutHotelBookingsInput>, TenantUncheckedUpdateWithoutHotelBookingsInput>
  }

  export type TenantCreateNestedOneWithoutHotelPricePoolInput = {
    create?: XOR<TenantCreateWithoutHotelPricePoolInput, TenantUncheckedCreateWithoutHotelPricePoolInput>
    connectOrCreate?: TenantCreateOrConnectWithoutHotelPricePoolInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutHotelPricePoolNestedInput = {
    create?: XOR<TenantCreateWithoutHotelPricePoolInput, TenantUncheckedCreateWithoutHotelPricePoolInput>
    connectOrCreate?: TenantCreateOrConnectWithoutHotelPricePoolInput
    upsert?: TenantUpsertWithoutHotelPricePoolInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutHotelPricePoolInput, TenantUpdateWithoutHotelPricePoolInput>, TenantUncheckedUpdateWithoutHotelPricePoolInput>
  }

  export type TenantCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<TenantCreateWithoutVehiclesInput, TenantUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVehiclesInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<TenantCreateWithoutVehiclesInput, TenantUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVehiclesInput
    upsert?: TenantUpsertWithoutVehiclesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVehiclesInput, TenantUpdateWithoutVehiclesInput>, TenantUncheckedUpdateWithoutVehiclesInput>
  }

  export type DriverCreateNestedOneWithoutTourBookingsInput = {
    create?: XOR<DriverCreateWithoutTourBookingsInput, DriverUncheckedCreateWithoutTourBookingsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutTourBookingsInput
    connect?: DriverWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutTourBookingsInput = {
    create?: XOR<TenantCreateWithoutTourBookingsInput, TenantUncheckedCreateWithoutTourBookingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTourBookingsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTour_bookingsInput = {
    create?: XOR<UserCreateWithoutTour_bookingsInput, UserUncheckedCreateWithoutTour_bookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTour_bookingsInput
    connect?: UserWhereUniqueInput
  }

  export type DriverUpdateOneWithoutTourBookingsNestedInput = {
    create?: XOR<DriverCreateWithoutTourBookingsInput, DriverUncheckedCreateWithoutTourBookingsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutTourBookingsInput
    upsert?: DriverUpsertWithoutTourBookingsInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutTourBookingsInput, DriverUpdateWithoutTourBookingsInput>, DriverUncheckedUpdateWithoutTourBookingsInput>
  }

  export type TenantUpdateOneRequiredWithoutTourBookingsNestedInput = {
    create?: XOR<TenantCreateWithoutTourBookingsInput, TenantUncheckedCreateWithoutTourBookingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTourBookingsInput
    upsert?: TenantUpsertWithoutTourBookingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTourBookingsInput, TenantUpdateWithoutTourBookingsInput>, TenantUncheckedUpdateWithoutTourBookingsInput>
  }

  export type UserUpdateOneWithoutTour_bookingsNestedInput = {
    create?: XOR<UserCreateWithoutTour_bookingsInput, UserUncheckedCreateWithoutTour_bookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTour_bookingsInput
    upsert?: UserUpsertWithoutTour_bookingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTour_bookingsInput, UserUpdateWithoutTour_bookingsInput>, UserUncheckedUpdateWithoutTour_bookingsInput>
  }

  export type TenantCreateNestedOneWithoutWebsitesInput = {
    create?: XOR<TenantCreateWithoutWebsitesInput, TenantUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWebsitesInput
    connect?: TenantWhereUniqueInput
  }

  export type WebsitePageCreateNestedManyWithoutWebsiteInput = {
    create?: XOR<WebsitePageCreateWithoutWebsiteInput, WebsitePageUncheckedCreateWithoutWebsiteInput> | WebsitePageCreateWithoutWebsiteInput[] | WebsitePageUncheckedCreateWithoutWebsiteInput[]
    connectOrCreate?: WebsitePageCreateOrConnectWithoutWebsiteInput | WebsitePageCreateOrConnectWithoutWebsiteInput[]
    createMany?: WebsitePageCreateManyWebsiteInputEnvelope
    connect?: WebsitePageWhereUniqueInput | WebsitePageWhereUniqueInput[]
  }

  export type WebsiteSettingsCreateNestedOneWithoutWebsiteInput = {
    create?: XOR<WebsiteSettingsCreateWithoutWebsiteInput, WebsiteSettingsUncheckedCreateWithoutWebsiteInput>
    connectOrCreate?: WebsiteSettingsCreateOrConnectWithoutWebsiteInput
    connect?: WebsiteSettingsWhereUniqueInput
  }

  export type WebsiteSectionCreateNestedManyWithoutWebsiteInput = {
    create?: XOR<WebsiteSectionCreateWithoutWebsiteInput, WebsiteSectionUncheckedCreateWithoutWebsiteInput> | WebsiteSectionCreateWithoutWebsiteInput[] | WebsiteSectionUncheckedCreateWithoutWebsiteInput[]
    connectOrCreate?: WebsiteSectionCreateOrConnectWithoutWebsiteInput | WebsiteSectionCreateOrConnectWithoutWebsiteInput[]
    createMany?: WebsiteSectionCreateManyWebsiteInputEnvelope
    connect?: WebsiteSectionWhereUniqueInput | WebsiteSectionWhereUniqueInput[]
  }

  export type WebsitePageUncheckedCreateNestedManyWithoutWebsiteInput = {
    create?: XOR<WebsitePageCreateWithoutWebsiteInput, WebsitePageUncheckedCreateWithoutWebsiteInput> | WebsitePageCreateWithoutWebsiteInput[] | WebsitePageUncheckedCreateWithoutWebsiteInput[]
    connectOrCreate?: WebsitePageCreateOrConnectWithoutWebsiteInput | WebsitePageCreateOrConnectWithoutWebsiteInput[]
    createMany?: WebsitePageCreateManyWebsiteInputEnvelope
    connect?: WebsitePageWhereUniqueInput | WebsitePageWhereUniqueInput[]
  }

  export type WebsiteSettingsUncheckedCreateNestedOneWithoutWebsiteInput = {
    create?: XOR<WebsiteSettingsCreateWithoutWebsiteInput, WebsiteSettingsUncheckedCreateWithoutWebsiteInput>
    connectOrCreate?: WebsiteSettingsCreateOrConnectWithoutWebsiteInput
    connect?: WebsiteSettingsWhereUniqueInput
  }

  export type WebsiteSectionUncheckedCreateNestedManyWithoutWebsiteInput = {
    create?: XOR<WebsiteSectionCreateWithoutWebsiteInput, WebsiteSectionUncheckedCreateWithoutWebsiteInput> | WebsiteSectionCreateWithoutWebsiteInput[] | WebsiteSectionUncheckedCreateWithoutWebsiteInput[]
    connectOrCreate?: WebsiteSectionCreateOrConnectWithoutWebsiteInput | WebsiteSectionCreateOrConnectWithoutWebsiteInput[]
    createMany?: WebsiteSectionCreateManyWebsiteInputEnvelope
    connect?: WebsiteSectionWhereUniqueInput | WebsiteSectionWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutWebsitesNestedInput = {
    create?: XOR<TenantCreateWithoutWebsitesInput, TenantUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWebsitesInput
    upsert?: TenantUpsertWithoutWebsitesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWebsitesInput, TenantUpdateWithoutWebsitesInput>, TenantUncheckedUpdateWithoutWebsitesInput>
  }

  export type WebsitePageUpdateManyWithoutWebsiteNestedInput = {
    create?: XOR<WebsitePageCreateWithoutWebsiteInput, WebsitePageUncheckedCreateWithoutWebsiteInput> | WebsitePageCreateWithoutWebsiteInput[] | WebsitePageUncheckedCreateWithoutWebsiteInput[]
    connectOrCreate?: WebsitePageCreateOrConnectWithoutWebsiteInput | WebsitePageCreateOrConnectWithoutWebsiteInput[]
    upsert?: WebsitePageUpsertWithWhereUniqueWithoutWebsiteInput | WebsitePageUpsertWithWhereUniqueWithoutWebsiteInput[]
    createMany?: WebsitePageCreateManyWebsiteInputEnvelope
    set?: WebsitePageWhereUniqueInput | WebsitePageWhereUniqueInput[]
    disconnect?: WebsitePageWhereUniqueInput | WebsitePageWhereUniqueInput[]
    delete?: WebsitePageWhereUniqueInput | WebsitePageWhereUniqueInput[]
    connect?: WebsitePageWhereUniqueInput | WebsitePageWhereUniqueInput[]
    update?: WebsitePageUpdateWithWhereUniqueWithoutWebsiteInput | WebsitePageUpdateWithWhereUniqueWithoutWebsiteInput[]
    updateMany?: WebsitePageUpdateManyWithWhereWithoutWebsiteInput | WebsitePageUpdateManyWithWhereWithoutWebsiteInput[]
    deleteMany?: WebsitePageScalarWhereInput | WebsitePageScalarWhereInput[]
  }

  export type WebsiteSettingsUpdateOneWithoutWebsiteNestedInput = {
    create?: XOR<WebsiteSettingsCreateWithoutWebsiteInput, WebsiteSettingsUncheckedCreateWithoutWebsiteInput>
    connectOrCreate?: WebsiteSettingsCreateOrConnectWithoutWebsiteInput
    upsert?: WebsiteSettingsUpsertWithoutWebsiteInput
    disconnect?: WebsiteSettingsWhereInput | boolean
    delete?: WebsiteSettingsWhereInput | boolean
    connect?: WebsiteSettingsWhereUniqueInput
    update?: XOR<XOR<WebsiteSettingsUpdateToOneWithWhereWithoutWebsiteInput, WebsiteSettingsUpdateWithoutWebsiteInput>, WebsiteSettingsUncheckedUpdateWithoutWebsiteInput>
  }

  export type WebsiteSectionUpdateManyWithoutWebsiteNestedInput = {
    create?: XOR<WebsiteSectionCreateWithoutWebsiteInput, WebsiteSectionUncheckedCreateWithoutWebsiteInput> | WebsiteSectionCreateWithoutWebsiteInput[] | WebsiteSectionUncheckedCreateWithoutWebsiteInput[]
    connectOrCreate?: WebsiteSectionCreateOrConnectWithoutWebsiteInput | WebsiteSectionCreateOrConnectWithoutWebsiteInput[]
    upsert?: WebsiteSectionUpsertWithWhereUniqueWithoutWebsiteInput | WebsiteSectionUpsertWithWhereUniqueWithoutWebsiteInput[]
    createMany?: WebsiteSectionCreateManyWebsiteInputEnvelope
    set?: WebsiteSectionWhereUniqueInput | WebsiteSectionWhereUniqueInput[]
    disconnect?: WebsiteSectionWhereUniqueInput | WebsiteSectionWhereUniqueInput[]
    delete?: WebsiteSectionWhereUniqueInput | WebsiteSectionWhereUniqueInput[]
    connect?: WebsiteSectionWhereUniqueInput | WebsiteSectionWhereUniqueInput[]
    update?: WebsiteSectionUpdateWithWhereUniqueWithoutWebsiteInput | WebsiteSectionUpdateWithWhereUniqueWithoutWebsiteInput[]
    updateMany?: WebsiteSectionUpdateManyWithWhereWithoutWebsiteInput | WebsiteSectionUpdateManyWithWhereWithoutWebsiteInput[]
    deleteMany?: WebsiteSectionScalarWhereInput | WebsiteSectionScalarWhereInput[]
  }

  export type WebsitePageUncheckedUpdateManyWithoutWebsiteNestedInput = {
    create?: XOR<WebsitePageCreateWithoutWebsiteInput, WebsitePageUncheckedCreateWithoutWebsiteInput> | WebsitePageCreateWithoutWebsiteInput[] | WebsitePageUncheckedCreateWithoutWebsiteInput[]
    connectOrCreate?: WebsitePageCreateOrConnectWithoutWebsiteInput | WebsitePageCreateOrConnectWithoutWebsiteInput[]
    upsert?: WebsitePageUpsertWithWhereUniqueWithoutWebsiteInput | WebsitePageUpsertWithWhereUniqueWithoutWebsiteInput[]
    createMany?: WebsitePageCreateManyWebsiteInputEnvelope
    set?: WebsitePageWhereUniqueInput | WebsitePageWhereUniqueInput[]
    disconnect?: WebsitePageWhereUniqueInput | WebsitePageWhereUniqueInput[]
    delete?: WebsitePageWhereUniqueInput | WebsitePageWhereUniqueInput[]
    connect?: WebsitePageWhereUniqueInput | WebsitePageWhereUniqueInput[]
    update?: WebsitePageUpdateWithWhereUniqueWithoutWebsiteInput | WebsitePageUpdateWithWhereUniqueWithoutWebsiteInput[]
    updateMany?: WebsitePageUpdateManyWithWhereWithoutWebsiteInput | WebsitePageUpdateManyWithWhereWithoutWebsiteInput[]
    deleteMany?: WebsitePageScalarWhereInput | WebsitePageScalarWhereInput[]
  }

  export type WebsiteSettingsUncheckedUpdateOneWithoutWebsiteNestedInput = {
    create?: XOR<WebsiteSettingsCreateWithoutWebsiteInput, WebsiteSettingsUncheckedCreateWithoutWebsiteInput>
    connectOrCreate?: WebsiteSettingsCreateOrConnectWithoutWebsiteInput
    upsert?: WebsiteSettingsUpsertWithoutWebsiteInput
    disconnect?: WebsiteSettingsWhereInput | boolean
    delete?: WebsiteSettingsWhereInput | boolean
    connect?: WebsiteSettingsWhereUniqueInput
    update?: XOR<XOR<WebsiteSettingsUpdateToOneWithWhereWithoutWebsiteInput, WebsiteSettingsUpdateWithoutWebsiteInput>, WebsiteSettingsUncheckedUpdateWithoutWebsiteInput>
  }

  export type WebsiteSectionUncheckedUpdateManyWithoutWebsiteNestedInput = {
    create?: XOR<WebsiteSectionCreateWithoutWebsiteInput, WebsiteSectionUncheckedCreateWithoutWebsiteInput> | WebsiteSectionCreateWithoutWebsiteInput[] | WebsiteSectionUncheckedCreateWithoutWebsiteInput[]
    connectOrCreate?: WebsiteSectionCreateOrConnectWithoutWebsiteInput | WebsiteSectionCreateOrConnectWithoutWebsiteInput[]
    upsert?: WebsiteSectionUpsertWithWhereUniqueWithoutWebsiteInput | WebsiteSectionUpsertWithWhereUniqueWithoutWebsiteInput[]
    createMany?: WebsiteSectionCreateManyWebsiteInputEnvelope
    set?: WebsiteSectionWhereUniqueInput | WebsiteSectionWhereUniqueInput[]
    disconnect?: WebsiteSectionWhereUniqueInput | WebsiteSectionWhereUniqueInput[]
    delete?: WebsiteSectionWhereUniqueInput | WebsiteSectionWhereUniqueInput[]
    connect?: WebsiteSectionWhereUniqueInput | WebsiteSectionWhereUniqueInput[]
    update?: WebsiteSectionUpdateWithWhereUniqueWithoutWebsiteInput | WebsiteSectionUpdateWithWhereUniqueWithoutWebsiteInput[]
    updateMany?: WebsiteSectionUpdateManyWithWhereWithoutWebsiteInput | WebsiteSectionUpdateManyWithWhereWithoutWebsiteInput[]
    deleteMany?: WebsiteSectionScalarWhereInput | WebsiteSectionScalarWhereInput[]
  }

  export type TenantWebsiteCreateNestedOneWithoutPagesInput = {
    create?: XOR<TenantWebsiteCreateWithoutPagesInput, TenantWebsiteUncheckedCreateWithoutPagesInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutPagesInput
    connect?: TenantWebsiteWhereUniqueInput
  }

  export type TenantWebsiteUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutPagesInput, TenantWebsiteUncheckedCreateWithoutPagesInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutPagesInput
    upsert?: TenantWebsiteUpsertWithoutPagesInput
    connect?: TenantWebsiteWhereUniqueInput
    update?: XOR<XOR<TenantWebsiteUpdateToOneWithWhereWithoutPagesInput, TenantWebsiteUpdateWithoutPagesInput>, TenantWebsiteUncheckedUpdateWithoutPagesInput>
  }

  export type TenantWebsiteCreateNestedOneWithoutSettingsInput = {
    create?: XOR<TenantWebsiteCreateWithoutSettingsInput, TenantWebsiteUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutSettingsInput
    connect?: TenantWebsiteWhereUniqueInput
  }

  export type TenantWebsiteUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutSettingsInput, TenantWebsiteUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutSettingsInput
    upsert?: TenantWebsiteUpsertWithoutSettingsInput
    connect?: TenantWebsiteWhereUniqueInput
    update?: XOR<XOR<TenantWebsiteUpdateToOneWithWhereWithoutSettingsInput, TenantWebsiteUpdateWithoutSettingsInput>, TenantWebsiteUncheckedUpdateWithoutSettingsInput>
  }

  export type TenantWebsiteCreateNestedOneWithoutSectionsInput = {
    create?: XOR<TenantWebsiteCreateWithoutSectionsInput, TenantWebsiteUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutSectionsInput
    connect?: TenantWebsiteWhereUniqueInput
  }

  export type TenantWebsiteUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutSectionsInput, TenantWebsiteUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutSectionsInput
    upsert?: TenantWebsiteUpsertWithoutSectionsInput
    connect?: TenantWebsiteWhereUniqueInput
    update?: XOR<XOR<TenantWebsiteUpdateToOneWithWhereWithoutSectionsInput, TenantWebsiteUpdateWithoutSectionsInput>, TenantWebsiteUncheckedUpdateWithoutSectionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ActivityCreateWithoutTenantInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutTenantInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput>
  }

  export type ActivityCreateManyTenantInputEnvelope = {
    data: ActivityCreateManyTenantInput | ActivityCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutTenantInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    paymentStatus?: string
    createdAt?: Date | string
    isReturn?: boolean
    distanceKm?: number | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    driver?: DriverCreateNestedOneWithoutReservationsInput
    returnTransfer?: ReservationCreateNestedOneWithoutOriginalTransferInput
    originalTransfer?: ReservationCreateNestedOneWithoutReturnTransferInput
    user?: UserCreateNestedOneWithoutReservationsInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutTenantInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    driverId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    returnTransferId?: string | null
    isReturn?: boolean
    distanceKm?: number | null
    userId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    originalTransfer?: ReservationUncheckedCreateNestedOneWithoutReturnTransferInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutTenantInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutTenantInput, ReservationUncheckedCreateWithoutTenantInput>
  }

  export type ReservationCreateManyTenantInputEnvelope = {
    data: ReservationCreateManyTenantInput | ReservationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DriverCreateWithoutTenantInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    createdAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutDriverInput
    tourBookings?: TourBookingCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    createdAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutDriverInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutTenantInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutTenantInput, DriverUncheckedCreateWithoutTenantInput>
  }

  export type DriverCreateManyTenantInputEnvelope = {
    data: DriverCreateManyTenantInput | DriverCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type HotelBookingCreateWithoutTenantInput = {
    id?: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
    request?: HotelRequestCreateNestedOneWithoutHotelBookingsInput
    reservation?: ReservationCreateNestedOneWithoutHotelBookingsInput
  }

  export type HotelBookingUncheckedCreateWithoutTenantInput = {
    id?: string
    requestId?: string | null
    reservationId?: string | null
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
  }

  export type HotelBookingCreateOrConnectWithoutTenantInput = {
    where: HotelBookingWhereUniqueInput
    create: XOR<HotelBookingCreateWithoutTenantInput, HotelBookingUncheckedCreateWithoutTenantInput>
  }

  export type HotelBookingCreateManyTenantInputEnvelope = {
    data: HotelBookingCreateManyTenantInput | HotelBookingCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type HotelPricePoolCreateWithoutTenantInput = {
    id?: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    hotelCity: string
    hotelCountry: string
    hotelRating: number
    hotelStars: number
    hotelImage?: string | null
    hotelAmenities?: string
    roomType: string
    roomName: string
    roomDescription?: string | null
    roomAmenities?: string
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    roomView?: string | null
    basePrice: number
    agentPrice: number
    customerPrice: number
    profitMargin: number
    profitPercentage: number
    currency?: string
    validFrom: Date | string
    validTo: Date | string
    cancellationPolicy?: string | null
    breakfastIncluded?: boolean
    freeCancellation?: boolean
    source?: string
    lastUpdated?: Date | string
    updatedBy: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelPricePoolUncheckedCreateWithoutTenantInput = {
    id?: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    hotelCity: string
    hotelCountry: string
    hotelRating: number
    hotelStars: number
    hotelImage?: string | null
    hotelAmenities?: string
    roomType: string
    roomName: string
    roomDescription?: string | null
    roomAmenities?: string
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    roomView?: string | null
    basePrice: number
    agentPrice: number
    customerPrice: number
    profitMargin: number
    profitPercentage: number
    currency?: string
    validFrom: Date | string
    validTo: Date | string
    cancellationPolicy?: string | null
    breakfastIncluded?: boolean
    freeCancellation?: boolean
    source?: string
    lastUpdated?: Date | string
    updatedBy: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelPricePoolCreateOrConnectWithoutTenantInput = {
    where: HotelPricePoolWhereUniqueInput
    create: XOR<HotelPricePoolCreateWithoutTenantInput, HotelPricePoolUncheckedCreateWithoutTenantInput>
  }

  export type HotelPricePoolCreateManyTenantInputEnvelope = {
    data: HotelPricePoolCreateManyTenantInput | HotelPricePoolCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type HotelRequestCreateWithoutTenantInput = {
    id?: string
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelBookings?: HotelBookingCreateNestedManyWithoutRequestInput
    user?: UserCreateNestedOneWithoutHotelRequestsInput
  }

  export type HotelRequestUncheckedCreateWithoutTenantInput = {
    id?: string
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    assignedTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutRequestInput
  }

  export type HotelRequestCreateOrConnectWithoutTenantInput = {
    where: HotelRequestWhereUniqueInput
    create: XOR<HotelRequestCreateWithoutTenantInput, HotelRequestUncheckedCreateWithoutTenantInput>
  }

  export type HotelRequestCreateManyTenantInputEnvelope = {
    data: HotelRequestCreateManyTenantInput | HotelRequestCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantModuleCreateWithoutTenantInput = {
    id?: string
    isEnabled?: boolean
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutTenantModulesInput
  }

  export type TenantModuleUncheckedCreateWithoutTenantInput = {
    id?: string
    moduleId: string
    isEnabled?: boolean
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantModuleCreateOrConnectWithoutTenantInput = {
    where: TenantModuleWhereUniqueInput
    create: XOR<TenantModuleCreateWithoutTenantInput, TenantModuleUncheckedCreateWithoutTenantInput>
  }

  export type TenantModuleCreateManyTenantInputEnvelope = {
    data: TenantModuleCreateManyTenantInput | TenantModuleCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantUserCreateWithoutTenantInput = {
    id?: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTenantUsersInput
  }

  export type TenantUserUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUserCreateOrConnectWithoutTenantInput = {
    where: TenantUserWhereUniqueInput
    create: XOR<TenantUserCreateWithoutTenantInput, TenantUserUncheckedCreateWithoutTenantInput>
  }

  export type TenantUserCreateManyTenantInputEnvelope = {
    data: TenantUserCreateManyTenantInput | TenantUserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TourBookingCreateWithoutTenantInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
    driver?: DriverCreateNestedOneWithoutTourBookingsInput
    User?: UserCreateNestedOneWithoutTour_bookingsInput
  }

  export type TourBookingUncheckedCreateWithoutTenantInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    userId?: string | null
    driverId?: string | null
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
  }

  export type TourBookingCreateOrConnectWithoutTenantInput = {
    where: TourBookingWhereUniqueInput
    create: XOR<TourBookingCreateWithoutTenantInput, TourBookingUncheckedCreateWithoutTenantInput>
  }

  export type TourBookingCreateManyTenantInputEnvelope = {
    data: TourBookingCreateManyTenantInput | TourBookingCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type VehicleCreateWithoutTenantInput = {
    id?: string
    type: string
    capacity: number
    licensePlate: string
    driverName?: string | null
    driverPhone?: string | null
    isAvailable?: boolean
    lastMaintenance?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUncheckedCreateWithoutTenantInput = {
    id?: string
    type: string
    capacity: number
    licensePlate: string
    driverName?: string | null
    driverPhone?: string | null
    isAvailable?: boolean
    lastMaintenance?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleCreateOrConnectWithoutTenantInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput>
  }

  export type VehicleCreateManyTenantInputEnvelope = {
    data: VehicleCreateManyTenantInput | VehicleCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantWebsiteCreateWithoutTenantInput = {
    id?: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: WebsitePageCreateNestedManyWithoutWebsiteInput
    settings?: WebsiteSettingsCreateNestedOneWithoutWebsiteInput
    sections?: WebsiteSectionCreateNestedManyWithoutWebsiteInput
  }

  export type TenantWebsiteUncheckedCreateWithoutTenantInput = {
    id?: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: WebsitePageUncheckedCreateNestedManyWithoutWebsiteInput
    settings?: WebsiteSettingsUncheckedCreateNestedOneWithoutWebsiteInput
    sections?: WebsiteSectionUncheckedCreateNestedManyWithoutWebsiteInput
  }

  export type TenantWebsiteCreateOrConnectWithoutTenantInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutTenantInput, TenantWebsiteUncheckedCreateWithoutTenantInput>
  }

  export type TenantWebsiteCreateManyTenantInputEnvelope = {
    data: TenantWebsiteCreateManyTenantInput | TenantWebsiteCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithWhereUniqueWithoutTenantInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutTenantInput, ActivityUncheckedUpdateWithoutTenantInput>
    create: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutTenantInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutTenantInput, ActivityUncheckedUpdateWithoutTenantInput>
  }

  export type ActivityUpdateManyWithWhereWithoutTenantInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutTenantInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    entityType?: StringFilter<"Activity"> | string
    entityId?: StringNullableFilter<"Activity"> | string | null
    description?: StringFilter<"Activity"> | string
    details?: JsonNullableFilter<"Activity">
    ipAddress?: StringNullableFilter<"Activity"> | string | null
    userAgent?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    tenantId?: StringNullableFilter<"Activity"> | string | null
  }

  export type ReservationUpsertWithWhereUniqueWithoutTenantInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutTenantInput, ReservationUncheckedUpdateWithoutTenantInput>
    create: XOR<ReservationCreateWithoutTenantInput, ReservationUncheckedCreateWithoutTenantInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutTenantInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutTenantInput, ReservationUncheckedUpdateWithoutTenantInput>
  }

  export type ReservationUpdateManyWithWhereWithoutTenantInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutTenantInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: StringFilter<"Reservation"> | string
    date?: StringFilter<"Reservation"> | string
    time?: StringFilter<"Reservation"> | string
    from?: StringFilter<"Reservation"> | string
    to?: StringFilter<"Reservation"> | string
    flightCode?: StringFilter<"Reservation"> | string
    passengerNames?: StringFilter<"Reservation"> | string
    luggageCount?: IntFilter<"Reservation"> | number
    price?: FloatFilter<"Reservation"> | number
    currency?: StringFilter<"Reservation"> | string
    phoneNumber?: StringNullableFilter<"Reservation"> | string | null
    voucherNumber?: StringFilter<"Reservation"> | string
    driverFee?: FloatNullableFilter<"Reservation"> | number | null
    driverId?: StringNullableFilter<"Reservation"> | string | null
    paymentStatus?: StringFilter<"Reservation"> | string
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    returnTransferId?: StringNullableFilter<"Reservation"> | string | null
    isReturn?: BoolFilter<"Reservation"> | boolean
    distanceKm?: FloatNullableFilter<"Reservation"> | number | null
    userId?: StringNullableFilter<"Reservation"> | string | null
    tenantId?: StringNullableFilter<"Reservation"> | string | null
    companyCommissionStatus?: StringFilter<"Reservation"> | string
    notes?: StringNullableFilter<"Reservation"> | string | null
    email?: StringNullableFilter<"Reservation"> | string | null
    type?: StringFilter<"Reservation"> | string
  }

  export type DriverUpsertWithWhereUniqueWithoutTenantInput = {
    where: DriverWhereUniqueInput
    update: XOR<DriverUpdateWithoutTenantInput, DriverUncheckedUpdateWithoutTenantInput>
    create: XOR<DriverCreateWithoutTenantInput, DriverUncheckedCreateWithoutTenantInput>
  }

  export type DriverUpdateWithWhereUniqueWithoutTenantInput = {
    where: DriverWhereUniqueInput
    data: XOR<DriverUpdateWithoutTenantInput, DriverUncheckedUpdateWithoutTenantInput>
  }

  export type DriverUpdateManyWithWhereWithoutTenantInput = {
    where: DriverScalarWhereInput
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyWithoutTenantInput>
  }

  export type DriverScalarWhereInput = {
    AND?: DriverScalarWhereInput | DriverScalarWhereInput[]
    OR?: DriverScalarWhereInput[]
    NOT?: DriverScalarWhereInput | DriverScalarWhereInput[]
    id?: StringFilter<"Driver"> | string
    name?: StringFilter<"Driver"> | string
    phoneNumber?: StringNullableFilter<"Driver"> | string | null
    tenantId?: StringNullableFilter<"Driver"> | string | null
    createdAt?: DateTimeFilter<"Driver"> | Date | string
  }

  export type HotelBookingUpsertWithWhereUniqueWithoutTenantInput = {
    where: HotelBookingWhereUniqueInput
    update: XOR<HotelBookingUpdateWithoutTenantInput, HotelBookingUncheckedUpdateWithoutTenantInput>
    create: XOR<HotelBookingCreateWithoutTenantInput, HotelBookingUncheckedCreateWithoutTenantInput>
  }

  export type HotelBookingUpdateWithWhereUniqueWithoutTenantInput = {
    where: HotelBookingWhereUniqueInput
    data: XOR<HotelBookingUpdateWithoutTenantInput, HotelBookingUncheckedUpdateWithoutTenantInput>
  }

  export type HotelBookingUpdateManyWithWhereWithoutTenantInput = {
    where: HotelBookingScalarWhereInput
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyWithoutTenantInput>
  }

  export type HotelBookingScalarWhereInput = {
    AND?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
    OR?: HotelBookingScalarWhereInput[]
    NOT?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
    id?: StringFilter<"HotelBooking"> | string
    tenantId?: StringNullableFilter<"HotelBooking"> | string | null
    requestId?: StringNullableFilter<"HotelBooking"> | string | null
    reservationId?: StringNullableFilter<"HotelBooking"> | string | null
    hotelId?: StringFilter<"HotelBooking"> | string
    hotelName?: StringFilter<"HotelBooking"> | string
    hotelAddress?: StringFilter<"HotelBooking"> | string
    roomType?: StringFilter<"HotelBooking"> | string
    checkin?: DateTimeFilter<"HotelBooking"> | Date | string
    checkout?: DateTimeFilter<"HotelBooking"> | Date | string
    adults?: IntFilter<"HotelBooking"> | number
    children?: IntFilter<"HotelBooking"> | number
    rooms?: IntFilter<"HotelBooking"> | number
    totalPrice?: FloatFilter<"HotelBooking"> | number
    currency?: StringFilter<"HotelBooking"> | string
    bookingReference?: StringFilter<"HotelBooking"> | string
    status?: StringFilter<"HotelBooking"> | string
    customerInfo?: JsonFilter<"HotelBooking">
    specialRequests?: StringNullableFilter<"HotelBooking"> | string | null
    cancellationPolicy?: StringNullableFilter<"HotelBooking"> | string | null
    createdAt?: DateTimeFilter<"HotelBooking"> | Date | string
    updatedAt?: DateTimeFilter<"HotelBooking"> | Date | string
    agentPrice?: FloatFilter<"HotelBooking"> | number
    customerPrice?: FloatFilter<"HotelBooking"> | number
    profitMargin?: FloatFilter<"HotelBooking"> | number
    voucherNumber?: StringFilter<"HotelBooking"> | string
  }

  export type HotelPricePoolUpsertWithWhereUniqueWithoutTenantInput = {
    where: HotelPricePoolWhereUniqueInput
    update: XOR<HotelPricePoolUpdateWithoutTenantInput, HotelPricePoolUncheckedUpdateWithoutTenantInput>
    create: XOR<HotelPricePoolCreateWithoutTenantInput, HotelPricePoolUncheckedCreateWithoutTenantInput>
  }

  export type HotelPricePoolUpdateWithWhereUniqueWithoutTenantInput = {
    where: HotelPricePoolWhereUniqueInput
    data: XOR<HotelPricePoolUpdateWithoutTenantInput, HotelPricePoolUncheckedUpdateWithoutTenantInput>
  }

  export type HotelPricePoolUpdateManyWithWhereWithoutTenantInput = {
    where: HotelPricePoolScalarWhereInput
    data: XOR<HotelPricePoolUpdateManyMutationInput, HotelPricePoolUncheckedUpdateManyWithoutTenantInput>
  }

  export type HotelPricePoolScalarWhereInput = {
    AND?: HotelPricePoolScalarWhereInput | HotelPricePoolScalarWhereInput[]
    OR?: HotelPricePoolScalarWhereInput[]
    NOT?: HotelPricePoolScalarWhereInput | HotelPricePoolScalarWhereInput[]
    id?: StringFilter<"HotelPricePool"> | string
    tenantId?: StringFilter<"HotelPricePool"> | string
    hotelId?: StringFilter<"HotelPricePool"> | string
    hotelName?: StringFilter<"HotelPricePool"> | string
    hotelAddress?: StringFilter<"HotelPricePool"> | string
    hotelCity?: StringFilter<"HotelPricePool"> | string
    hotelCountry?: StringFilter<"HotelPricePool"> | string
    hotelRating?: FloatFilter<"HotelPricePool"> | number
    hotelStars?: IntFilter<"HotelPricePool"> | number
    hotelImage?: StringNullableFilter<"HotelPricePool"> | string | null
    hotelAmenities?: StringFilter<"HotelPricePool"> | string
    roomType?: StringFilter<"HotelPricePool"> | string
    roomName?: StringFilter<"HotelPricePool"> | string
    roomDescription?: StringNullableFilter<"HotelPricePool"> | string | null
    roomAmenities?: StringFilter<"HotelPricePool"> | string
    maxOccupancy?: IntFilter<"HotelPricePool"> | number
    bedType?: StringFilter<"HotelPricePool"> | string
    roomSize?: StringNullableFilter<"HotelPricePool"> | string | null
    roomView?: StringNullableFilter<"HotelPricePool"> | string | null
    basePrice?: FloatFilter<"HotelPricePool"> | number
    agentPrice?: FloatFilter<"HotelPricePool"> | number
    customerPrice?: FloatFilter<"HotelPricePool"> | number
    profitMargin?: FloatFilter<"HotelPricePool"> | number
    profitPercentage?: FloatFilter<"HotelPricePool"> | number
    currency?: StringFilter<"HotelPricePool"> | string
    validFrom?: DateTimeFilter<"HotelPricePool"> | Date | string
    validTo?: DateTimeFilter<"HotelPricePool"> | Date | string
    cancellationPolicy?: StringNullableFilter<"HotelPricePool"> | string | null
    breakfastIncluded?: BoolFilter<"HotelPricePool"> | boolean
    freeCancellation?: BoolFilter<"HotelPricePool"> | boolean
    source?: StringFilter<"HotelPricePool"> | string
    lastUpdated?: DateTimeFilter<"HotelPricePool"> | Date | string
    updatedBy?: StringFilter<"HotelPricePool"> | string
    isActive?: BoolFilter<"HotelPricePool"> | boolean
    createdAt?: DateTimeFilter<"HotelPricePool"> | Date | string
    updatedAt?: DateTimeFilter<"HotelPricePool"> | Date | string
  }

  export type HotelRequestUpsertWithWhereUniqueWithoutTenantInput = {
    where: HotelRequestWhereUniqueInput
    update: XOR<HotelRequestUpdateWithoutTenantInput, HotelRequestUncheckedUpdateWithoutTenantInput>
    create: XOR<HotelRequestCreateWithoutTenantInput, HotelRequestUncheckedCreateWithoutTenantInput>
  }

  export type HotelRequestUpdateWithWhereUniqueWithoutTenantInput = {
    where: HotelRequestWhereUniqueInput
    data: XOR<HotelRequestUpdateWithoutTenantInput, HotelRequestUncheckedUpdateWithoutTenantInput>
  }

  export type HotelRequestUpdateManyWithWhereWithoutTenantInput = {
    where: HotelRequestScalarWhereInput
    data: XOR<HotelRequestUpdateManyMutationInput, HotelRequestUncheckedUpdateManyWithoutTenantInput>
  }

  export type HotelRequestScalarWhereInput = {
    AND?: HotelRequestScalarWhereInput | HotelRequestScalarWhereInput[]
    OR?: HotelRequestScalarWhereInput[]
    NOT?: HotelRequestScalarWhereInput | HotelRequestScalarWhereInput[]
    id?: StringFilter<"HotelRequest"> | string
    tenantId?: StringNullableFilter<"HotelRequest"> | string | null
    customerName?: StringFilter<"HotelRequest"> | string
    customerEmail?: StringFilter<"HotelRequest"> | string
    customerPhone?: StringFilter<"HotelRequest"> | string
    checkin?: DateTimeFilter<"HotelRequest"> | Date | string
    checkout?: DateTimeFilter<"HotelRequest"> | Date | string
    adults?: IntFilter<"HotelRequest"> | number
    children?: IntFilter<"HotelRequest"> | number
    rooms?: IntFilter<"HotelRequest"> | number
    city?: StringFilter<"HotelRequest"> | string
    region?: StringNullableFilter<"HotelRequest"> | string | null
    budget?: FloatNullableFilter<"HotelRequest"> | number | null
    roomType?: StringNullableFilter<"HotelRequest"> | string | null
    breakfast?: BoolFilter<"HotelRequest"> | boolean
    amenities?: StringFilter<"HotelRequest"> | string
    specialRequests?: StringNullableFilter<"HotelRequest"> | string | null
    status?: StringFilter<"HotelRequest"> | string
    assignedTo?: StringNullableFilter<"HotelRequest"> | string | null
    createdAt?: DateTimeFilter<"HotelRequest"> | Date | string
    updatedAt?: DateTimeFilter<"HotelRequest"> | Date | string
  }

  export type TenantModuleUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantModuleWhereUniqueInput
    update: XOR<TenantModuleUpdateWithoutTenantInput, TenantModuleUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantModuleCreateWithoutTenantInput, TenantModuleUncheckedCreateWithoutTenantInput>
  }

  export type TenantModuleUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantModuleWhereUniqueInput
    data: XOR<TenantModuleUpdateWithoutTenantInput, TenantModuleUncheckedUpdateWithoutTenantInput>
  }

  export type TenantModuleUpdateManyWithWhereWithoutTenantInput = {
    where: TenantModuleScalarWhereInput
    data: XOR<TenantModuleUpdateManyMutationInput, TenantModuleUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantModuleScalarWhereInput = {
    AND?: TenantModuleScalarWhereInput | TenantModuleScalarWhereInput[]
    OR?: TenantModuleScalarWhereInput[]
    NOT?: TenantModuleScalarWhereInput | TenantModuleScalarWhereInput[]
    id?: StringFilter<"TenantModule"> | string
    tenantId?: StringFilter<"TenantModule"> | string
    moduleId?: StringFilter<"TenantModule"> | string
    isEnabled?: BoolFilter<"TenantModule"> | boolean
    activatedAt?: DateTimeNullableFilter<"TenantModule"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"TenantModule"> | Date | string | null
    features?: StringFilter<"TenantModule"> | string
    createdAt?: DateTimeFilter<"TenantModule"> | Date | string
    updatedAt?: DateTimeFilter<"TenantModule"> | Date | string
  }

  export type TenantUserUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantUserWhereUniqueInput
    update: XOR<TenantUserUpdateWithoutTenantInput, TenantUserUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantUserCreateWithoutTenantInput, TenantUserUncheckedCreateWithoutTenantInput>
  }

  export type TenantUserUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantUserWhereUniqueInput
    data: XOR<TenantUserUpdateWithoutTenantInput, TenantUserUncheckedUpdateWithoutTenantInput>
  }

  export type TenantUserUpdateManyWithWhereWithoutTenantInput = {
    where: TenantUserScalarWhereInput
    data: XOR<TenantUserUpdateManyMutationInput, TenantUserUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantUserScalarWhereInput = {
    AND?: TenantUserScalarWhereInput | TenantUserScalarWhereInput[]
    OR?: TenantUserScalarWhereInput[]
    NOT?: TenantUserScalarWhereInput | TenantUserScalarWhereInput[]
    id?: StringFilter<"TenantUser"> | string
    tenantId?: StringFilter<"TenantUser"> | string
    userId?: StringFilter<"TenantUser"> | string
    role?: StringFilter<"TenantUser"> | string
    permissions?: StringFilter<"TenantUser"> | string
    isActive?: BoolFilter<"TenantUser"> | boolean
    createdAt?: DateTimeFilter<"TenantUser"> | Date | string
    updatedAt?: DateTimeFilter<"TenantUser"> | Date | string
  }

  export type TourBookingUpsertWithWhereUniqueWithoutTenantInput = {
    where: TourBookingWhereUniqueInput
    update: XOR<TourBookingUpdateWithoutTenantInput, TourBookingUncheckedUpdateWithoutTenantInput>
    create: XOR<TourBookingCreateWithoutTenantInput, TourBookingUncheckedCreateWithoutTenantInput>
  }

  export type TourBookingUpdateWithWhereUniqueWithoutTenantInput = {
    where: TourBookingWhereUniqueInput
    data: XOR<TourBookingUpdateWithoutTenantInput, TourBookingUncheckedUpdateWithoutTenantInput>
  }

  export type TourBookingUpdateManyWithWhereWithoutTenantInput = {
    where: TourBookingScalarWhereInput
    data: XOR<TourBookingUpdateManyMutationInput, TourBookingUncheckedUpdateManyWithoutTenantInput>
  }

  export type TourBookingScalarWhereInput = {
    AND?: TourBookingScalarWhereInput | TourBookingScalarWhereInput[]
    OR?: TourBookingScalarWhereInput[]
    NOT?: TourBookingScalarWhereInput | TourBookingScalarWhereInput[]
    id?: StringFilter<"TourBooking"> | string
    voucherNumber?: StringFilter<"TourBooking"> | string
    routeName?: StringFilter<"TourBooking"> | string
    vehicleType?: StringFilter<"TourBooking"> | string
    groupSize?: IntFilter<"TourBooking"> | number
    price?: FloatFilter<"TourBooking"> | number
    currency?: StringFilter<"TourBooking"> | string
    pickupLocation?: StringFilter<"TourBooking"> | string
    tourDate?: DateTimeFilter<"TourBooking"> | Date | string
    tourTime?: StringNullableFilter<"TourBooking"> | string | null
    passengerNames?: StringFilter<"TourBooking"> | string
    notes?: StringNullableFilter<"TourBooking"> | string | null
    status?: StringFilter<"TourBooking"> | string
    tenantId?: StringFilter<"TourBooking"> | string
    userId?: StringNullableFilter<"TourBooking"> | string | null
    driverId?: StringNullableFilter<"TourBooking"> | string | null
    driverFee?: FloatNullableFilter<"TourBooking"> | number | null
    createdAt?: DateTimeFilter<"TourBooking"> | Date | string
    updatedAt?: DateTimeFilter<"TourBooking"> | Date | string
    tourDuration?: IntFilter<"TourBooking"> | number
  }

  export type VehicleUpsertWithWhereUniqueWithoutTenantInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutTenantInput, VehicleUncheckedUpdateWithoutTenantInput>
    create: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutTenantInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutTenantInput, VehicleUncheckedUpdateWithoutTenantInput>
  }

  export type VehicleUpdateManyWithWhereWithoutTenantInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutTenantInput>
  }

  export type VehicleScalarWhereInput = {
    AND?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    OR?: VehicleScalarWhereInput[]
    NOT?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    type?: StringFilter<"Vehicle"> | string
    capacity?: IntFilter<"Vehicle"> | number
    licensePlate?: StringFilter<"Vehicle"> | string
    driverName?: StringNullableFilter<"Vehicle"> | string | null
    driverPhone?: StringNullableFilter<"Vehicle"> | string | null
    isAvailable?: BoolFilter<"Vehicle"> | boolean
    lastMaintenance?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    tenantId?: StringFilter<"Vehicle"> | string
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
  }

  export type TenantWebsiteUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantWebsiteWhereUniqueInput
    update: XOR<TenantWebsiteUpdateWithoutTenantInput, TenantWebsiteUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantWebsiteCreateWithoutTenantInput, TenantWebsiteUncheckedCreateWithoutTenantInput>
  }

  export type TenantWebsiteUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantWebsiteWhereUniqueInput
    data: XOR<TenantWebsiteUpdateWithoutTenantInput, TenantWebsiteUncheckedUpdateWithoutTenantInput>
  }

  export type TenantWebsiteUpdateManyWithWhereWithoutTenantInput = {
    where: TenantWebsiteScalarWhereInput
    data: XOR<TenantWebsiteUpdateManyMutationInput, TenantWebsiteUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantWebsiteScalarWhereInput = {
    AND?: TenantWebsiteScalarWhereInput | TenantWebsiteScalarWhereInput[]
    OR?: TenantWebsiteScalarWhereInput[]
    NOT?: TenantWebsiteScalarWhereInput | TenantWebsiteScalarWhereInput[]
    id?: StringFilter<"TenantWebsite"> | string
    tenantId?: StringFilter<"TenantWebsite"> | string
    domain?: StringNullableFilter<"TenantWebsite"> | string | null
    subdomain?: StringNullableFilter<"TenantWebsite"> | string | null
    isActive?: BoolFilter<"TenantWebsite"> | boolean
    theme?: StringFilter<"TenantWebsite"> | string
    customCSS?: StringNullableFilter<"TenantWebsite"> | string | null
    favicon?: StringNullableFilter<"TenantWebsite"> | string | null
    createdAt?: DateTimeFilter<"TenantWebsite"> | Date | string
    updatedAt?: DateTimeFilter<"TenantWebsite"> | Date | string
  }

  export type TenantModuleCreateWithoutModuleInput = {
    id?: string
    isEnabled?: boolean
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutModulesInput
  }

  export type TenantModuleUncheckedCreateWithoutModuleInput = {
    id?: string
    tenantId: string
    isEnabled?: boolean
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantModuleCreateOrConnectWithoutModuleInput = {
    where: TenantModuleWhereUniqueInput
    create: XOR<TenantModuleCreateWithoutModuleInput, TenantModuleUncheckedCreateWithoutModuleInput>
  }

  export type TenantModuleCreateManyModuleInputEnvelope = {
    data: TenantModuleCreateManyModuleInput | TenantModuleCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type TenantModuleUpsertWithWhereUniqueWithoutModuleInput = {
    where: TenantModuleWhereUniqueInput
    update: XOR<TenantModuleUpdateWithoutModuleInput, TenantModuleUncheckedUpdateWithoutModuleInput>
    create: XOR<TenantModuleCreateWithoutModuleInput, TenantModuleUncheckedCreateWithoutModuleInput>
  }

  export type TenantModuleUpdateWithWhereUniqueWithoutModuleInput = {
    where: TenantModuleWhereUniqueInput
    data: XOR<TenantModuleUpdateWithoutModuleInput, TenantModuleUncheckedUpdateWithoutModuleInput>
  }

  export type TenantModuleUpdateManyWithWhereWithoutModuleInput = {
    where: TenantModuleScalarWhereInput
    data: XOR<TenantModuleUpdateManyMutationInput, TenantModuleUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleCreateWithoutTenantModulesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    priceMonthly?: number
    priceYearly?: number
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUncheckedCreateWithoutTenantModulesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    priceMonthly?: number
    priceYearly?: number
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleCreateOrConnectWithoutTenantModulesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutTenantModulesInput, ModuleUncheckedCreateWithoutTenantModulesInput>
  }

  export type TenantCreateWithoutModulesInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutModulesInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutModulesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutModulesInput, TenantUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutTenantModulesInput = {
    update: XOR<ModuleUpdateWithoutTenantModulesInput, ModuleUncheckedUpdateWithoutTenantModulesInput>
    create: XOR<ModuleCreateWithoutTenantModulesInput, ModuleUncheckedCreateWithoutTenantModulesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutTenantModulesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutTenantModulesInput, ModuleUncheckedUpdateWithoutTenantModulesInput>
  }

  export type ModuleUpdateWithoutTenantModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateWithoutTenantModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUpsertWithoutModulesInput = {
    update: XOR<TenantUpdateWithoutModulesInput, TenantUncheckedUpdateWithoutModulesInput>
    create: XOR<TenantCreateWithoutModulesInput, TenantUncheckedCreateWithoutModulesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutModulesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutModulesInput, TenantUncheckedUpdateWithoutModulesInput>
  }

  export type TenantUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutTenantUsersInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    reservations?: ReservationCreateNestedManyWithoutUserInput
    creator?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantUsersInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantUsersInput, UserUncheckedCreateWithoutTenantUsersInput>
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutTenantUsersInput = {
    update: XOR<UserUpdateWithoutTenantUsersInput, UserUncheckedUpdateWithoutTenantUsersInput>
    create: XOR<UserCreateWithoutTenantUsersInput, UserUncheckedCreateWithoutTenantUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTenantUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTenantUsersInput, UserUncheckedUpdateWithoutTenantUsersInput>
  }

  export type UserUpdateWithoutTenantUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    creator?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReservationCreateWithoutDriverInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    paymentStatus?: string
    createdAt?: Date | string
    isReturn?: boolean
    distanceKm?: number | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    returnTransfer?: ReservationCreateNestedOneWithoutOriginalTransferInput
    originalTransfer?: ReservationCreateNestedOneWithoutReturnTransferInput
    tenant?: TenantCreateNestedOneWithoutReservationsInput
    user?: UserCreateNestedOneWithoutReservationsInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutDriverInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    paymentStatus?: string
    createdAt?: Date | string
    returnTransferId?: string | null
    isReturn?: boolean
    distanceKm?: number | null
    userId?: string | null
    tenantId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    originalTransfer?: ReservationUncheckedCreateNestedOneWithoutReturnTransferInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutDriverInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutDriverInput, ReservationUncheckedCreateWithoutDriverInput>
  }

  export type ReservationCreateManyDriverInputEnvelope = {
    data: ReservationCreateManyDriverInput | ReservationCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutDriversInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDriversInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDriversInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDriversInput, TenantUncheckedCreateWithoutDriversInput>
  }

  export type TourBookingCreateWithoutDriverInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
    tenant: TenantCreateNestedOneWithoutTourBookingsInput
    User?: UserCreateNestedOneWithoutTour_bookingsInput
  }

  export type TourBookingUncheckedCreateWithoutDriverInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    tenantId: string
    userId?: string | null
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
  }

  export type TourBookingCreateOrConnectWithoutDriverInput = {
    where: TourBookingWhereUniqueInput
    create: XOR<TourBookingCreateWithoutDriverInput, TourBookingUncheckedCreateWithoutDriverInput>
  }

  export type TourBookingCreateManyDriverInputEnvelope = {
    data: TourBookingCreateManyDriverInput | TourBookingCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutDriverInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutDriverInput, ReservationUncheckedUpdateWithoutDriverInput>
    create: XOR<ReservationCreateWithoutDriverInput, ReservationUncheckedCreateWithoutDriverInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutDriverInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutDriverInput, ReservationUncheckedUpdateWithoutDriverInput>
  }

  export type ReservationUpdateManyWithWhereWithoutDriverInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutDriverInput>
  }

  export type TenantUpsertWithoutDriversInput = {
    update: XOR<TenantUpdateWithoutDriversInput, TenantUncheckedUpdateWithoutDriversInput>
    create: XOR<TenantCreateWithoutDriversInput, TenantUncheckedCreateWithoutDriversInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDriversInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDriversInput, TenantUncheckedUpdateWithoutDriversInput>
  }

  export type TenantUpdateWithoutDriversInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDriversInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TourBookingUpsertWithWhereUniqueWithoutDriverInput = {
    where: TourBookingWhereUniqueInput
    update: XOR<TourBookingUpdateWithoutDriverInput, TourBookingUncheckedUpdateWithoutDriverInput>
    create: XOR<TourBookingCreateWithoutDriverInput, TourBookingUncheckedCreateWithoutDriverInput>
  }

  export type TourBookingUpdateWithWhereUniqueWithoutDriverInput = {
    where: TourBookingWhereUniqueInput
    data: XOR<TourBookingUpdateWithoutDriverInput, TourBookingUncheckedUpdateWithoutDriverInput>
  }

  export type TourBookingUpdateManyWithWhereWithoutDriverInput = {
    where: TourBookingScalarWhereInput
    data: XOR<TourBookingUpdateManyMutationInput, TourBookingUncheckedUpdateManyWithoutDriverInput>
  }

  export type ActivityCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    tenantId?: string | null
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutUserInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    paymentStatus?: string
    createdAt?: Date | string
    isReturn?: boolean
    distanceKm?: number | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    driver?: DriverCreateNestedOneWithoutReservationsInput
    returnTransfer?: ReservationCreateNestedOneWithoutOriginalTransferInput
    originalTransfer?: ReservationCreateNestedOneWithoutReturnTransferInput
    tenant?: TenantCreateNestedOneWithoutReservationsInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutUserInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    driverId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    returnTransferId?: string | null
    isReturn?: boolean
    distanceKm?: number | null
    tenantId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    originalTransfer?: ReservationUncheckedCreateNestedOneWithoutReturnTransferInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutUserInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput>
  }

  export type ReservationCreateManyUserInputEnvelope = {
    data: ReservationCreateManyUserInput | ReservationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedUsersInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    reservations?: ReservationCreateNestedManyWithoutUserInput
    creator?: UserCreateNestedOneWithoutCreatedUsersInput
    permissions?: UserPermissionCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserUncheckedCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
  }

  export type UserCreateWithoutCreatorInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    reservations?: ReservationCreateNestedManyWithoutUserInput
    createdUsers?: UserCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatorInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserUncheckedCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput>
  }

  export type UserCreateManyCreatorInputEnvelope = {
    data: UserCreateManyCreatorInput | UserCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserPermissionCreateWithoutUserInput = {
    id?: string
    permission: string
    grantedBy?: string | null
    grantedAt?: Date | string
    isActive?: boolean
  }

  export type UserPermissionUncheckedCreateWithoutUserInput = {
    id?: string
    permission: string
    grantedBy?: string | null
    grantedAt?: Date | string
    isActive?: boolean
  }

  export type UserPermissionCreateOrConnectWithoutUserInput = {
    where: UserPermissionWhereUniqueInput
    create: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput>
  }

  export type UserPermissionCreateManyUserInputEnvelope = {
    data: UserPermissionCreateManyUserInput | UserPermissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HotelRequestCreateWithoutUserInput = {
    id?: string
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelBookings?: HotelBookingCreateNestedManyWithoutRequestInput
    tenant?: TenantCreateNestedOneWithoutHotelRequestsInput
  }

  export type HotelRequestUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId?: string | null
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutRequestInput
  }

  export type HotelRequestCreateOrConnectWithoutUserInput = {
    where: HotelRequestWhereUniqueInput
    create: XOR<HotelRequestCreateWithoutUserInput, HotelRequestUncheckedCreateWithoutUserInput>
  }

  export type HotelRequestCreateManyUserInputEnvelope = {
    data: HotelRequestCreateManyUserInput | HotelRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUserCreateWithoutUserInput = {
    id?: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type TenantUserUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUserCreateOrConnectWithoutUserInput = {
    where: TenantUserWhereUniqueInput
    create: XOR<TenantUserCreateWithoutUserInput, TenantUserUncheckedCreateWithoutUserInput>
  }

  export type TenantUserCreateManyUserInputEnvelope = {
    data: TenantUserCreateManyUserInput | TenantUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TourBookingCreateWithoutUserInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
    driver?: DriverCreateNestedOneWithoutTourBookingsInput
    tenant: TenantCreateNestedOneWithoutTourBookingsInput
  }

  export type TourBookingUncheckedCreateWithoutUserInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    tenantId: string
    driverId?: string | null
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
  }

  export type TourBookingCreateOrConnectWithoutUserInput = {
    where: TourBookingWhereUniqueInput
    create: XOR<TourBookingCreateWithoutUserInput, TourBookingUncheckedCreateWithoutUserInput>
  }

  export type TourBookingCreateManyUserInputEnvelope = {
    data: TourBookingCreateManyUserInput | TourBookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutUserInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutUserInput, ReservationUncheckedUpdateWithoutUserInput>
    create: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutUserInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutUserInput, ReservationUncheckedUpdateWithoutUserInput>
  }

  export type ReservationUpdateManyWithWhereWithoutUserInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    creator?: UserUpdateOneWithoutCreatedUsersNestedInput
    permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUncheckedUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatorInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatorInput, UserUncheckedUpdateWithoutCreatorInput>
    create: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatorInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatorInput, UserUncheckedUpdateWithoutCreatorInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatorInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatorInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdBy?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserPermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPermissionWhereUniqueInput
    update: XOR<UserPermissionUpdateWithoutUserInput, UserPermissionUncheckedUpdateWithoutUserInput>
    create: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput>
  }

  export type UserPermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPermissionWhereUniqueInput
    data: XOR<UserPermissionUpdateWithoutUserInput, UserPermissionUncheckedUpdateWithoutUserInput>
  }

  export type UserPermissionUpdateManyWithWhereWithoutUserInput = {
    where: UserPermissionScalarWhereInput
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPermissionScalarWhereInput = {
    AND?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
    OR?: UserPermissionScalarWhereInput[]
    NOT?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
    id?: StringFilter<"UserPermission"> | string
    userId?: StringFilter<"UserPermission"> | string
    permission?: StringFilter<"UserPermission"> | string
    grantedBy?: StringNullableFilter<"UserPermission"> | string | null
    grantedAt?: DateTimeFilter<"UserPermission"> | Date | string
    isActive?: BoolFilter<"UserPermission"> | boolean
  }

  export type HotelRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: HotelRequestWhereUniqueInput
    update: XOR<HotelRequestUpdateWithoutUserInput, HotelRequestUncheckedUpdateWithoutUserInput>
    create: XOR<HotelRequestCreateWithoutUserInput, HotelRequestUncheckedCreateWithoutUserInput>
  }

  export type HotelRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: HotelRequestWhereUniqueInput
    data: XOR<HotelRequestUpdateWithoutUserInput, HotelRequestUncheckedUpdateWithoutUserInput>
  }

  export type HotelRequestUpdateManyWithWhereWithoutUserInput = {
    where: HotelRequestScalarWhereInput
    data: XOR<HotelRequestUpdateManyMutationInput, HotelRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantUserUpsertWithWhereUniqueWithoutUserInput = {
    where: TenantUserWhereUniqueInput
    update: XOR<TenantUserUpdateWithoutUserInput, TenantUserUncheckedUpdateWithoutUserInput>
    create: XOR<TenantUserCreateWithoutUserInput, TenantUserUncheckedCreateWithoutUserInput>
  }

  export type TenantUserUpdateWithWhereUniqueWithoutUserInput = {
    where: TenantUserWhereUniqueInput
    data: XOR<TenantUserUpdateWithoutUserInput, TenantUserUncheckedUpdateWithoutUserInput>
  }

  export type TenantUserUpdateManyWithWhereWithoutUserInput = {
    where: TenantUserScalarWhereInput
    data: XOR<TenantUserUpdateManyMutationInput, TenantUserUncheckedUpdateManyWithoutUserInput>
  }

  export type TourBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: TourBookingWhereUniqueInput
    update: XOR<TourBookingUpdateWithoutUserInput, TourBookingUncheckedUpdateWithoutUserInput>
    create: XOR<TourBookingCreateWithoutUserInput, TourBookingUncheckedCreateWithoutUserInput>
  }

  export type TourBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: TourBookingWhereUniqueInput
    data: XOR<TourBookingUpdateWithoutUserInput, TourBookingUncheckedUpdateWithoutUserInput>
  }

  export type TourBookingUpdateManyWithWhereWithoutUserInput = {
    where: TourBookingScalarWhereInput
    data: XOR<TourBookingUpdateManyMutationInput, TourBookingUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutPermissionsInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    reservations?: ReservationCreateNestedManyWithoutUserInput
    creator?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatorInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPermissionsInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatorInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserUncheckedCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
  }

  export type UserUpsertWithoutPermissionsInput = {
    update: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    creator?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatorNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatorNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUncheckedUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutActivitiesInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutActivitiesInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutActivitiesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutActivitiesInput, TenantUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutUserInput
    creator?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserUncheckedCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type TenantUpsertWithoutActivitiesInput = {
    update: XOR<TenantUpdateWithoutActivitiesInput, TenantUncheckedUpdateWithoutActivitiesInput>
    create: XOR<TenantCreateWithoutActivitiesInput, TenantUncheckedCreateWithoutActivitiesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutActivitiesInput, TenantUncheckedUpdateWithoutActivitiesInput>
  }

  export type TenantUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    creator?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUncheckedUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DriverCreateWithoutReservationsInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    createdAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutDriversInput
    tourBookings?: TourBookingCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutReservationsInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    tenantId?: string | null
    createdAt?: Date | string
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutReservationsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutReservationsInput, DriverUncheckedCreateWithoutReservationsInput>
  }

  export type ReservationCreateWithoutOriginalTransferInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    paymentStatus?: string
    createdAt?: Date | string
    isReturn?: boolean
    distanceKm?: number | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    driver?: DriverCreateNestedOneWithoutReservationsInput
    returnTransfer?: ReservationCreateNestedOneWithoutOriginalTransferInput
    tenant?: TenantCreateNestedOneWithoutReservationsInput
    user?: UserCreateNestedOneWithoutReservationsInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutOriginalTransferInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    driverId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    returnTransferId?: string | null
    isReturn?: boolean
    distanceKm?: number | null
    userId?: string | null
    tenantId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutOriginalTransferInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutOriginalTransferInput, ReservationUncheckedCreateWithoutOriginalTransferInput>
  }

  export type ReservationCreateWithoutReturnTransferInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    paymentStatus?: string
    createdAt?: Date | string
    isReturn?: boolean
    distanceKm?: number | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    driver?: DriverCreateNestedOneWithoutReservationsInput
    originalTransfer?: ReservationCreateNestedOneWithoutReturnTransferInput
    tenant?: TenantCreateNestedOneWithoutReservationsInput
    user?: UserCreateNestedOneWithoutReservationsInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutReturnTransferInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    driverId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    isReturn?: boolean
    distanceKm?: number | null
    userId?: string | null
    tenantId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    originalTransfer?: ReservationUncheckedCreateNestedOneWithoutReturnTransferInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutReturnTransferInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutReturnTransferInput, ReservationUncheckedCreateWithoutReturnTransferInput>
  }

  export type TenantCreateWithoutReservationsInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutReservationsInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutReservationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutReservationsInput, TenantUncheckedCreateWithoutReservationsInput>
  }

  export type UserCreateWithoutReservationsInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    creator?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReservationsInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserUncheckedCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReservationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReservationsInput, UserUncheckedCreateWithoutReservationsInput>
  }

  export type HotelBookingCreateWithoutReservationInput = {
    id?: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
    request?: HotelRequestCreateNestedOneWithoutHotelBookingsInput
    tenant?: TenantCreateNestedOneWithoutHotelBookingsInput
  }

  export type HotelBookingUncheckedCreateWithoutReservationInput = {
    id?: string
    tenantId?: string | null
    requestId?: string | null
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
  }

  export type HotelBookingCreateOrConnectWithoutReservationInput = {
    where: HotelBookingWhereUniqueInput
    create: XOR<HotelBookingCreateWithoutReservationInput, HotelBookingUncheckedCreateWithoutReservationInput>
  }

  export type HotelBookingCreateManyReservationInputEnvelope = {
    data: HotelBookingCreateManyReservationInput | HotelBookingCreateManyReservationInput[]
    skipDuplicates?: boolean
  }

  export type DriverUpsertWithoutReservationsInput = {
    update: XOR<DriverUpdateWithoutReservationsInput, DriverUncheckedUpdateWithoutReservationsInput>
    create: XOR<DriverCreateWithoutReservationsInput, DriverUncheckedCreateWithoutReservationsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutReservationsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutReservationsInput, DriverUncheckedUpdateWithoutReservationsInput>
  }

  export type DriverUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutDriversNestedInput
    tourBookings?: TourBookingUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourBookings?: TourBookingUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type ReservationUpsertWithoutOriginalTransferInput = {
    update: XOR<ReservationUpdateWithoutOriginalTransferInput, ReservationUncheckedUpdateWithoutOriginalTransferInput>
    create: XOR<ReservationCreateWithoutOriginalTransferInput, ReservationUncheckedCreateWithoutOriginalTransferInput>
    where?: ReservationWhereInput
  }

  export type ReservationUpdateToOneWithWhereWithoutOriginalTransferInput = {
    where?: ReservationWhereInput
    data: XOR<ReservationUpdateWithoutOriginalTransferInput, ReservationUncheckedUpdateWithoutOriginalTransferInput>
  }

  export type ReservationUpdateWithoutOriginalTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    driver?: DriverUpdateOneWithoutReservationsNestedInput
    returnTransfer?: ReservationUpdateOneWithoutOriginalTransferNestedInput
    tenant?: TenantUpdateOneWithoutReservationsNestedInput
    user?: UserUpdateOneWithoutReservationsNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutOriginalTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUpsertWithoutReturnTransferInput = {
    update: XOR<ReservationUpdateWithoutReturnTransferInput, ReservationUncheckedUpdateWithoutReturnTransferInput>
    create: XOR<ReservationCreateWithoutReturnTransferInput, ReservationUncheckedCreateWithoutReturnTransferInput>
    where?: ReservationWhereInput
  }

  export type ReservationUpdateToOneWithWhereWithoutReturnTransferInput = {
    where?: ReservationWhereInput
    data: XOR<ReservationUpdateWithoutReturnTransferInput, ReservationUncheckedUpdateWithoutReturnTransferInput>
  }

  export type ReservationUpdateWithoutReturnTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    driver?: DriverUpdateOneWithoutReservationsNestedInput
    originalTransfer?: ReservationUpdateOneWithoutReturnTransferNestedInput
    tenant?: TenantUpdateOneWithoutReservationsNestedInput
    user?: UserUpdateOneWithoutReservationsNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutReturnTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    originalTransfer?: ReservationUncheckedUpdateOneWithoutReturnTransferNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type TenantUpsertWithoutReservationsInput = {
    update: XOR<TenantUpdateWithoutReservationsInput, TenantUncheckedUpdateWithoutReservationsInput>
    create: XOR<TenantCreateWithoutReservationsInput, TenantUncheckedCreateWithoutReservationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutReservationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutReservationsInput, TenantUncheckedUpdateWithoutReservationsInput>
  }

  export type TenantUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutReservationsInput = {
    update: XOR<UserUpdateWithoutReservationsInput, UserUncheckedUpdateWithoutReservationsInput>
    create: XOR<UserCreateWithoutReservationsInput, UserUncheckedCreateWithoutReservationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReservationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReservationsInput, UserUncheckedUpdateWithoutReservationsInput>
  }

  export type UserUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    creator?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUncheckedUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HotelBookingUpsertWithWhereUniqueWithoutReservationInput = {
    where: HotelBookingWhereUniqueInput
    update: XOR<HotelBookingUpdateWithoutReservationInput, HotelBookingUncheckedUpdateWithoutReservationInput>
    create: XOR<HotelBookingCreateWithoutReservationInput, HotelBookingUncheckedCreateWithoutReservationInput>
  }

  export type HotelBookingUpdateWithWhereUniqueWithoutReservationInput = {
    where: HotelBookingWhereUniqueInput
    data: XOR<HotelBookingUpdateWithoutReservationInput, HotelBookingUncheckedUpdateWithoutReservationInput>
  }

  export type HotelBookingUpdateManyWithWhereWithoutReservationInput = {
    where: HotelBookingScalarWhereInput
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyWithoutReservationInput>
  }

  export type HotelBookingCreateWithoutRequestInput = {
    id?: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
    reservation?: ReservationCreateNestedOneWithoutHotelBookingsInput
    tenant?: TenantCreateNestedOneWithoutHotelBookingsInput
  }

  export type HotelBookingUncheckedCreateWithoutRequestInput = {
    id?: string
    tenantId?: string | null
    reservationId?: string | null
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
  }

  export type HotelBookingCreateOrConnectWithoutRequestInput = {
    where: HotelBookingWhereUniqueInput
    create: XOR<HotelBookingCreateWithoutRequestInput, HotelBookingUncheckedCreateWithoutRequestInput>
  }

  export type HotelBookingCreateManyRequestInputEnvelope = {
    data: HotelBookingCreateManyRequestInput | HotelBookingCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutHotelRequestsInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    reservations?: ReservationCreateNestedManyWithoutUserInput
    creator?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHotelRequestsInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserUncheckedCreateNestedManyWithoutUserInput
    tour_bookings?: TourBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHotelRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHotelRequestsInput, UserUncheckedCreateWithoutHotelRequestsInput>
  }

  export type TenantCreateWithoutHotelRequestsInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutHotelRequestsInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutHotelRequestsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutHotelRequestsInput, TenantUncheckedCreateWithoutHotelRequestsInput>
  }

  export type HotelBookingUpsertWithWhereUniqueWithoutRequestInput = {
    where: HotelBookingWhereUniqueInput
    update: XOR<HotelBookingUpdateWithoutRequestInput, HotelBookingUncheckedUpdateWithoutRequestInput>
    create: XOR<HotelBookingCreateWithoutRequestInput, HotelBookingUncheckedCreateWithoutRequestInput>
  }

  export type HotelBookingUpdateWithWhereUniqueWithoutRequestInput = {
    where: HotelBookingWhereUniqueInput
    data: XOR<HotelBookingUpdateWithoutRequestInput, HotelBookingUncheckedUpdateWithoutRequestInput>
  }

  export type HotelBookingUpdateManyWithWhereWithoutRequestInput = {
    where: HotelBookingScalarWhereInput
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyWithoutRequestInput>
  }

  export type UserUpsertWithoutHotelRequestsInput = {
    update: XOR<UserUpdateWithoutHotelRequestsInput, UserUncheckedUpdateWithoutHotelRequestsInput>
    create: XOR<UserCreateWithoutHotelRequestsInput, UserUncheckedCreateWithoutHotelRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHotelRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHotelRequestsInput, UserUncheckedUpdateWithoutHotelRequestsInput>
  }

  export type UserUpdateWithoutHotelRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    creator?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHotelRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUncheckedUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantUpsertWithoutHotelRequestsInput = {
    update: XOR<TenantUpdateWithoutHotelRequestsInput, TenantUncheckedUpdateWithoutHotelRequestsInput>
    create: XOR<TenantCreateWithoutHotelRequestsInput, TenantUncheckedCreateWithoutHotelRequestsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutHotelRequestsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutHotelRequestsInput, TenantUncheckedUpdateWithoutHotelRequestsInput>
  }

  export type TenantUpdateWithoutHotelRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutHotelRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type HotelRequestCreateWithoutHotelBookingsInput = {
    id?: string
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutHotelRequestsInput
    tenant?: TenantCreateNestedOneWithoutHotelRequestsInput
  }

  export type HotelRequestUncheckedCreateWithoutHotelBookingsInput = {
    id?: string
    tenantId?: string | null
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    assignedTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelRequestCreateOrConnectWithoutHotelBookingsInput = {
    where: HotelRequestWhereUniqueInput
    create: XOR<HotelRequestCreateWithoutHotelBookingsInput, HotelRequestUncheckedCreateWithoutHotelBookingsInput>
  }

  export type ReservationCreateWithoutHotelBookingsInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    paymentStatus?: string
    createdAt?: Date | string
    isReturn?: boolean
    distanceKm?: number | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    driver?: DriverCreateNestedOneWithoutReservationsInput
    returnTransfer?: ReservationCreateNestedOneWithoutOriginalTransferInput
    originalTransfer?: ReservationCreateNestedOneWithoutReturnTransferInput
    tenant?: TenantCreateNestedOneWithoutReservationsInput
    user?: UserCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutHotelBookingsInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    driverId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    returnTransferId?: string | null
    isReturn?: boolean
    distanceKm?: number | null
    userId?: string | null
    tenantId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
    originalTransfer?: ReservationUncheckedCreateNestedOneWithoutReturnTransferInput
  }

  export type ReservationCreateOrConnectWithoutHotelBookingsInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutHotelBookingsInput, ReservationUncheckedCreateWithoutHotelBookingsInput>
  }

  export type TenantCreateWithoutHotelBookingsInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutHotelBookingsInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutHotelBookingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutHotelBookingsInput, TenantUncheckedCreateWithoutHotelBookingsInput>
  }

  export type HotelRequestUpsertWithoutHotelBookingsInput = {
    update: XOR<HotelRequestUpdateWithoutHotelBookingsInput, HotelRequestUncheckedUpdateWithoutHotelBookingsInput>
    create: XOR<HotelRequestCreateWithoutHotelBookingsInput, HotelRequestUncheckedCreateWithoutHotelBookingsInput>
    where?: HotelRequestWhereInput
  }

  export type HotelRequestUpdateToOneWithWhereWithoutHotelBookingsInput = {
    where?: HotelRequestWhereInput
    data: XOR<HotelRequestUpdateWithoutHotelBookingsInput, HotelRequestUncheckedUpdateWithoutHotelBookingsInput>
  }

  export type HotelRequestUpdateWithoutHotelBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutHotelRequestsNestedInput
    tenant?: TenantUpdateOneWithoutHotelRequestsNestedInput
  }

  export type HotelRequestUncheckedUpdateWithoutHotelBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpsertWithoutHotelBookingsInput = {
    update: XOR<ReservationUpdateWithoutHotelBookingsInput, ReservationUncheckedUpdateWithoutHotelBookingsInput>
    create: XOR<ReservationCreateWithoutHotelBookingsInput, ReservationUncheckedCreateWithoutHotelBookingsInput>
    where?: ReservationWhereInput
  }

  export type ReservationUpdateToOneWithWhereWithoutHotelBookingsInput = {
    where?: ReservationWhereInput
    data: XOR<ReservationUpdateWithoutHotelBookingsInput, ReservationUncheckedUpdateWithoutHotelBookingsInput>
  }

  export type ReservationUpdateWithoutHotelBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    driver?: DriverUpdateOneWithoutReservationsNestedInput
    returnTransfer?: ReservationUpdateOneWithoutOriginalTransferNestedInput
    originalTransfer?: ReservationUpdateOneWithoutReturnTransferNestedInput
    tenant?: TenantUpdateOneWithoutReservationsNestedInput
    user?: UserUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutHotelBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    originalTransfer?: ReservationUncheckedUpdateOneWithoutReturnTransferNestedInput
  }

  export type TenantUpsertWithoutHotelBookingsInput = {
    update: XOR<TenantUpdateWithoutHotelBookingsInput, TenantUncheckedUpdateWithoutHotelBookingsInput>
    create: XOR<TenantCreateWithoutHotelBookingsInput, TenantUncheckedCreateWithoutHotelBookingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutHotelBookingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutHotelBookingsInput, TenantUncheckedUpdateWithoutHotelBookingsInput>
  }

  export type TenantUpdateWithoutHotelBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutHotelBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutHotelPricePoolInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutHotelPricePoolInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutHotelPricePoolInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutHotelPricePoolInput, TenantUncheckedCreateWithoutHotelPricePoolInput>
  }

  export type TenantUpsertWithoutHotelPricePoolInput = {
    update: XOR<TenantUpdateWithoutHotelPricePoolInput, TenantUncheckedUpdateWithoutHotelPricePoolInput>
    create: XOR<TenantCreateWithoutHotelPricePoolInput, TenantUncheckedCreateWithoutHotelPricePoolInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutHotelPricePoolInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutHotelPricePoolInput, TenantUncheckedUpdateWithoutHotelPricePoolInput>
  }

  export type TenantUpdateWithoutHotelPricePoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutHotelPricePoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutVehiclesInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVehiclesInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVehiclesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVehiclesInput, TenantUncheckedCreateWithoutVehiclesInput>
  }

  export type TenantUpsertWithoutVehiclesInput = {
    update: XOR<TenantUpdateWithoutVehiclesInput, TenantUncheckedUpdateWithoutVehiclesInput>
    create: XOR<TenantCreateWithoutVehiclesInput, TenantUncheckedCreateWithoutVehiclesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVehiclesInput, TenantUncheckedUpdateWithoutVehiclesInput>
  }

  export type TenantUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DriverCreateWithoutTourBookingsInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    createdAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutDriverInput
    tenant?: TenantCreateNestedOneWithoutDriversInput
  }

  export type DriverUncheckedCreateWithoutTourBookingsInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    tenantId?: string | null
    createdAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutTourBookingsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutTourBookingsInput, DriverUncheckedCreateWithoutTourBookingsInput>
  }

  export type TenantCreateWithoutTourBookingsInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTourBookingsInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTourBookingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTourBookingsInput, TenantUncheckedCreateWithoutTourBookingsInput>
  }

  export type UserCreateWithoutTour_bookingsInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    reservations?: ReservationCreateNestedManyWithoutUserInput
    creator?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTour_bookingsInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatorInput
    permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutUserInput
    tenantUsers?: TenantUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTour_bookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTour_bookingsInput, UserUncheckedCreateWithoutTour_bookingsInput>
  }

  export type DriverUpsertWithoutTourBookingsInput = {
    update: XOR<DriverUpdateWithoutTourBookingsInput, DriverUncheckedUpdateWithoutTourBookingsInput>
    create: XOR<DriverCreateWithoutTourBookingsInput, DriverUncheckedCreateWithoutTourBookingsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutTourBookingsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutTourBookingsInput, DriverUncheckedUpdateWithoutTourBookingsInput>
  }

  export type DriverUpdateWithoutTourBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutDriverNestedInput
    tenant?: TenantUpdateOneWithoutDriversNestedInput
  }

  export type DriverUncheckedUpdateWithoutTourBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type TenantUpsertWithoutTourBookingsInput = {
    update: XOR<TenantUpdateWithoutTourBookingsInput, TenantUncheckedUpdateWithoutTourBookingsInput>
    create: XOR<TenantCreateWithoutTourBookingsInput, TenantUncheckedCreateWithoutTourBookingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTourBookingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTourBookingsInput, TenantUncheckedUpdateWithoutTourBookingsInput>
  }

  export type TenantUpdateWithoutTourBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTourBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutTour_bookingsInput = {
    update: XOR<UserUpdateWithoutTour_bookingsInput, UserUncheckedUpdateWithoutTour_bookingsInput>
    create: XOR<UserCreateWithoutTour_bookingsInput, UserUncheckedCreateWithoutTour_bookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTour_bookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTour_bookingsInput, UserUncheckedUpdateWithoutTour_bookingsInput>
  }

  export type UserUpdateWithoutTour_bookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    creator?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTour_bookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutWebsitesInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityCreateNestedManyWithoutTenantInput
    reservations?: ReservationCreateNestedManyWithoutTenantInput
    drivers?: DriverCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestCreateNestedManyWithoutTenantInput
    modules?: TenantModuleCreateNestedManyWithoutTenantInput
    users?: TenantUserCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWebsitesInput = {
    id?: string
    subdomain: string
    companyName: string
    domain?: string | null
    isActive?: boolean
    subscriptionPlan?: string
    websiteModuleEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAccountHolder?: string | null
    paymentBank?: string | null
    paymentIban?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutTenantInput
    drivers?: DriverUncheckedCreateNestedManyWithoutTenantInput
    hotelBookings?: HotelBookingUncheckedCreateNestedManyWithoutTenantInput
    hotelPricePool?: HotelPricePoolUncheckedCreateNestedManyWithoutTenantInput
    hotelRequests?: HotelRequestUncheckedCreateNestedManyWithoutTenantInput
    modules?: TenantModuleUncheckedCreateNestedManyWithoutTenantInput
    users?: TenantUserUncheckedCreateNestedManyWithoutTenantInput
    tourBookings?: TourBookingUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWebsitesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWebsitesInput, TenantUncheckedCreateWithoutWebsitesInput>
  }

  export type WebsitePageCreateWithoutWebsiteInput = {
    id?: string
    slug: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    isHomepage?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsitePageUncheckedCreateWithoutWebsiteInput = {
    id?: string
    slug: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    isHomepage?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsitePageCreateOrConnectWithoutWebsiteInput = {
    where: WebsitePageWhereUniqueInput
    create: XOR<WebsitePageCreateWithoutWebsiteInput, WebsitePageUncheckedCreateWithoutWebsiteInput>
  }

  export type WebsitePageCreateManyWebsiteInputEnvelope = {
    data: WebsitePageCreateManyWebsiteInput | WebsitePageCreateManyWebsiteInput[]
    skipDuplicates?: boolean
  }

  export type WebsiteSettingsCreateWithoutWebsiteInput = {
    id?: string
    companyName: string
    logo?: string | null
    heroTitle: string
    heroSubtitle: string
    heroImage?: string | null
    contactInfo: JsonNullValueInput | InputJsonValue
    socialMedia: JsonNullValueInput | InputJsonValue
    seoSettings: JsonNullValueInput | InputJsonValue
    colorScheme: JsonNullValueInput | InputJsonValue
    customCSS?: string | null
    analyticsCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteSettingsUncheckedCreateWithoutWebsiteInput = {
    id?: string
    companyName: string
    logo?: string | null
    heroTitle: string
    heroSubtitle: string
    heroImage?: string | null
    contactInfo: JsonNullValueInput | InputJsonValue
    socialMedia: JsonNullValueInput | InputJsonValue
    seoSettings: JsonNullValueInput | InputJsonValue
    colorScheme: JsonNullValueInput | InputJsonValue
    customCSS?: string | null
    analyticsCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteSettingsCreateOrConnectWithoutWebsiteInput = {
    where: WebsiteSettingsWhereUniqueInput
    create: XOR<WebsiteSettingsCreateWithoutWebsiteInput, WebsiteSettingsUncheckedCreateWithoutWebsiteInput>
  }

  export type WebsiteSectionCreateWithoutWebsiteInput = {
    id?: string
    sectionType: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteSectionUncheckedCreateWithoutWebsiteInput = {
    id?: string
    sectionType: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteSectionCreateOrConnectWithoutWebsiteInput = {
    where: WebsiteSectionWhereUniqueInput
    create: XOR<WebsiteSectionCreateWithoutWebsiteInput, WebsiteSectionUncheckedCreateWithoutWebsiteInput>
  }

  export type WebsiteSectionCreateManyWebsiteInputEnvelope = {
    data: WebsiteSectionCreateManyWebsiteInput | WebsiteSectionCreateManyWebsiteInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutWebsitesInput = {
    update: XOR<TenantUpdateWithoutWebsitesInput, TenantUncheckedUpdateWithoutWebsitesInput>
    create: XOR<TenantCreateWithoutWebsitesInput, TenantUncheckedCreateWithoutWebsitesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWebsitesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWebsitesInput, TenantUncheckedUpdateWithoutWebsitesInput>
  }

  export type TenantUpdateWithoutWebsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUpdateManyWithoutTenantNestedInput
    drivers?: DriverUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUpdateManyWithoutTenantNestedInput
    users?: TenantUserUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWebsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionPlan?: StringFieldUpdateOperationsInput | string
    websiteModuleEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAccountHolder?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBank?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIban?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutTenantNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutTenantNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutTenantNestedInput
    hotelPricePool?: HotelPricePoolUncheckedUpdateManyWithoutTenantNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutTenantNestedInput
    modules?: TenantModuleUncheckedUpdateManyWithoutTenantNestedInput
    users?: TenantUserUncheckedUpdateManyWithoutTenantNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type WebsitePageUpsertWithWhereUniqueWithoutWebsiteInput = {
    where: WebsitePageWhereUniqueInput
    update: XOR<WebsitePageUpdateWithoutWebsiteInput, WebsitePageUncheckedUpdateWithoutWebsiteInput>
    create: XOR<WebsitePageCreateWithoutWebsiteInput, WebsitePageUncheckedCreateWithoutWebsiteInput>
  }

  export type WebsitePageUpdateWithWhereUniqueWithoutWebsiteInput = {
    where: WebsitePageWhereUniqueInput
    data: XOR<WebsitePageUpdateWithoutWebsiteInput, WebsitePageUncheckedUpdateWithoutWebsiteInput>
  }

  export type WebsitePageUpdateManyWithWhereWithoutWebsiteInput = {
    where: WebsitePageScalarWhereInput
    data: XOR<WebsitePageUpdateManyMutationInput, WebsitePageUncheckedUpdateManyWithoutWebsiteInput>
  }

  export type WebsitePageScalarWhereInput = {
    AND?: WebsitePageScalarWhereInput | WebsitePageScalarWhereInput[]
    OR?: WebsitePageScalarWhereInput[]
    NOT?: WebsitePageScalarWhereInput | WebsitePageScalarWhereInput[]
    id?: StringFilter<"WebsitePage"> | string
    websiteId?: StringFilter<"WebsitePage"> | string
    slug?: StringFilter<"WebsitePage"> | string
    title?: StringFilter<"WebsitePage"> | string
    content?: JsonFilter<"WebsitePage">
    metaTitle?: StringNullableFilter<"WebsitePage"> | string | null
    metaDescription?: StringNullableFilter<"WebsitePage"> | string | null
    isPublished?: BoolFilter<"WebsitePage"> | boolean
    isHomepage?: BoolFilter<"WebsitePage"> | boolean
    sortOrder?: IntFilter<"WebsitePage"> | number
    createdAt?: DateTimeFilter<"WebsitePage"> | Date | string
    updatedAt?: DateTimeFilter<"WebsitePage"> | Date | string
  }

  export type WebsiteSettingsUpsertWithoutWebsiteInput = {
    update: XOR<WebsiteSettingsUpdateWithoutWebsiteInput, WebsiteSettingsUncheckedUpdateWithoutWebsiteInput>
    create: XOR<WebsiteSettingsCreateWithoutWebsiteInput, WebsiteSettingsUncheckedCreateWithoutWebsiteInput>
    where?: WebsiteSettingsWhereInput
  }

  export type WebsiteSettingsUpdateToOneWithWhereWithoutWebsiteInput = {
    where?: WebsiteSettingsWhereInput
    data: XOR<WebsiteSettingsUpdateWithoutWebsiteInput, WebsiteSettingsUncheckedUpdateWithoutWebsiteInput>
  }

  export type WebsiteSettingsUpdateWithoutWebsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: JsonNullValueInput | InputJsonValue
    socialMedia?: JsonNullValueInput | InputJsonValue
    seoSettings?: JsonNullValueInput | InputJsonValue
    colorScheme?: JsonNullValueInput | InputJsonValue
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSettingsUncheckedUpdateWithoutWebsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: JsonNullValueInput | InputJsonValue
    socialMedia?: JsonNullValueInput | InputJsonValue
    seoSettings?: JsonNullValueInput | InputJsonValue
    colorScheme?: JsonNullValueInput | InputJsonValue
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSectionUpsertWithWhereUniqueWithoutWebsiteInput = {
    where: WebsiteSectionWhereUniqueInput
    update: XOR<WebsiteSectionUpdateWithoutWebsiteInput, WebsiteSectionUncheckedUpdateWithoutWebsiteInput>
    create: XOR<WebsiteSectionCreateWithoutWebsiteInput, WebsiteSectionUncheckedCreateWithoutWebsiteInput>
  }

  export type WebsiteSectionUpdateWithWhereUniqueWithoutWebsiteInput = {
    where: WebsiteSectionWhereUniqueInput
    data: XOR<WebsiteSectionUpdateWithoutWebsiteInput, WebsiteSectionUncheckedUpdateWithoutWebsiteInput>
  }

  export type WebsiteSectionUpdateManyWithWhereWithoutWebsiteInput = {
    where: WebsiteSectionScalarWhereInput
    data: XOR<WebsiteSectionUpdateManyMutationInput, WebsiteSectionUncheckedUpdateManyWithoutWebsiteInput>
  }

  export type WebsiteSectionScalarWhereInput = {
    AND?: WebsiteSectionScalarWhereInput | WebsiteSectionScalarWhereInput[]
    OR?: WebsiteSectionScalarWhereInput[]
    NOT?: WebsiteSectionScalarWhereInput | WebsiteSectionScalarWhereInput[]
    id?: StringFilter<"WebsiteSection"> | string
    websiteId?: StringFilter<"WebsiteSection"> | string
    sectionType?: StringFilter<"WebsiteSection"> | string
    title?: StringNullableFilter<"WebsiteSection"> | string | null
    content?: JsonFilter<"WebsiteSection">
    isActive?: BoolFilter<"WebsiteSection"> | boolean
    sortOrder?: IntFilter<"WebsiteSection"> | number
    createdAt?: DateTimeFilter<"WebsiteSection"> | Date | string
    updatedAt?: DateTimeFilter<"WebsiteSection"> | Date | string
  }

  export type TenantWebsiteCreateWithoutPagesInput = {
    id?: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWebsitesInput
    settings?: WebsiteSettingsCreateNestedOneWithoutWebsiteInput
    sections?: WebsiteSectionCreateNestedManyWithoutWebsiteInput
  }

  export type TenantWebsiteUncheckedCreateWithoutPagesInput = {
    id?: string
    tenantId: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: WebsiteSettingsUncheckedCreateNestedOneWithoutWebsiteInput
    sections?: WebsiteSectionUncheckedCreateNestedManyWithoutWebsiteInput
  }

  export type TenantWebsiteCreateOrConnectWithoutPagesInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutPagesInput, TenantWebsiteUncheckedCreateWithoutPagesInput>
  }

  export type TenantWebsiteUpsertWithoutPagesInput = {
    update: XOR<TenantWebsiteUpdateWithoutPagesInput, TenantWebsiteUncheckedUpdateWithoutPagesInput>
    create: XOR<TenantWebsiteCreateWithoutPagesInput, TenantWebsiteUncheckedCreateWithoutPagesInput>
    where?: TenantWebsiteWhereInput
  }

  export type TenantWebsiteUpdateToOneWithWhereWithoutPagesInput = {
    where?: TenantWebsiteWhereInput
    data: XOR<TenantWebsiteUpdateWithoutPagesInput, TenantWebsiteUncheckedUpdateWithoutPagesInput>
  }

  export type TenantWebsiteUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWebsitesNestedInput
    settings?: WebsiteSettingsUpdateOneWithoutWebsiteNestedInput
    sections?: WebsiteSectionUpdateManyWithoutWebsiteNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: WebsiteSettingsUncheckedUpdateOneWithoutWebsiteNestedInput
    sections?: WebsiteSectionUncheckedUpdateManyWithoutWebsiteNestedInput
  }

  export type TenantWebsiteCreateWithoutSettingsInput = {
    id?: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWebsitesInput
    pages?: WebsitePageCreateNestedManyWithoutWebsiteInput
    sections?: WebsiteSectionCreateNestedManyWithoutWebsiteInput
  }

  export type TenantWebsiteUncheckedCreateWithoutSettingsInput = {
    id?: string
    tenantId: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: WebsitePageUncheckedCreateNestedManyWithoutWebsiteInput
    sections?: WebsiteSectionUncheckedCreateNestedManyWithoutWebsiteInput
  }

  export type TenantWebsiteCreateOrConnectWithoutSettingsInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutSettingsInput, TenantWebsiteUncheckedCreateWithoutSettingsInput>
  }

  export type TenantWebsiteUpsertWithoutSettingsInput = {
    update: XOR<TenantWebsiteUpdateWithoutSettingsInput, TenantWebsiteUncheckedUpdateWithoutSettingsInput>
    create: XOR<TenantWebsiteCreateWithoutSettingsInput, TenantWebsiteUncheckedCreateWithoutSettingsInput>
    where?: TenantWebsiteWhereInput
  }

  export type TenantWebsiteUpdateToOneWithWhereWithoutSettingsInput = {
    where?: TenantWebsiteWhereInput
    data: XOR<TenantWebsiteUpdateWithoutSettingsInput, TenantWebsiteUncheckedUpdateWithoutSettingsInput>
  }

  export type TenantWebsiteUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWebsitesNestedInput
    pages?: WebsitePageUpdateManyWithoutWebsiteNestedInput
    sections?: WebsiteSectionUpdateManyWithoutWebsiteNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: WebsitePageUncheckedUpdateManyWithoutWebsiteNestedInput
    sections?: WebsiteSectionUncheckedUpdateManyWithoutWebsiteNestedInput
  }

  export type TenantWebsiteCreateWithoutSectionsInput = {
    id?: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWebsitesInput
    pages?: WebsitePageCreateNestedManyWithoutWebsiteInput
    settings?: WebsiteSettingsCreateNestedOneWithoutWebsiteInput
  }

  export type TenantWebsiteUncheckedCreateWithoutSectionsInput = {
    id?: string
    tenantId: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: WebsitePageUncheckedCreateNestedManyWithoutWebsiteInput
    settings?: WebsiteSettingsUncheckedCreateNestedOneWithoutWebsiteInput
  }

  export type TenantWebsiteCreateOrConnectWithoutSectionsInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutSectionsInput, TenantWebsiteUncheckedCreateWithoutSectionsInput>
  }

  export type TenantWebsiteUpsertWithoutSectionsInput = {
    update: XOR<TenantWebsiteUpdateWithoutSectionsInput, TenantWebsiteUncheckedUpdateWithoutSectionsInput>
    create: XOR<TenantWebsiteCreateWithoutSectionsInput, TenantWebsiteUncheckedCreateWithoutSectionsInput>
    where?: TenantWebsiteWhereInput
  }

  export type TenantWebsiteUpdateToOneWithWhereWithoutSectionsInput = {
    where?: TenantWebsiteWhereInput
    data: XOR<TenantWebsiteUpdateWithoutSectionsInput, TenantWebsiteUncheckedUpdateWithoutSectionsInput>
  }

  export type TenantWebsiteUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWebsitesNestedInput
    pages?: WebsitePageUpdateManyWithoutWebsiteNestedInput
    settings?: WebsiteSettingsUpdateOneWithoutWebsiteNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: WebsitePageUncheckedUpdateManyWithoutWebsiteNestedInput
    settings?: WebsiteSettingsUncheckedUpdateOneWithoutWebsiteNestedInput
  }

  export type ActivityCreateManyTenantInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ReservationCreateManyTenantInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    driverId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    returnTransferId?: string | null
    isReturn?: boolean
    distanceKm?: number | null
    userId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
  }

  export type DriverCreateManyTenantInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    createdAt?: Date | string
  }

  export type HotelBookingCreateManyTenantInput = {
    id?: string
    requestId?: string | null
    reservationId?: string | null
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
  }

  export type HotelPricePoolCreateManyTenantInput = {
    id?: string
    hotelId: string
    hotelName: string
    hotelAddress: string
    hotelCity: string
    hotelCountry: string
    hotelRating: number
    hotelStars: number
    hotelImage?: string | null
    hotelAmenities?: string
    roomType: string
    roomName: string
    roomDescription?: string | null
    roomAmenities?: string
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    roomView?: string | null
    basePrice: number
    agentPrice: number
    customerPrice: number
    profitMargin: number
    profitPercentage: number
    currency?: string
    validFrom: Date | string
    validTo: Date | string
    cancellationPolicy?: string | null
    breakfastIncluded?: boolean
    freeCancellation?: boolean
    source?: string
    lastUpdated?: Date | string
    updatedBy: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelRequestCreateManyTenantInput = {
    id?: string
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    assignedTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantModuleCreateManyTenantInput = {
    id?: string
    moduleId: string
    isEnabled?: boolean
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUserCreateManyTenantInput = {
    id?: string
    userId: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourBookingCreateManyTenantInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    userId?: string | null
    driverId?: string | null
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
  }

  export type VehicleCreateManyTenantInput = {
    id?: string
    type: string
    capacity: number
    licensePlate: string
    driverName?: string | null
    driverPhone?: string | null
    isAvailable?: boolean
    lastMaintenance?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantWebsiteCreateManyTenantInput = {
    id?: string
    domain?: string | null
    subdomain?: string | null
    isActive?: boolean
    theme?: string
    customCSS?: string | null
    favicon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    driver?: DriverUpdateOneWithoutReservationsNestedInput
    returnTransfer?: ReservationUpdateOneWithoutOriginalTransferNestedInput
    originalTransfer?: ReservationUpdateOneWithoutReturnTransferNestedInput
    user?: UserUpdateOneWithoutReservationsNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    originalTransfer?: ReservationUncheckedUpdateOneWithoutReturnTransferNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DriverUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutDriverNestedInput
    tourBookings?: TourBookingUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutDriverNestedInput
    tourBookings?: TourBookingUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    request?: HotelRequestUpdateOneWithoutHotelBookingsNestedInput
    reservation?: ReservationUpdateOneWithoutHotelBookingsNestedInput
  }

  export type HotelBookingUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
  }

  export type HotelBookingUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
  }

  export type HotelPricePoolUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    hotelCity?: StringFieldUpdateOperationsInput | string
    hotelCountry?: StringFieldUpdateOperationsInput | string
    hotelRating?: FloatFieldUpdateOperationsInput | number
    hotelStars?: IntFieldUpdateOperationsInput | number
    hotelImage?: NullableStringFieldUpdateOperationsInput | string | null
    hotelAmenities?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    roomDescription?: NullableStringFieldUpdateOperationsInput | string | null
    roomAmenities?: StringFieldUpdateOperationsInput | string
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    roomView?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    breakfastIncluded?: BoolFieldUpdateOperationsInput | boolean
    freeCancellation?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelPricePoolUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    hotelCity?: StringFieldUpdateOperationsInput | string
    hotelCountry?: StringFieldUpdateOperationsInput | string
    hotelRating?: FloatFieldUpdateOperationsInput | number
    hotelStars?: IntFieldUpdateOperationsInput | number
    hotelImage?: NullableStringFieldUpdateOperationsInput | string | null
    hotelAmenities?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    roomDescription?: NullableStringFieldUpdateOperationsInput | string | null
    roomAmenities?: StringFieldUpdateOperationsInput | string
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    roomView?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    breakfastIncluded?: BoolFieldUpdateOperationsInput | boolean
    freeCancellation?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelPricePoolUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    hotelCity?: StringFieldUpdateOperationsInput | string
    hotelCountry?: StringFieldUpdateOperationsInput | string
    hotelRating?: FloatFieldUpdateOperationsInput | number
    hotelStars?: IntFieldUpdateOperationsInput | number
    hotelImage?: NullableStringFieldUpdateOperationsInput | string | null
    hotelAmenities?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    roomDescription?: NullableStringFieldUpdateOperationsInput | string | null
    roomAmenities?: StringFieldUpdateOperationsInput | string
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    roomView?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    breakfastIncluded?: BoolFieldUpdateOperationsInput | boolean
    freeCancellation?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelRequestUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelBookings?: HotelBookingUpdateManyWithoutRequestNestedInput
    user?: UserUpdateOneWithoutHotelRequestsNestedInput
  }

  export type HotelRequestUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type HotelRequestUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantModuleUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutTenantModulesNestedInput
  }

  export type TenantModuleUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantModuleUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTenantUsersNestedInput
  }

  export type TenantUserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourBookingUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
    driver?: DriverUpdateOneWithoutTourBookingsNestedInput
    User?: UserUpdateOneWithoutTour_bookingsNestedInput
  }

  export type TourBookingUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
  }

  export type TourBookingUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantWebsiteUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: WebsitePageUpdateManyWithoutWebsiteNestedInput
    settings?: WebsiteSettingsUpdateOneWithoutWebsiteNestedInput
    sections?: WebsiteSectionUpdateManyWithoutWebsiteNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: WebsitePageUncheckedUpdateManyWithoutWebsiteNestedInput
    settings?: WebsiteSettingsUncheckedUpdateOneWithoutWebsiteNestedInput
    sections?: WebsiteSectionUncheckedUpdateManyWithoutWebsiteNestedInput
  }

  export type TenantWebsiteUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    customCSS?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantModuleCreateManyModuleInput = {
    id?: string
    tenantId: string
    isEnabled?: boolean
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    features?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantModuleUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutModulesNestedInput
  }

  export type TenantModuleUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantModuleUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    features?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyDriverInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    paymentStatus?: string
    createdAt?: Date | string
    returnTransferId?: string | null
    isReturn?: boolean
    distanceKm?: number | null
    userId?: string | null
    tenantId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
  }

  export type TourBookingCreateManyDriverInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    tenantId: string
    userId?: string | null
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
  }

  export type ReservationUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    returnTransfer?: ReservationUpdateOneWithoutOriginalTransferNestedInput
    originalTransfer?: ReservationUpdateOneWithoutReturnTransferNestedInput
    tenant?: TenantUpdateOneWithoutReservationsNestedInput
    user?: UserUpdateOneWithoutReservationsNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    originalTransfer?: ReservationUncheckedUpdateOneWithoutReturnTransferNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type TourBookingUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
    tenant?: TenantUpdateOneRequiredWithoutTourBookingsNestedInput
    User?: UserUpdateOneWithoutTour_bookingsNestedInput
  }

  export type TourBookingUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
  }

  export type TourBookingUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    tenantId?: string | null
  }

  export type ReservationCreateManyUserInput = {
    id?: string
    date: string
    time: string
    from: string
    to: string
    flightCode: string
    passengerNames: string
    luggageCount: number
    price: number
    currency: string
    phoneNumber?: string | null
    voucherNumber: string
    driverFee?: number | null
    driverId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    returnTransferId?: string | null
    isReturn?: boolean
    distanceKm?: number | null
    tenantId?: string | null
    companyCommissionStatus?: string
    notes?: string | null
    email?: string | null
    type?: string
  }

  export type UserCreateManyCreatorInput = {
    id?: string
    username: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPermissionCreateManyUserInput = {
    id?: string
    permission: string
    grantedBy?: string | null
    grantedAt?: Date | string
    isActive?: boolean
  }

  export type HotelRequestCreateManyUserInput = {
    id?: string
    tenantId?: string | null
    customerName: string
    customerEmail: string
    customerPhone: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children?: number
    rooms?: number
    city: string
    region?: string | null
    budget?: number | null
    roomType?: string | null
    breakfast?: boolean
    amenities?: string
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUserCreateManyUserInput = {
    id?: string
    tenantId: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourBookingCreateManyUserInput = {
    id?: string
    voucherNumber: string
    routeName: string
    vehicleType: string
    groupSize: number
    price: number
    currency?: string
    pickupLocation: string
    tourDate: Date | string
    tourTime?: string | null
    passengerNames: string
    notes?: string | null
    status?: string
    tenantId: string
    driverId?: string | null
    driverFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tourDuration?: number
  }

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    driver?: DriverUpdateOneWithoutReservationsNestedInput
    returnTransfer?: ReservationUpdateOneWithoutOriginalTransferNestedInput
    originalTransfer?: ReservationUpdateOneWithoutReturnTransferNestedInput
    tenant?: TenantUpdateOneWithoutReservationsNestedInput
    hotelBookings?: HotelBookingUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    originalTransfer?: ReservationUncheckedUpdateOneWithoutReturnTransferNestedInput
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    flightCode?: StringFieldUpdateOperationsInput | string
    passengerNames?: StringFieldUpdateOperationsInput | string
    luggageCount?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    voucherNumber?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    isReturn?: BoolFieldUpdateOperationsInput | boolean
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyCommissionStatus?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    createdUsers?: UserUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatorNestedInput
    permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    hotelRequests?: HotelRequestUncheckedUpdateManyWithoutUserNestedInput
    tenantUsers?: TenantUserUncheckedUpdateManyWithoutUserNestedInput
    tour_bookings?: TourBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPermissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPermissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPermissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelBookings?: HotelBookingUpdateManyWithoutRequestNestedInput
    tenant?: TenantUpdateOneWithoutHotelRequestsNestedInput
  }

  export type HotelRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelBookings?: HotelBookingUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type HotelRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    breakfast?: BoolFieldUpdateOperationsInput | boolean
    amenities?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type TenantUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourBookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
    driver?: DriverUpdateOneWithoutTourBookingsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTourBookingsNestedInput
  }

  export type TourBookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
  }

  export type TourBookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNumber?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    tourDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tourTime?: NullableStringFieldUpdateOperationsInput | string | null
    passengerNames?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    driverFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourDuration?: IntFieldUpdateOperationsInput | number
  }

  export type HotelBookingCreateManyReservationInput = {
    id?: string
    tenantId?: string | null
    requestId?: string | null
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
  }

  export type HotelBookingUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    request?: HotelRequestUpdateOneWithoutHotelBookingsNestedInput
    tenant?: TenantUpdateOneWithoutHotelBookingsNestedInput
  }

  export type HotelBookingUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
  }

  export type HotelBookingUncheckedUpdateManyWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
  }

  export type HotelBookingCreateManyRequestInput = {
    id?: string
    tenantId?: string | null
    reservationId?: string | null
    hotelId: string
    hotelName: string
    hotelAddress: string
    roomType: string
    checkin: Date | string
    checkout: Date | string
    adults: number
    children: number
    rooms: number
    totalPrice: number
    currency?: string
    bookingReference: string
    status?: string
    customerInfo: JsonNullValueInput | InputJsonValue
    specialRequests?: string | null
    cancellationPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentPrice: number
    customerPrice: number
    profitMargin: number
    voucherNumber: string
  }

  export type HotelBookingUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
    reservation?: ReservationUpdateOneWithoutHotelBookingsNestedInput
    tenant?: TenantUpdateOneWithoutHotelBookingsNestedInput
  }

  export type HotelBookingUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
  }

  export type HotelBookingUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelId?: StringFieldUpdateOperationsInput | string
    hotelName?: StringFieldUpdateOperationsInput | string
    hotelAddress?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    checkin?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerInfo?: JsonNullValueInput | InputJsonValue
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentPrice?: FloatFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    voucherNumber?: StringFieldUpdateOperationsInput | string
  }

  export type WebsitePageCreateManyWebsiteInput = {
    id?: string
    slug: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    isHomepage?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteSectionCreateManyWebsiteInput = {
    id?: string
    sectionType: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsitePageUpdateWithoutWebsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isHomepage?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsitePageUncheckedUpdateWithoutWebsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isHomepage?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsitePageUncheckedUpdateManyWithoutWebsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isHomepage?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSectionUpdateWithoutWebsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSectionUncheckedUpdateWithoutWebsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSectionUncheckedUpdateManyWithoutWebsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}